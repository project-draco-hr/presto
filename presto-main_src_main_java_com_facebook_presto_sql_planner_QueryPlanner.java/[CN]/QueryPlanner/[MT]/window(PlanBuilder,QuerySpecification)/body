{
  Set<FunctionCall> windowFunctions=ImmutableSet.copyOf(analysis.getWindowFunctions(node));
  if (windowFunctions.isEmpty()) {
    return subPlan;
  }
  for (  FunctionCall windowFunction : windowFunctions) {
    Window window=windowFunction.getWindow().get();
    WindowFrame.Type frameType=WindowFrame.Type.RANGE;
    FrameBound.Type frameStartType=FrameBound.Type.UNBOUNDED_PRECEDING;
    FrameBound.Type frameEndType=FrameBound.Type.CURRENT_ROW;
    Expression frameStart=null;
    Expression frameEnd=null;
    if (window.getFrame().isPresent()) {
      WindowFrame frame=window.getFrame().get();
      frameType=frame.getType();
      frameStartType=frame.getStart().getType();
      frameStart=frame.getStart().getValue().orElse(null);
      if (frame.getEnd().isPresent()) {
        frameEndType=frame.getEnd().get().getType();
        frameEnd=frame.getEnd().get().getValue().orElse(null);
      }
    }
    ImmutableList.Builder<Expression> inputs=ImmutableList.<Expression>builder().addAll(windowFunction.getArguments()).addAll(window.getPartitionBy()).addAll(Iterables.transform(window.getOrderBy(),sortKeyGetter()));
    if (frameStart != null) {
      inputs.add(frameStart);
    }
    if (frameEnd != null) {
      inputs.add(frameEnd);
    }
    subPlan=appendProjections(subPlan,inputs.build());
    ImmutableList.Builder<Symbol> partitionBySymbols=ImmutableList.builder();
    for (    Expression expression : window.getPartitionBy()) {
      partitionBySymbols.add(subPlan.translate(expression));
    }
    ImmutableList.Builder<Symbol> orderBySymbols=ImmutableList.builder();
    Map<Symbol,SortOrder> orderings=new HashMap<>();
    for (    SortItem item : window.getOrderBy()) {
      Symbol symbol=subPlan.translate(item.getSortKey());
      orderBySymbols.add(symbol);
      orderings.put(symbol,toSortOrder(item));
    }
    Optional<Symbol> frameStartSymbol=Optional.absent();
    Optional<Symbol> frameEndSymbol=Optional.absent();
    if (frameStart != null) {
      frameStartSymbol=Optional.of(subPlan.translate(frameStart));
    }
    if (frameEnd != null) {
      frameEndSymbol=Optional.of(subPlan.translate(frameEnd));
    }
    WindowNode.Frame frame=new WindowNode.Frame(frameType,frameStartType,frameStartSymbol,frameEndType,frameEndSymbol);
    TranslationMap outputTranslations=new TranslationMap(subPlan.getRelationPlan(),analysis);
    outputTranslations.copyMappingsFrom(subPlan.getTranslations());
    ImmutableMap.Builder<Symbol,FunctionCall> assignments=ImmutableMap.builder();
    Map<Symbol,Signature> signatures=new HashMap<>();
    Expression rewritten=subPlan.rewrite(windowFunction);
    Symbol newSymbol=symbolAllocator.newSymbol(rewritten,analysis.getType(windowFunction));
    boolean needCoercion=rewritten instanceof Cast;
    if (rewritten instanceof Cast) {
      rewritten=((Cast)rewritten).getExpression();
    }
    assignments.put(newSymbol,(FunctionCall)rewritten);
    outputTranslations.put(windowFunction,newSymbol);
    signatures.put(newSymbol,analysis.getFunctionInfo(windowFunction).getSignature());
    List<Symbol> sourceSymbols=subPlan.getRoot().getOutputSymbols();
    subPlan=new PlanBuilder(outputTranslations,new WindowNode(idAllocator.getNextId(),subPlan.getRoot(),partitionBySymbols.build(),orderBySymbols.build(),orderings,frame,assignments.build(),signatures,Optional.<Symbol>absent()),subPlan.getSampleWeight());
    if (needCoercion) {
      subPlan=explicitCoercionSymbols(subPlan,sourceSymbols,ImmutableList.of(windowFunction));
    }
  }
  return subPlan;
}
