{
  if (analysis.getAggregates(node).isEmpty() && analysis.getGroupByExpressions(node).isEmpty()) {
    return subPlan;
  }
  Set<FieldOrExpression> arguments=IterableTransformer.on(analysis.getAggregates(node)).transformAndFlatten(argumentsGetter()).transform(toFieldOrExpression()).set();
  Iterable<FieldOrExpression> inputs=Iterables.concat(analysis.getGroupByExpressions(node),arguments);
  if (!Iterables.isEmpty(inputs)) {
    subPlan=project(subPlan,inputs);
  }
  ImmutableMap.Builder<Symbol,FunctionCall> aggregationAssignments=ImmutableMap.builder();
  ImmutableMap.Builder<Symbol,Signature> functions=ImmutableMap.builder();
  TranslationMap translations=new TranslationMap(subPlan.getRelationPlan(),analysis);
  boolean needPostProjectionCoercion=false;
  for (  FunctionCall aggregate : analysis.getAggregates(node)) {
    Expression rewritten=subPlan.rewrite(aggregate);
    Symbol newSymbol=symbolAllocator.newSymbol(rewritten,analysis.getType(aggregate));
    if (rewritten instanceof Cast) {
      rewritten=((Cast)rewritten).getExpression();
      needPostProjectionCoercion=true;
    }
    aggregationAssignments.put(newSymbol,(FunctionCall)rewritten);
    translations.put(aggregate,newSymbol);
    functions.put(newSymbol,analysis.getFunctionInfo(aggregate).getSignature());
  }
  Set<Symbol> groupBySymbols=new LinkedHashSet<>();
  for (  FieldOrExpression fieldOrExpression : analysis.getGroupByExpressions(node)) {
    Symbol symbol=subPlan.translate(fieldOrExpression);
    groupBySymbols.add(symbol);
    translations.put(fieldOrExpression,symbol);
  }
  Map<Set<Expression>,Symbol> argumentMarkers=new HashMap<>();
  Map<Symbol,Symbol> masks=new HashMap<>();
  for (  FunctionCall aggregate : Iterables.filter(analysis.getAggregates(node),distinctPredicate())) {
    Set<Expression> args=ImmutableSet.copyOf(aggregate.getArguments());
    Symbol marker=argumentMarkers.get(args);
    Symbol aggregateSymbol=translations.get(aggregate);
    if (marker == null) {
      if (args.size() == 1) {
        marker=symbolAllocator.newSymbol(Iterables.getOnlyElement(args),BOOLEAN,"distinct");
      }
 else {
        marker=symbolAllocator.newSymbol(aggregateSymbol.getName(),BOOLEAN,"distinct");
      }
      argumentMarkers.put(args,marker);
    }
    masks.put(aggregateSymbol,marker);
  }
  for (  Map.Entry<Set<Expression>,Symbol> entry : argumentMarkers.entrySet()) {
    ImmutableList.Builder<Symbol> builder=ImmutableList.builder();
    builder.addAll(groupBySymbols);
    for (    Expression expression : entry.getKey()) {
      builder.add(subPlan.translate(expression));
    }
    MarkDistinctNode markDistinct=new MarkDistinctNode(idAllocator.getNextId(),subPlan.getRoot(),entry.getValue(),builder.build(),Optional.<Symbol>absent());
    subPlan=new PlanBuilder(subPlan.getTranslations(),markDistinct,subPlan.getSampleWeight());
  }
  double confidence=1.0;
  if (analysis.getQuery().getApproximate().isPresent()) {
    confidence=Double.valueOf(analysis.getQuery().getApproximate().get().getConfidence()) / 100.0;
  }
  AggregationNode aggregationNode=new AggregationNode(idAllocator.getNextId(),subPlan.getRoot(),ImmutableList.copyOf(groupBySymbols),aggregationAssignments.build(),functions.build(),new ImmutableMap.Builder<Symbol,Symbol>().putAll(masks).build(),subPlan.getSampleWeight(),confidence,Optional.<Symbol>absent());
  subPlan=new PlanBuilder(translations,aggregationNode,Optional.<Symbol>absent());
  if (needPostProjectionCoercion) {
    return explicitCoercionFields(subPlan,analysis.getGroupByExpressions(node),analysis.getAggregates(node));
  }
  return subPlan;
}
