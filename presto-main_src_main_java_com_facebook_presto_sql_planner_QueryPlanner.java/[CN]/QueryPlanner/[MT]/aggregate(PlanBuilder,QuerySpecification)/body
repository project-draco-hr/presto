{
  if (analysis.getAggregates(node).isEmpty() && analysis.getGroupByExpressions(node).isEmpty()) {
    return subPlan;
  }
  Set<FieldOrExpression> arguments=IterableTransformer.on(analysis.getAggregates(node)).transformAndFlatten(argumentsGetter()).transform(toFieldOrExpression()).set();
  Iterable<FieldOrExpression> inputs=Iterables.concat(analysis.getGroupByExpressions(node),arguments);
  if (!Iterables.isEmpty(inputs)) {
    subPlan=project(subPlan,inputs);
  }
  ImmutableMap.Builder<Symbol,FunctionCall> aggregationAssignments=ImmutableMap.builder();
  ImmutableMap.Builder<Symbol,Signature> functions=ImmutableMap.builder();
  TranslationMap translations=new TranslationMap(subPlan.getRelationPlan(),analysis);
  for (  FunctionCall aggregate : analysis.getAggregates(node)) {
    FunctionCall rewritten=(FunctionCall)subPlan.rewrite(aggregate);
    Symbol newSymbol=symbolAllocator.newSymbol(rewritten,analysis.getType(aggregate));
    aggregationAssignments.put(newSymbol,rewritten);
    translations.put(aggregate,newSymbol);
    functions.put(newSymbol,analysis.getFunctionInfo(aggregate).getHandle());
  }
  Set<Symbol> groupBySymbols=new LinkedHashSet<>();
  for (  FieldOrExpression fieldOrExpression : analysis.getGroupByExpressions(node)) {
    Symbol symbol=subPlan.translate(fieldOrExpression);
    groupBySymbols.add(symbol);
    translations.put(fieldOrExpression,symbol);
  }
  Map<Set<Expression>,Symbol> argumentMarkers=new HashMap<>();
  ImmutableMap.Builder<Symbol,Symbol> masks=ImmutableMap.builder();
  for (  FunctionCall aggregate : Iterables.filter(analysis.getAggregates(node),distinctPredicate())) {
    Set<Expression> args=ImmutableSet.copyOf(aggregate.getArguments());
    Symbol marker=argumentMarkers.get(args);
    Symbol aggregateSymbol=translations.get(aggregate);
    if (marker == null) {
      if (args.size() == 1) {
        marker=symbolAllocator.newSymbol(Iterables.getOnlyElement(args),Type.BOOLEAN,"distinct");
      }
 else {
        marker=symbolAllocator.newSymbol(aggregateSymbol.getName(),Type.BOOLEAN,"distinct");
      }
      argumentMarkers.put(args,marker);
    }
    masks.put(aggregateSymbol,marker);
  }
  for (  Map.Entry<Set<Expression>,Symbol> entry : argumentMarkers.entrySet()) {
    ImmutableList.Builder<Symbol> builder=ImmutableList.builder();
    builder.addAll(groupBySymbols);
    for (    Expression expression : entry.getKey()) {
      builder.add(subPlan.translate(expression));
    }
    MarkDistinctNode markDistinct=new MarkDistinctNode(idAllocator.getNextId(),subPlan.getRoot(),entry.getValue(),builder.build());
    subPlan=new PlanBuilder(subPlan.getTranslations(),markDistinct);
  }
  return new PlanBuilder(translations,new AggregationNode(idAllocator.getNextId(),subPlan.getRoot(),ImmutableList.copyOf(groupBySymbols),aggregationAssignments.build(),functions.build(),masks.build()));
}
