{
  if (positions.isEmpty()) {
    return EmptyValueBlock.INSTANCE;
  }
  if (!valueBlock.getRange().overlaps(positions.getRange())) {
    return EmptyValueBlock.INSTANCE;
  }
  Range intersection=valueBlock.getRange().intersect(positions.getRange());
  if (valueBlock.isSingleValue() && positions.isPositionsContiguous()) {
    Tuple value=valueBlock.iterator().next();
    return new RunLengthEncodedBlock(value,intersection);
  }
  PositionBlock newPositionBlock;
  if (valueBlock.isPositionsContiguous()) {
    newPositionBlock=positions.filter(new RangePositionBlock(valueBlock.getRange()));
  }
 else {
    newPositionBlock=positions.filter(valueBlock.toPositionBlock());
  }
  return new MaskedValueBlock(valueBlock,newPositionBlock);
}
