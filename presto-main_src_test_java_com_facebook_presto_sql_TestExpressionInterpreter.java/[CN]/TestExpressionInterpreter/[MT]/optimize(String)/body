{
  Expression parsedExpression=createExpression(expression);
  Expression roundtrip=createExpression(ExpressionFormatter.formatExpression(parsedExpression));
  assertEquals(parsedExpression,roundtrip);
  IdentityHashMap<Expression,Type> expressionTypes=getExpressionTypes(SESSION,DUAL_METADATA_MANAGER,SYMBOL_TYPES,parsedExpression);
  ExpressionInterpreter interpreter=expressionOptimizer(parsedExpression,DUAL_METADATA_MANAGER,SESSION,expressionTypes);
  return interpreter.optimize(new SymbolResolver(){
    @Override public Object getValue(    Symbol symbol){
switch (symbol.getName().toLowerCase()) {
case "bound_long":
        return 1234L;
case "bound_string":
      return Slices.wrappedBuffer("hello".getBytes(UTF_8));
case "bound_double":
    return 12.34;
case "bound_timestamp":
  DateTime dateTime=new DateTime(2001,8,22,3,4,5,321,DateTimeZone.UTC);
return MILLISECONDS.toSeconds(dateTime.getMillis());
case "bound_pattern":
return Slices.wrappedBuffer("%el%".getBytes(UTF_8));
}
return new QualifiedNameReference(symbol.toQualifiedName());
}
}
);
}
