{
  TpchIndexHandle tpchIndexHandle=checkType(indexHandle,TpchIndexHandle.class,"indexHandle");
  Map<ColumnHandle,Comparable<?>> fixedValues=tpchIndexHandle.getFixedValues().extractFixedValues();
  checkArgument(!any(lookupSchema,in(fixedValues.keySet())),"Lookup columnHandles are not expected to overlap with the fixed value predicates");
  List<ColumnHandle> fixedValueColumns=ImmutableList.copyOf(fixedValues.keySet());
  ImmutableList.Builder<Object> valueBuilder=ImmutableList.builder();
  ImmutableList.Builder<Type> typeBuilder=ImmutableList.builder();
  for (  ColumnHandle fixedValueColumn : fixedValueColumns) {
    valueBuilder.add(fixedValues.get(fixedValueColumn));
    typeBuilder.add(((TpchColumnHandle)fixedValueColumn).getType());
  }
  final List<Object> rawFixedValues=valueBuilder.build();
  final List<Type> rawFixedTypes=typeBuilder.build();
  List<ColumnHandle> finalLookupSchema=ImmutableList.<ColumnHandle>builder().addAll(lookupSchema).addAll(fixedValueColumns).build();
  Optional<TpchIndexedData.IndexedTable> indexedTable=indexedData.getIndexedTable(tpchIndexHandle.getTableName(),tpchIndexHandle.getScaleFactor(),tpchIndexHandle.getIndexColumnNames());
  checkState(indexedTable.isPresent());
  TpchIndexedData.IndexedTable table=indexedTable.get();
  final List<Integer> keyRemap=computeRemap(handleToNames(finalLookupSchema),table.getKeyColumns());
  Function<RecordSet,RecordSet> keyFormatter=new Function<RecordSet,RecordSet>(){
    @Override public RecordSet apply(    RecordSet key){
      return new MappedRecordSet(new AppendingRecordSet(key,rawFixedValues,rawFixedTypes),keyRemap);
    }
  }
;
  final List<Integer> outputRemap=computeRemap(table.getOutputColumns(),handleToNames(outputSchema));
  Function<RecordSet,RecordSet> outputFormatter=new Function<RecordSet,RecordSet>(){
    @Override public RecordSet apply(    RecordSet output){
      return new MappedRecordSet(output,outputRemap);
    }
  }
;
  return new TpchConnectorIndex(keyFormatter,outputFormatter,table);
}
