{
  Preconditions.checkArgument(!query.getSelect().isDistinct(),"not yet implemented: DISTINCT");
  Preconditions.checkArgument(query.getHaving() == null,"not yet implemented: HAVING");
  Preconditions.checkArgument(query.getFrom().size() == 1,"not yet implemented: multiple FROM relations");
  Preconditions.checkArgument(query.getLimit() != null && !query.getOrderBy().isEmpty() || query.getOrderBy().isEmpty(),"not yet implemented: ORDER BY without LIMIT");
  Relation relation=Iterables.getOnlyElement(query.getFrom());
  TupleDescriptor sourceDescriptor=new RelationAnalyzer(metadata).process(relation,context);
  AnalyzedExpression predicate=null;
  if (query.getWhere() != null) {
    predicate=analyzePredicate(query.getWhere(),sourceDescriptor);
  }
  List<AnalyzedExpression> groupBy=analyzeGroupBy(query.getGroupBy(),sourceDescriptor);
  Set<AnalyzedAggregation> aggregations=analyzeAggregations(query.getGroupBy(),query.getSelect(),query.getOrderBy(),sourceDescriptor);
  List<AnalyzedOrdering> orderBy=analyzeOrderBy(query.getOrderBy(),sourceDescriptor);
  AnalyzedOutput output=analyzeOutput(query.getSelect(),context.getSlotAllocator(),sourceDescriptor);
  Long limit=null;
  if (query.getLimit() != null) {
    limit=Long.parseLong(query.getLimit());
  }
  return AnalysisResult.newInstance(context,output,predicate,groupBy,aggregations,limit,orderBy);
}
