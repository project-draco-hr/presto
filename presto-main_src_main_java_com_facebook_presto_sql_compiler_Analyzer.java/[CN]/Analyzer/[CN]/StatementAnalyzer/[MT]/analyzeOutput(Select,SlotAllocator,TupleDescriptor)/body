{
  ImmutableList.Builder<Expression> expressions=ImmutableList.builder();
  ImmutableList.Builder<Optional<String>> names=ImmutableList.builder();
  for (  Expression expression : select.getSelectItems()) {
    if (expression instanceof AllColumns) {
      Optional<QualifiedName> starPrefix=((AllColumns)expression).getPrefix();
      for (      NamedSlot slot : descriptor.getSlots()) {
        Optional<QualifiedName> prefix=slot.getPrefix();
        if (!starPrefix.isPresent() || prefix.isPresent() && prefix.get().hasSuffix(starPrefix.get())) {
          names.add(slot.getAttribute());
          expressions.add(new SlotReference(slot.getSlot()));
        }
      }
    }
 else {
      Optional<String> alias=Optional.absent();
      if (expression instanceof AliasedExpression) {
        AliasedExpression aliased=(AliasedExpression)expression;
        alias=Optional.of(aliased.getAlias());
        expression=aliased.getExpression();
      }
 else       if (expression instanceof QualifiedNameReference) {
        alias=Optional.of(((QualifiedNameReference)expression).getName().getSuffix());
      }
      names.add(alias);
      expressions.add(expression);
    }
  }
  BiMap<Slot,AnalyzedExpression> assignments=HashBiMap.create();
  ImmutableList.Builder<Slot> slots=ImmutableList.builder();
  for (  Expression expression : expressions.build()) {
    AnalyzedExpression analysis=new ExpressionAnalyzer(metadata).analyze(expression,descriptor);
    Slot slot;
    if (assignments.containsValue(analysis)) {
      slot=assignments.inverse().get(analysis);
    }
 else {
      slot=allocator.newSlot(analysis);
      assignments.put(slot,analysis);
    }
    slots.add(slot);
  }
  return new AnalyzedOutput(new TupleDescriptor(names.build(),slots.build()),assignments);
}
