{
  if (node.getType() != Join.Type.INNER) {
    throw new SemanticException(node,"Only inner joins are supported");
  }
  TupleDescriptor left=process(node.getLeft(),context);
  TupleDescriptor right=process(node.getRight(),context);
  TupleDescriptor descriptor=new TupleDescriptor(ImmutableList.copyOf(Iterables.concat(left.getFields(),right.getFields())));
  AnalyzedExpression analyzedCriteria;
  JoinCriteria criteria=node.getCriteria();
  if (criteria instanceof NaturalJoin) {
    throw new SemanticException(node,"Natural join not supported");
  }
 else   if (criteria instanceof JoinUsing) {
    throw new UnsupportedOperationException("Join 'using' not yet supported");
  }
 else   if (criteria instanceof JoinOn) {
    analyzedCriteria=new ExpressionAnalyzer(metadata,descriptor.getSymbols()).analyze(((JoinOn)criteria).getExpression(),descriptor);
    Expression expression=analyzedCriteria.getRewrittenExpression();
    if (!(expression instanceof ComparisonExpression)) {
      throw new SemanticException(node,"Non-equi joins not supported");
    }
    ComparisonExpression comparison=(ComparisonExpression)expression;
    if (comparison.getType() != ComparisonExpression.Type.EQUAL || !(comparison.getLeft() instanceof QualifiedNameReference) || !(comparison.getRight() instanceof QualifiedNameReference)) {
      throw new SemanticException(node,"Non-equi joins not supported");
    }
  }
 else {
    throw new UnsupportedOperationException("unsupported join criteria: " + criteria.getClass().getName());
  }
  context.registerJoin(node,analyzedCriteria);
  return descriptor;
}
