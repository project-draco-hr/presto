{
  Set<Symbol> requiredTableScanOutputs=FluentIterable.from(expectedOutputs).filter(in(node.getOutputSymbols())).toSet();
  if (requiredTableScanOutputs.isEmpty()) {
    for (    Symbol symbol : node.getOutputSymbols()) {
      Type type=types.get(symbol);
      if (type.equals(BIGINT) || type.equals(DOUBLE)) {
        requiredTableScanOutputs=ImmutableSet.of(symbol);
        break;
      }
    }
    if (requiredTableScanOutputs.isEmpty()) {
      requiredTableScanOutputs=ImmutableSet.of(node.getOutputSymbols().get(0));
    }
  }
  checkState(!requiredTableScanOutputs.isEmpty());
  List<Symbol> newOutputSymbols=FluentIterable.from(node.getOutputSymbols()).filter(in(requiredTableScanOutputs)).toList();
  Set<Symbol> requiredAssignmentSymbols=requiredTableScanOutputs;
  if (!node.getPartitionsDomainSummary().isNone()) {
    Set<Symbol> requiredPartitionDomainSymbols=Maps.filterValues(node.getAssignments(),Predicates.in(node.getPartitionsDomainSummary().getDomains().keySet())).keySet();
    requiredAssignmentSymbols=Sets.union(requiredTableScanOutputs,requiredPartitionDomainSymbols);
  }
  Map<Symbol,ColumnHandle> newAssignments=Maps.filterKeys(node.getAssignments(),in(requiredAssignmentSymbols));
  return new TableScanNode(node.getId(),node.getTable(),newOutputSymbols,newAssignments,node.getOriginalConstraint(),node.getSummarizedPartition());
}
