{
  WindowFunctionExtractor extractor=new WindowFunctionExtractor();
  for (  FieldOrExpression fieldOrExpression : Iterables.concat(outputExpressions,orderByExpressions)) {
    if (fieldOrExpression.isExpression()) {
      extractor.process(fieldOrExpression.getExpression(),null);
      if (fieldOrExpression.getExpression() instanceof FunctionCall) {
        FunctionCall functionCall=(FunctionCall)fieldOrExpression.getExpression();
        FunctionInfo functionInfo=analysis.getFunctionInfo(functionCall);
        checkState(functionInfo != null,"functionInfo is null");
        if (functionInfo.isWindow() && !functionInfo.isAggregate() && !functionCall.getWindow().isPresent()) {
          throw new SemanticException(WINDOW_REQUIRES_OVER,node,"Window function %s requires an OVER clause",functionInfo.getName());
        }
      }
    }
  }
  List<FunctionCall> windowFunctions=extractor.getWindowFunctions();
  for (  FunctionCall windowFunction : windowFunctions) {
    Window window=windowFunction.getWindow().get();
    WindowFunctionExtractor nestedExtractor=new WindowFunctionExtractor();
    for (    Expression argument : windowFunction.getArguments()) {
      nestedExtractor.process(argument,null);
    }
    for (    Expression expression : window.getPartitionBy()) {
      nestedExtractor.process(expression,null);
    }
    for (    SortItem sortItem : window.getOrderBy()) {
      nestedExtractor.process(sortItem.getSortKey(),null);
    }
    if (window.getFrame().isPresent()) {
      nestedExtractor.process(window.getFrame().get(),null);
    }
    if (!nestedExtractor.getWindowFunctions().isEmpty()) {
      throw new SemanticException(NESTED_WINDOW,node,"Cannot nest window functions inside window function '%s': %s",windowFunction,extractor.getWindowFunctions());
    }
    if (windowFunction.isDistinct()) {
      throw new SemanticException(NOT_SUPPORTED,node,"DISTINCT in window function parameters not yet supported: %s",windowFunction);
    }
    if (window.getFrame().isPresent()) {
      analyzeWindowFrame(window.getFrame().get());
    }
    List<TypeSignature> argumentTypes=Lists.transform(windowFunction.getArguments(),new Function<Expression,TypeSignature>(){
      @Override public TypeSignature apply(      Expression input){
        return analysis.getType(input).getTypeSignature();
      }
    }
);
    FunctionInfo info=metadata.resolveFunction(windowFunction.getName(),argumentTypes,false);
    if (!info.isWindow()) {
      throw new SemanticException(MUST_BE_WINDOW_FUNCTION,node,"Not a window function: %s",windowFunction.getName());
    }
  }
  analysis.setWindowFunctions(node,windowFunctions);
}
