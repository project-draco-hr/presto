{
  TupleDescriptor child=process(relation.getRelation(),context);
  ImmutableList.Builder<Field> builder=ImmutableList.builder();
  if (relation.getColumnNames() != null) {
    int totalColumns=child.getFields().size();
    if (totalColumns != relation.getColumnNames().size()) {
      throw new SemanticException(MISMATCHED_COLUMN_ALIASES,relation,"Column alias list has %s entries but '%s' has %s columns available",relation.getColumnNames().size(),relation.getAlias(),totalColumns);
    }
  }
  for (int i=0; i < child.getFields().size(); i++) {
    Field field=child.getFields().get(i);
    Optional<String> columnAlias=field.getName();
    if (relation.getColumnNames() != null) {
      columnAlias=Optional.of(relation.getColumnNames().get(i));
    }
    builder.add(Field.newQualified(QualifiedName.of(relation.getAlias()),columnAlias,field.getType()));
  }
  TupleDescriptor descriptor=new TupleDescriptor(builder.build());
  analysis.setOutputDescriptor(relation,descriptor);
  return descriptor;
}
