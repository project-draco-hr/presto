{
  if (!EnumSet.of(Join.Type.INNER,Join.Type.LEFT,Join.Type.RIGHT).contains(node.getType())) {
    throw new SemanticException(NOT_SUPPORTED,node,"Only inner, left, and right joins are supported");
  }
  JoinCriteria criteria=node.getCriteria();
  if (criteria instanceof NaturalJoin) {
    throw new SemanticException(NOT_SUPPORTED,node,"Natural join not supported");
  }
  TupleDescriptor left=process(node.getLeft(),context);
  TupleDescriptor right=process(node.getRight(),context);
  Sets.SetView<QualifiedName> duplicateAliases=Sets.intersection(left.getRelationAliases(),right.getRelationAliases());
  if (!duplicateAliases.isEmpty()) {
    throw new SemanticException(DUPLICATE_RELATION,node,"Relations appear more than once: %s",duplicateAliases);
  }
  List<Field> outputFields=ImmutableList.<Field>builder().addAll(left.getFields()).addAll(right.getFields()).build();
  TupleDescriptor output=new TupleDescriptor(outputFields);
  if (criteria instanceof JoinUsing) {
    List<String> columns=((JoinUsing)criteria).getColumns();
    ImmutableList.Builder<EquiJoinClause> builder=ImmutableList.builder();
    for (    String column : columns) {
      Expression leftExpression=new QualifiedNameReference(QualifiedName.of(column));
      Expression rightExpression=new QualifiedNameReference(QualifiedName.of(column));
      Analyzer.analyzeExpression(metadata,left,analysis,leftExpression);
      Analyzer.analyzeExpression(metadata,right,analysis,rightExpression);
      builder.add(new EquiJoinClause(leftExpression,rightExpression));
    }
    analysis.setEquijoinCriteria(node,builder.build());
  }
 else   if (criteria instanceof JoinOn) {
    Expression expression=((JoinOn)criteria).getExpression();
    ExpressionAnalyzer analyzer=new ExpressionAnalyzer(metadata);
    analyzer.analyze(expression,output);
    Analyzer.verifyNoAggregatesOrWindowFunctions(metadata,expression,"JOIN");
    Object optimizedExpression=ExpressionInterpreter.expressionOptimizer(new NoOpSymbolResolver(),metadata,session).process(expression,null);
    if (!(optimizedExpression instanceof Expression)) {
      throw new SemanticException(NOT_SUPPORTED,node,"Joins on constant expressions (i.e., cross joins) not supported");
    }
    ImmutableList.Builder<EquiJoinClause> clauses=ImmutableList.builder();
    for (    Expression conjunct : ExpressionUtils.extractConjuncts((Expression)optimizedExpression)) {
      if (!(conjunct instanceof ComparisonExpression)) {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins not supported: %s",conjunct);
      }
      ComparisonExpression comparison=(ComparisonExpression)conjunct;
      if (comparison.getType() != ComparisonExpression.Type.EQUAL) {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins not supported: %s",conjunct);
      }
      Set<QualifiedName> firstDependencies=DependencyExtractor.extract(comparison.getLeft());
      Set<QualifiedName> secondDependencies=DependencyExtractor.extract(comparison.getRight());
      Expression leftExpression;
      Expression rightExpression;
      if (Iterables.all(firstDependencies,left.canResolvePredicate()) && Iterables.all(secondDependencies,right.canResolvePredicate())) {
        leftExpression=comparison.getLeft();
        rightExpression=comparison.getRight();
      }
 else       if (Iterables.all(firstDependencies,right.canResolvePredicate()) && Iterables.all(secondDependencies,left.canResolvePredicate())) {
        leftExpression=comparison.getRight();
        rightExpression=comparison.getLeft();
      }
 else {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins not supported: %s",conjunct);
      }
      Analyzer.analyzeExpression(metadata,left,analysis,leftExpression);
      Analyzer.analyzeExpression(metadata,right,analysis,rightExpression);
      clauses.add(new EquiJoinClause(leftExpression,rightExpression));
    }
    analysis.setEquijoinCriteria(node,clauses.build());
  }
 else {
    throw new UnsupportedOperationException("unsupported join criteria: " + criteria.getClass().getName());
  }
  analysis.setOutputDescriptor(node,output);
  return output;
}
