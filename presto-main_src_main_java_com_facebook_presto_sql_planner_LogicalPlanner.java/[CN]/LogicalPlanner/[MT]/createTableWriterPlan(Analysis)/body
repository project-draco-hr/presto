{
  QualifiedTableName destination=analysis.getDestination();
  TableHandle targetTable;
  List<ColumnHandle> columnHandles;
  RelationPlan plan;
  if (analysis.isDoRefresh()) {
    targetTable=metadata.getTableHandle(destination).get();
    QualifiedTableName sourceTable=storageManager.getTableSource((NativeTableHandle)targetTable);
    TableHandle sourceTableHandle=metadata.getTableHandle(sourceTable).get();
    TableMetadata sourceTableMetadata=metadata.getTableMetadata(sourceTableHandle);
    Map<String,ColumnHandle> sourceTableColumns=metadata.getColumnHandles(sourceTableHandle);
    ImmutableList.Builder<Symbol> outputSymbols=ImmutableList.builder();
    ImmutableMap.Builder<Symbol,ColumnHandle> columns=ImmutableMap.builder();
    ImmutableList.Builder<Field> fields=ImmutableList.builder();
    ImmutableList.Builder<ColumnHandle> columnHandleBuilder=ImmutableList.builder();
    for (    ColumnMetadata column : sourceTableMetadata.getColumns()) {
      Field field=Field.newQualified(sourceTable.asQualifiedName(),Optional.of(column.getName()),Type.fromRaw(column.getType()));
      Symbol symbol=symbolAllocator.newSymbol(field);
      ColumnHandle columnHandle=sourceTableColumns.get(column.getName());
      columns.put(symbol,columnHandle);
      fields.add(field);
      columnHandleBuilder.add(columnHandle);
      outputSymbols.add(symbol);
    }
    plan=new RelationPlan(new TableScanNode(idAllocator.getNextId(),sourceTableHandle,columns.build()),new TupleDescriptor(fields.build()),outputSymbols.build());
    columnHandles=columnHandleBuilder.build();
  }
 else {
    RelationPlanner planner=new RelationPlanner(analysis,symbolAllocator,idAllocator,metadata,session);
    plan=planner.process(analysis.getQuery(),null);
    ImmutableList.Builder<ColumnMetadata> columns=ImmutableList.builder();
    for (int i=0; i < plan.getDescriptor().getFields().size(); i++) {
      Field field=plan.getDescriptor().getFields().get(i);
      String name=field.getName().or("_field" + i);
      ColumnMetadata columnMetadata=new ColumnMetadata(name,field.getType().getRawType(),i);
      columns.add(columnMetadata);
    }
    TableMetadata tableMetadata=new TableMetadata(destination,columns.build());
    targetTable=metadata.createTable(tableMetadata);
    Map<String,ColumnHandle> columnHandleIndex=metadata.getColumnHandles(targetTable);
    ImmutableList.Builder<ColumnHandle> columnHandleBuilder=ImmutableList.builder();
    for (    ColumnMetadata column : tableMetadata.getColumns()) {
      columnHandleBuilder.add(columnHandleIndex.get(column.getName()));
    }
    columnHandles=columnHandleBuilder.build();
    List<Relation> relations=analysis.getQuery().getFrom();
    checkState(relations.size() == 1,"Query has more than one source table");
    Relation relation=Iterables.getOnlyElement(relations);
    checkState(relation instanceof Table,"FROM clause is not a simple table name");
    QualifiedTableName sourceTable=MetadataUtil.createQualifiedTableName(session,((Table)relation).getName());
    storageManager.insertTableSource(((NativeTableHandle)targetTable),sourceTable);
    if (analysis.getRefreshInterval().isPresent()) {
      PeriodicImportJob job=PeriodicImportJob.createJob(sourceTable,destination,analysis.getRefreshInterval().get());
      periodicImportManager.insertJob(job);
    }
  }
  ImmutableMap.Builder<Symbol,ColumnHandle> mappings=ImmutableMap.builder();
  for (int i=0; i < columnHandles.size(); i++) {
    ColumnHandle column=columnHandles.get(i);
    Symbol symbol=plan.getSymbol(i);
    mappings.put(symbol,column);
  }
  Symbol output=symbolAllocator.newSymbol("imported_rows",Type.LONG);
  TableWriterNode writerNode=new TableWriterNode(idAllocator.getNextId(),plan.getRoot(),targetTable,mappings.build(),output);
  return new RelationPlan(writerNode,analysis.getOutputDescriptor(),ImmutableList.of(output));
}
