{
  Set<AnalyzedExpression> inputs=ImmutableSet.copyOf(concat(IterableTransformer.on(windowFunctions).transformAndFlatten(argumentGetter()).list(),IterableTransformer.on(windowFunctions).transformAndFlatten(windowExpressionGetter()).list()));
  BiMap<Symbol,Expression> inputAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : inputs) {
    Symbol symbol=allocator.newSymbol(expression.getRewrittenExpression(),expression.getType());
    inputAssignments.put(symbol,expression.getRewrittenExpression());
  }
  Map<Symbol,Expression> preProjections=new HashMap<>();
  for (  Symbol symbol : source.getOutputSymbols()) {
    QualifiedNameReference expression=new QualifiedNameReference(symbol.toQualifiedName());
    preProjections.put(symbol,expression);
  }
  preProjections.putAll(inputAssignments);
  source=new ProjectNode(idAllocator.getNextId(),source,preProjections);
  Map<Expression,Symbol> substitutions=new HashMap<>();
  for (  AnalyzedFunction function : windowFunctions) {
    AnalyzedWindow window=function.getWindow().get();
    List<Symbol> partitionBySymbols=new ArrayList<>();
    for (    AnalyzedExpression item : window.getPartitionBy()) {
      Expression rewritten=TreeRewriter.rewriteWith(substitution(inputAssignments.inverse()),item.getRewrittenExpression());
      Symbol symbol=allocator.newSymbol(rewritten,item.getType());
      partitionBySymbols.add(symbol);
      substitutions.put(rewritten,symbol);
    }
    List<Symbol> orderBySymbols=new ArrayList<>();
    Map<Symbol,SortItem.Ordering> orderings=new HashMap<>();
    for (    AnalyzedOrdering item : window.getOrderBy()) {
      Expression rewritten=TreeRewriter.rewriteWith(substitution(inputAssignments.inverse()),item.getExpression().getRewrittenExpression());
      Symbol symbol=allocator.newSymbol(rewritten,item.getExpression().getType());
      orderBySymbols.add(symbol);
      orderings.put(symbol,item.getOrdering());
      substitutions.put(rewritten,symbol);
    }
    BiMap<Symbol,FunctionCall> functionAssignments=HashBiMap.create();
    Map<Symbol,FunctionHandle> functionHandles=new HashMap<>();
    FunctionCall rewrittenFunction=TreeRewriter.rewriteWith(substitution(inputAssignments.inverse()),function.getRewrittenCall());
    Symbol symbol=allocator.newSymbol(function.getFunctionName().getSuffix(),function.getType());
    functionAssignments.put(symbol,rewrittenFunction);
    functionHandles.put(symbol,function.getFunctionInfo().getHandle());
    substitutions.put(function.getRewrittenCall(),symbol);
    source=new WindowNode(idAllocator.getNextId(),source,partitionBySymbols,orderBySymbols,orderings,functionAssignments,functionHandles);
  }
  BiMap<Symbol,Expression> postProjectScalarAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : outputs) {
    Expression rewritten=TreeRewriter.rewriteWith(substitution(substitutions),expression.getRewrittenExpression());
    Symbol symbol=allocator.newSymbol(rewritten,expression.getType());
    postProjectScalarAssignments.put(symbol,rewritten);
    outputSubstitutions.put(expression.getRewrittenExpression(),symbol);
  }
  return new ProjectNode(idAllocator.getNextId(),source,postProjectScalarAssignments);
}
