{
  checkState(Thread.holdsLock(SharedBuffer.this),"Thread must hold a lock on the %s",SharedBuffer.class.getSimpleName());
  if (future.isDone()) {
    return true;
  }
  if (state.get() == FAILED) {
    return false;
  }
  try {
    NamedBuffer namedBuffer=namedBuffers.get(outputId);
    if (state.get() == FINISHED) {
      future.complete(emptyResults(namedBuffer == null ? 0 : namedBuffer.getSequenceId(),true));
      return true;
    }
    if (namedBuffer == null) {
      return false;
    }
    if (startingSequenceId < namedBuffer.getSequenceId()) {
      future.complete(emptyResults(startingSequenceId,false));
      return true;
    }
    BufferResult bufferResult=namedBuffer.getPages(startingSequenceId,maxSize);
    checkFlushComplete();
    if (bufferResult.isEmpty() && !bufferResult.isBufferClosed()) {
      return false;
    }
    future.complete(bufferResult);
  }
 catch (  Throwable throwable) {
    future.completeExceptionally(throwable);
  }
  return true;
}
