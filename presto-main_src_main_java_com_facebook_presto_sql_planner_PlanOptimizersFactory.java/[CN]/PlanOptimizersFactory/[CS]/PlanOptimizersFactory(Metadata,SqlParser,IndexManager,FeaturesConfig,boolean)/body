{
  ImmutableList.Builder<PlanOptimizer> builder=ImmutableList.builder();
  builder.add(new ImplementSampleAsFilter(),new CanonicalizeExpressions(),new SimplifyExpressions(metadata,sqlParser),new UnaliasSymbolReferences(),new PruneRedundantProjections(),new SetFlatteningOptimizer(),new LimitPushDown(),new PredicatePushDown(metadata,sqlParser),new MergeProjections(),new SimplifyExpressions(metadata,sqlParser),new ProjectionPushDown(),new UnaliasSymbolReferences(),new IndexJoinOptimizer(metadata,indexManager),new CountConstantOptimizer(),new WindowFilterPushDown(),new HashGenerationOptimizer(featuresConfig.isOptimizeHashGeneration()),new MergeProjections(),new PruneUnreferencedOutputs(),new PruneRedundantProjections());
  if (featuresConfig.isOptimizeMetadataQueries()) {
    builder.add(new MetadataQueryOptimizer(metadata));
  }
  if (featuresConfig.isOptimizeSingleDistinct()) {
    builder.add(new SingleDistinctOptimizer());
    builder.add(new PruneUnreferencedOutputs());
  }
  builder.add(new BeginTableWrite(metadata));
  if (!forceSingleNode) {
    builder.add(new AddExchanges(metadata,sqlParser,featuresConfig.isDistributedIndexJoinsEnabled(),featuresConfig.isDistributedJoinsEnabled()));
  }
  builder.add(new PickLayout(metadata));
  builder.add(new PredicatePushDown(metadata,sqlParser));
  builder.add(new UnaliasSymbolReferences());
  builder.add(new MergeProjections());
  builder.add(new PruneUnreferencedOutputs());
  builder.add(new PruneRedundantProjections());
  this.optimizers=builder.build();
}
