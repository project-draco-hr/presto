{
  checkNotNull(session,"session is null");
  checkNotNull(taskId,"taskId is null");
  checkNotNull(nodeId,"nodeId is null");
  checkNotNull(location,"location is null");
  checkNotNull(planFragment,"planFragment1 is null");
  checkNotNull(outputBuffers,"outputBuffers is null");
  checkNotNull(httpClient,"httpClient is null");
  checkNotNull(executor,"executor is null");
  checkNotNull(taskInfoCodec,"taskInfoCodec is null");
  checkNotNull(taskUpdateRequestCodec,"taskUpdateRequestCodec is null");
  try (SetThreadName ignored=new SetThreadName("HttpRemoteTask-%s",taskId)){
    this.taskId=taskId;
    this.session=session;
    this.nodeId=nodeId;
    this.planFragment=planFragment;
    this.outputBuffers.set(outputBuffers);
    this.httpClient=httpClient;
    this.executor=executor;
    this.taskInfoCodec=taskInfoCodec;
    this.taskUpdateRequestCodec=taskUpdateRequestCodec;
    this.maxConsecutiveErrorCount=maxConsecutiveErrorCount;
    this.minErrorDuration=minErrorDuration;
    for (    Entry<PlanNodeId,Split> entry : checkNotNull(initialSplits,"initialSplits is null").entries()) {
      ScheduledSplit scheduledSplit=new ScheduledSplit(nextSplitId.getAndIncrement(),entry.getValue());
      pendingSplits.put(entry.getKey(),scheduledSplit);
    }
    List<BufferInfo> bufferStates=ImmutableList.copyOf(transform(outputBuffers.getBuffers().keySet(),new Function<TaskId,BufferInfo>(){
      @Override public BufferInfo apply(      TaskId outputId){
        return new BufferInfo(outputId,false,0,0);
      }
    }
));
    TaskStats taskStats=new TaskContext(taskId,executor,session).getTaskStats();
    taskInfo=new StateMachine<>("task " + taskId,executor,new TaskInfo(taskId,TaskInfo.MIN_VERSION,TaskState.PLANNED,location,DateTime.now(),new SharedBufferInfo(BufferState.OPEN,0,0,bufferStates),ImmutableSet.<PlanNodeId>of(),taskStats,ImmutableList.<ExecutionFailureInfo>of()));
  }
 }
