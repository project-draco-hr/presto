{
  ByteCodeNode patternNode=arguments.get(1);
  MethodHandle methodHandle;
  if (patternNode instanceof Constant) {
    Slice patternSlice=(Slice)((Constant)patternNode).getValue();
    String pattern=patternSlice.toString(Charsets.UTF_8);
    JsonExtractor<?> jsonExtractor;
switch (name) {
case JSON_EXTRACT_SCALAR_FUNCTION_NAME:
      methodHandle=constantJsonExtract;
    jsonExtractor=generateExtractor(pattern,new ScalarValueJsonExtractor());
  break;
case JSON_EXTRACT_FUNCTION_NAME:
methodHandle=constantJsonExtract;
jsonExtractor=generateExtractor(pattern,new JsonValueJsonExtractor());
break;
case JSON_SIZE_FUNCTION_NAME:
methodHandle=constantJsonSize;
jsonExtractor=generateExtractor(pattern,new JsonSizeExtractor());
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
methodHandle=MethodHandles.insertArguments(methodHandle,1,jsonExtractor);
arguments=new ArrayList<>(arguments);
arguments.remove(1);
arguments=ImmutableList.copyOf(arguments);
}
 else {
JsonExtractCache<?> cache;
switch (name) {
case JSON_EXTRACT_SCALAR_FUNCTION_NAME:
methodHandle=dynamicJsonExtract;
cache=new JsonExtractCache<>(20,new Supplier<JsonExtractor<Slice>>(){
@Override public JsonExtractor<Slice> get(){
return new ScalarValueJsonExtractor();
}
}
);
break;
case JSON_EXTRACT_FUNCTION_NAME:
methodHandle=dynamicJsonExtract;
cache=new JsonExtractCache<>(20,new Supplier<JsonExtractor<Slice>>(){
@Override public JsonExtractor<Slice> get(){
return new JsonValueJsonExtractor();
}
}
);
break;
case JSON_SIZE_FUNCTION_NAME:
methodHandle=dynamicJsonSize;
cache=new JsonExtractCache<>(20,new Supplier<JsonExtractor<Long>>(){
@Override public JsonExtractor<Long> get(){
return new JsonSizeExtractor();
}
}
);
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
methodHandle=methodHandle.bindTo(cache);
}
return DefaultFunctionBinder.bindConstantArguments(bindingId,name,getSessionByteCode,arguments,methodHandle,true);
}
