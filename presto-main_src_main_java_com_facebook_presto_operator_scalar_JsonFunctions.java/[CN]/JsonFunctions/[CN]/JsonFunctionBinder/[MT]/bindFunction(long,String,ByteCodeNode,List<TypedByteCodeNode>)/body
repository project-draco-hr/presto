{
  TypedByteCodeNode patternNode=arguments.get(1);
  MethodHandle methodHandle;
  if (patternNode.getNode() instanceof Constant) {
    Slice patternSlice=(Slice)((Constant)patternNode.getNode()).getValue();
    String pattern=patternSlice.toString(Charsets.UTF_8);
    JsonExtractor jsonExtractor;
switch (name) {
case JSON_EXTRACT_SCALAR_FUNCTION_NAME:
      jsonExtractor=generateExtractor(pattern,true);
    break;
case JSON_EXTRACT_FUNCTION_NAME:
  jsonExtractor=generateExtractor(pattern,false);
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
methodHandle=MethodHandles.insertArguments(constantJsonExtract,1,jsonExtractor);
arguments=new ArrayList<>(arguments);
arguments.remove(1);
arguments=ImmutableList.copyOf(arguments);
}
 else {
ThreadLocalCache<Slice,JsonExtractor> cache;
switch (name) {
case JSON_EXTRACT_SCALAR_FUNCTION_NAME:
cache=new JsonExtractCache(20,true);
break;
case JSON_EXTRACT_FUNCTION_NAME:
cache=new JsonExtractCache(20,false);
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
methodHandle=dynamicJsonExtract.bindTo(cache);
}
return DefaultFunctionBinder.bindConstantArguments(bindingId,name,getSessionByteCode,arguments,methodHandle,true);
}
