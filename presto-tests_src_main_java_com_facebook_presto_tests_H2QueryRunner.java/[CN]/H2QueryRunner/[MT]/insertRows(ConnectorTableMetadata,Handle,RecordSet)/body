{
  List<ColumnMetadata> columns=ImmutableList.copyOf(Iterables.filter(tableMetadata.getColumns(),new Predicate<ColumnMetadata>(){
    @Override public boolean apply(    ColumnMetadata columnMetadata){
      return !columnMetadata.isHidden();
    }
  }
));
  String vars=Joiner.on(',').join(nCopies(columns.size(),"?"));
  String sql=format("INSERT INTO %s VALUES (%s)",tableMetadata.getTable().getTableName(),vars);
  RecordCursor cursor=data.cursor();
  while (true) {
    PreparedBatch batch=handle.prepareBatch(sql);
    for (int row=0; row < 1000; row++) {
      if (!cursor.advanceNextPosition()) {
        batch.execute();
        return;
      }
      PreparedBatchPart part=batch.add();
      for (int column=0; column < columns.size(); column++) {
        Type type=columns.get(column).getType();
        if (BOOLEAN.equals(type)) {
          part.bind(column,cursor.getBoolean(column));
        }
 else         if (BIGINT.equals(type)) {
          part.bind(column,cursor.getLong(column));
        }
 else         if (DOUBLE.equals(type)) {
          part.bind(column,cursor.getDouble(column));
        }
 else         if (VARCHAR.equals(type)) {
          part.bind(column,cursor.getSlice(column).toStringUtf8());
        }
 else         if (DATE.equals(type)) {
          part.bind(column,new Date(cursor.getLong(column)));
        }
 else {
          throw new IllegalArgumentException("Unsupported type " + type);
        }
      }
    }
    batch.execute();
  }
}
