{
  List<DriverContext> runningDrivers=ImmutableList.copyOf(this.runningDrivers);
  int totalDriers=completedDrivers.get() + runningDrivers.size();
  int queuedDrivers=0;
  int startedDrivers=0;
  int completedDrivers=this.completedDrivers.get();
  Distribution queuedTime=new Distribution(this.queuedTime);
  Distribution elapsedTime=new Distribution(this.elapsedTime);
  long totalScheduledTime=this.totalScheduledTime.get();
  long totalCpuTime=this.totalCpuTime.get();
  long totalUserTime=this.totalUserTime.get();
  long totalBlockedTime=this.totalBlockedTime.get();
  long inputDataSize=this.inputDataSize.get();
  long inputPositions=this.inputPositions.get();
  long outputDataSize=this.outputDataSize.get();
  long outputPositions=this.outputPositions.get();
  List<DriverStats> drivers=new ArrayList<>();
  Multimap<Integer,OperatorStats> runningOperators=ArrayListMultimap.create();
  for (  DriverContext driverContext : runningDrivers) {
    DriverStats driverStats=driverContext.getDriverStats();
    drivers.add(driverStats);
    if (driverStats.getStartTime() == null) {
      queuedDrivers++;
    }
 else {
      startedDrivers++;
    }
    queuedTime.add(driverStats.getQueuedTime().roundTo(NANOSECONDS));
    elapsedTime.add(driverStats.getElapsedTime().roundTo(NANOSECONDS));
    totalScheduledTime+=driverStats.getTotalScheduledTime().roundTo(NANOSECONDS);
    totalCpuTime+=driverStats.getTotalCpuTime().roundTo(NANOSECONDS);
    totalUserTime+=driverStats.getTotalUserTime().roundTo(NANOSECONDS);
    totalBlockedTime+=driverStats.getTotalBlockedTime().roundTo(NANOSECONDS);
    List<OperatorStats> operators=ImmutableList.copyOf(transform(driverContext.getOperatorContexts(),operatorStatsGetter()));
    for (    OperatorStats operator : operators) {
      runningOperators.put(operator.getOperatorId(),operator);
    }
    OperatorStats inputOperator=getFirst(operators,null);
    if (inputOperator != null) {
      inputDataSize+=inputOperator.getInputDataSize().toBytes();
      inputPositions+=inputOperator.getInputPositions();
      OperatorStats outputOperator=checkNotNull(getLast(operators,null));
      outputDataSize+=outputOperator.getOutputDataSize().toBytes();
      outputPositions+=outputOperator.getOutputPositions();
    }
  }
  TreeMap<Integer,OperatorStats> operatorSummaries=new TreeMap<>();
  for (  Entry<Integer,OperatorStats> entry : this.operatorSummaries.entrySet()) {
    OperatorStats operator=entry.getValue();
    operator.add(runningOperators.get(entry.getKey()));
    operatorSummaries.put(entry.getKey(),operator);
  }
  return new PipelineStats(totalDriers,queuedDrivers,startedDrivers,completedDrivers,new DataSize(memoryReservation.get(),BYTE).convertToMostSuccinctDataSize(),queuedTime.snapshot(),elapsedTime.snapshot(),new Duration(totalScheduledTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalCpuTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalUserTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalBlockedTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new DataSize(inputDataSize,BYTE).convertToMostSuccinctDataSize(),inputPositions,new DataSize(outputDataSize,BYTE).convertToMostSuccinctDataSize(),outputPositions,ImmutableList.copyOf(operatorSummaries.values()),drivers);
}
