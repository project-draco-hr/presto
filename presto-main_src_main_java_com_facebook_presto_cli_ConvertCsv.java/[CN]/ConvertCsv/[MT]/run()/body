{
  checkArgument(extractionSpecs != null && !extractionSpecs.isEmpty(),"Extraction Spec is required");
  final CountingInputStream countingInputStream;
  InputSupplier<InputStreamReader> readerSupplier;
  if (csvFile != null) {
    countingInputStream=null;
    readerSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    countingInputStream=new CountingInputStream(System.in);
    readerSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(countingInputStream,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableSortedMap.Builder<Integer,TupleInfo.Type> schemaBuilder=ImmutableSortedMap.naturalOrder();
  ImmutableList.Builder<OutputSupplier<? extends OutputStream>> outputSupplierBuilder=ImmutableList.builder();
  for (  String extractionSpec : extractionSpecs) {
    List<String> parts=ImmutableList.copyOf(Splitter.on(':').split(extractionSpec));
    checkState(parts.size() == 3,"type format: <column_index>:<data_type>:<encoding> (e.g. 0:long:raw, 3:string:rle)");
    Integer columnIndex;
    try {
      columnIndex=Integer.parseInt(parts.get(0));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException("Malformed column index: " + parts.get(0));
    }
    String dataTypeName=parts.get(1);
    String encodingName=parts.get(2);
    schemaBuilder.put(columnIndex,TupleInfo.Type.fromName(dataTypeName));
    outputSupplierBuilder.add(newOutputStreamSupplier(new File(outputDir,String.format("column%d.%s_%s.data",columnIndex,dataTypeName,encodingName))));
  }
  ImmutableSortedMap<Integer,TupleInfo.Type> schema=schemaBuilder.build();
  ImmutableList<OutputSupplier<? extends OutputStream>> outputSuppliers=outputSupplierBuilder.build();
  ImmutableList.Builder<Type> typesBuilder=ImmutableList.builder();
  ImmutableList.Builder<BlocksFileWriter> writersBuilder=ImmutableList.builder();
  for (int index=0; index <= schema.lastKey(); index++) {
    TupleInfo.Type type=VARIABLE_BINARY;
    if (schema.containsKey(index)) {
      type=schema.get(index);
    }
    typesBuilder.add(type);
    writersBuilder.add(new BlocksFileWriter(BlocksFileEncoding.RAW,outputSuppliers.get(index)));
  }
  List<Type> types=typesBuilder.build();
  List<BlocksFileWriter> writers=writersBuilder.build();
  DelimitedRecordSet records=new DelimitedRecordSet(readerSupplier,Splitter.on(toChar(columnSeparator)));
  DataSize dataSize;
  if (countingInputStream == null) {
    dataSize=new DataSize(csvFile.length(),Unit.BYTE);
  }
 else {
    dataSize=new DataSize(countingInputStream.getCount(),Unit.BYTE);
  }
  Operator source=new RecordProjectOperator(records,dataSize,types);
  long rowCount=ImportingOperator.importData(source,writers);
  log.info("Imported %d rows",rowCount);
}
