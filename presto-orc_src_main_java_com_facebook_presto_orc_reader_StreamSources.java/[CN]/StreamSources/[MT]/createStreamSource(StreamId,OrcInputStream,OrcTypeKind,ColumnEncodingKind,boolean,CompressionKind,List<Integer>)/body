{
  int compressedBlockOffset=0;
  if (!offsetPositions.isEmpty()) {
    compressedBlockOffset=Ints.checkedCast(offsetPositions.get(0));
    offsetPositions=offsetPositions.subList(1,offsetPositions.size());
  }
  int decompressedOffset;
  if (!offsetPositions.isEmpty() & compressionKind != UNCOMPRESSED) {
    decompressedOffset=Ints.checkedCast(offsetPositions.get(0));
    offsetPositions=offsetPositions.subList(1,offsetPositions.size());
  }
 else {
    decompressedOffset=compressedBlockOffset;
    compressedBlockOffset=0;
  }
  OrcByteSource byteSource=new OrcByteSource(inputStream,compressedBlockOffset,decompressedOffset);
  if (streamId.getStreamKind() == PRESENT) {
    return new BooleanStreamSource(byteSource,getBooleanStreamStartOffset(offsetPositions));
  }
  if (streamId.getStreamKind() == DICTIONARY_DATA) {
switch (type) {
case SHORT:
case INT:
case LONG:
      return new LongStreamSource(byteSource,DWRF_DIRECT,INT,true,usesVInt,getPosition(offsetPositions,0));
case STRING:
case VARCHAR:
case CHAR:
case BINARY:
    return new ByteArrayStreamSource(byteSource);
}
}
if ((encoding == DICTIONARY || encoding == DICTIONARY_V2) && (streamId.getStreamKind() == LENGTH || streamId.getStreamKind() == DATA)) {
return new LongStreamSource(byteSource,encoding,INT,false,usesVInt,getPosition(offsetPositions,0));
}
if (streamId.getStreamKind() == DATA) {
switch (type) {
case BOOLEAN:
  return new BooleanStreamSource(byteSource,getBooleanStreamStartOffset(offsetPositions));
case BYTE:
return new ByteStreamSource(byteSource,Ints.checkedCast(getPosition(offsetPositions,0)));
case SHORT:
case INT:
case LONG:
return new LongStreamSource(byteSource,encoding,type,true,usesVInt,getPosition(offsetPositions,0));
case FLOAT:
return new FloatStreamSource(byteSource,getPosition(offsetPositions,0));
case DOUBLE:
return new DoubleStreamSource(byteSource,getPosition(offsetPositions,0));
case DATE:
return new LongStreamSource(byteSource,encoding,type,true,usesVInt,getPosition(offsetPositions,0));
case STRING:
case BINARY:
return new ByteArrayStreamSource(byteSource);
case TIMESTAMP:
return new LongStreamSource(byteSource,encoding,type,true,usesVInt,getPosition(offsetPositions,0));
}
}
if (streamId.getStreamKind() == LENGTH) {
switch (type) {
case STRING:
case BINARY:
case MAP:
case LIST:
return new LongStreamSource(byteSource,encoding,type,false,usesVInt,getPosition(offsetPositions,0));
}
}
if (streamId.getStreamKind() == ROW_GROUP_DICTIONARY_LENGTH) {
switch (type) {
case STRING:
case BINARY:
return new RowGroupDictionaryLengthStreamSource(byteSource,encoding,false,getPosition(offsetPositions,0),getPosition(offsetPositions,1));
}
}
if (streamId.getStreamKind() == ROW_GROUP_DICTIONARY) {
switch (type) {
case STRING:
case BINARY:
return new ByteArrayStreamSource(byteSource);
}
}
if (streamId.getStreamKind() == IN_DICTIONARY) {
return new BooleanStreamSource(byteSource,getBooleanStreamStartOffset(offsetPositions));
}
if (type == TIMESTAMP && streamId.getStreamKind() == SECONDARY) {
return new LongStreamSource(byteSource,encoding,type,false,usesVInt,getPosition(offsetPositions,0));
}
throw new IllegalArgumentException("Unsupported column type " + type + " for stream "+ streamId);
}
