{
  ImmutableList.Builder<TupleInfo> tupleInfos=ImmutableList.builder();
  for (  Provider<AggregationFunctionStep> functionProvider : functionProviders) {
    tupleInfos.add(functionProvider.get().getTupleInfo());
  }
  this.tupleInfos=tupleInfos.build();
  ImmutableList.Builder<ObjectArrayList<AggregationFunctionStep>> builder=ImmutableList.builder();
  for (int i=0; i < functionProviders.size(); i++) {
    ObjectArrayList<AggregationFunctionStep> functions=ObjectArrayList.wrap(new AggregationFunctionStep[expectedGroups],0);
    builder.add(functions);
  }
  aggregateValues=builder.build();
  TupleInfo groupByTupleInfo=source.getTupleInfos().get(groupChannel);
  SliceHashStrategy hashStrategy=new SliceHashStrategy(groupByTupleInfo);
  Long2IntOpenCustomHashMap addressToGroupId=new Long2IntOpenCustomHashMap(expectedGroups,hashStrategy);
  addressToGroupId.defaultReturnValue(-1);
  Slice slice=Slices.allocate((int)BlockBuilder.DEFAULT_MAX_BLOCK_SIZE.toBytes());
  hashStrategy.addSlice(slice);
  BlockBuilder blockBuilder=new BlockBuilder(groupByTupleInfo,slice.length(),slice.getOutput());
  int nextGroupId=0;
  List<UncompressedBlock> groupByBlocks=new ArrayList<>();
  BlockCursor[] cursors=new BlockCursor[source.getChannelCount()];
  PageIterator iterator=source.iterator(operatorStats);
  while (iterator.hasNext()) {
    Page page=iterator.next();
    Block[] blocks=page.getBlocks();
    Slice groupBySlice=((UncompressedBlock)blocks[groupChannel]).getSlice();
    hashStrategy.setLookupSlice(groupBySlice);
    for (int i=0; i < blocks.length; i++) {
      cursors[i]=blocks[i].cursor();
    }
    int rows=page.getPositionCount();
    for (int position=0; position < rows; position++) {
      for (      BlockCursor cursor : cursors) {
        checkState(cursor.advanceNextPosition());
      }
      int groupByRawOffset=cursors[groupChannel].getRawOffset();
      int groupId=addressToGroupId.get(encodeSyntheticAddress(LOOKUP_SLICE_INDEX,groupByRawOffset));
      if (groupId < 0) {
        int length=groupByTupleInfo.size(groupBySlice,groupByRawOffset);
        if (blockBuilder.writableBytes() < length) {
          UncompressedBlock block=blockBuilder.build();
          groupByBlocks.add(block);
          slice=Slices.allocate(Math.max((int)BlockBuilder.DEFAULT_MAX_BLOCK_SIZE.toBytes(),length));
          blockBuilder=new BlockBuilder(groupByTupleInfo,slice.length(),slice.getOutput());
          hashStrategy.addSlice(slice);
        }
        blockBuilder.appendTuple(groupBySlice,groupByRawOffset,length);
        groupId=nextGroupId++;
        addressToGroupId.put(encodeSyntheticAddress(groupByBlocks.size() - 1,groupByRawOffset),groupId);
        for (int i=0; i < functionProviders.size(); i++) {
          Provider<AggregationFunctionStep> provider=functionProviders.get(i);
          AggregationFunctionStep function=provider.get();
          aggregateValues.get(i).add(function);
          function.add(cursors);
        }
      }
 else {
        for (        ObjectArrayList<AggregationFunctionStep> aggregateValue : aggregateValues) {
          AggregationFunctionStep function=aggregateValue.get(groupId);
          function.add(cursors);
        }
      }
    }
    for (    BlockCursor cursor : cursors) {
      checkState(!cursor.advanceNextPosition());
    }
  }
  groupByBlocksIterator=groupByBlocks.iterator();
}
