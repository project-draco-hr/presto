{
  Set<AnalyzedExpression> scalarExpressions=ImmutableSet.copyOf(concat(IterableTransformer.on(aggregations).transformAndFlatten(argumentGetter()).list(),groupBys));
  BiMap<Slot,Expression> scalarAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : scalarExpressions) {
    Slot slot=allocator.newSlot(expression);
    scalarAssignments.put(slot,expression.getRewrittenExpression());
  }
  PlanNode preProjectNode=source;
  if (!scalarAssignments.isEmpty()) {
    preProjectNode=new ProjectNode(source,scalarAssignments);
  }
  Map<Expression,Slot> substitutions=new HashMap<>();
  BiMap<Slot,FunctionCall> aggregationAssignments=HashBiMap.create();
  Map<Slot,FunctionInfo> functionInfos=new HashMap<>();
  for (  AnalyzedAggregation aggregation : aggregations) {
    FunctionCall rewrittenFunction=TreeRewriter.rewriteWith(substitution(scalarAssignments.inverse()),aggregation.getRewrittenCall());
    Slot slot=allocator.newSlot(aggregation.getType());
    aggregationAssignments.put(slot,rewrittenFunction);
    functionInfos.put(slot,aggregation.getFunctionInfo());
    substitutions.put(aggregation.getRewrittenCall(),slot);
  }
  List<Slot> groupBySlots=new ArrayList<>();
  for (  AnalyzedExpression groupBy : groupBys) {
    Expression rewritten=TreeRewriter.rewriteWith(substitution(scalarAssignments.inverse()),groupBy.getRewrittenExpression());
    Slot slot=allocator.newSlot(groupBy.getType(),rewritten);
    groupBySlots.add(slot);
    substitutions.put(groupBy.getRewrittenExpression(),slot);
  }
  PlanNode aggregationNode=new AggregationNode(preProjectNode,groupBySlots,aggregationAssignments,functionInfos);
  BiMap<Slot,Expression> postProjectScalarAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : ImmutableSet.copyOf(concat(outputs,groupBys))) {
    Expression rewritten=TreeRewriter.rewriteWith(substitution(substitutions),expression.getRewrittenExpression());
    Slot slot=allocator.newSlot(expression.getType(),rewritten);
    postProjectScalarAssignments.put(slot,rewritten);
    outputSubstitutions.put(expression.getRewrittenExpression(),slot);
  }
  return new ProjectNode(aggregationNode,postProjectScalarAssignments);
}
