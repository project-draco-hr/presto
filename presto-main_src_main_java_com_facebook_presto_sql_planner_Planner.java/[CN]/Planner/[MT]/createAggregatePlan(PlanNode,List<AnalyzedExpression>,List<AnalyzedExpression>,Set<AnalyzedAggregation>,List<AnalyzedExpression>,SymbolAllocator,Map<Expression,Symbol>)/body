{
  Set<AnalyzedExpression> scalarExpressions=ImmutableSet.copyOf(concat(IterableTransformer.on(aggregations).transformAndFlatten(argumentGetter()).list(),groupBys));
  BiMap<Symbol,Expression> scalarAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : scalarExpressions) {
    Symbol symbol=allocator.newSymbol(expression.getRewrittenExpression(),expression.getType());
    scalarAssignments.put(symbol,expression.getRewrittenExpression());
  }
  PlanNode preProjectNode=source;
  if (!scalarAssignments.isEmpty()) {
    preProjectNode=new ProjectNode(source,scalarAssignments);
  }
  Map<Expression,Symbol> substitutions=new HashMap<>();
  BiMap<Symbol,FunctionCall> aggregationAssignments=HashBiMap.create();
  Map<Symbol,FunctionInfo> functionInfos=new HashMap<>();
  for (  AnalyzedAggregation aggregation : aggregations) {
    FunctionCall rewrittenFunction=TreeRewriter.rewriteWith(substitution(scalarAssignments.inverse()),aggregation.getRewrittenCall());
    Symbol symbol=allocator.newSymbol(aggregation.getFunctionName().getSuffix(),aggregation.getType());
    aggregationAssignments.put(symbol,rewrittenFunction);
    functionInfos.put(symbol,aggregation.getFunctionInfo());
    substitutions.put(aggregation.getRewrittenCall(),symbol);
  }
  List<Symbol> groupBySymbols=new ArrayList<>();
  for (  AnalyzedExpression groupBy : groupBys) {
    Expression rewritten=TreeRewriter.rewriteWith(substitution(scalarAssignments.inverse()),groupBy.getRewrittenExpression());
    Symbol symbol=allocator.newSymbol(rewritten,groupBy.getType());
    groupBySymbols.add(symbol);
    substitutions.put(groupBy.getRewrittenExpression(),symbol);
  }
  PlanNode aggregationNode=new AggregationNode(preProjectNode,groupBySymbols,aggregationAssignments,functionInfos);
  BiMap<Symbol,Expression> postProjectScalarAssignments=HashBiMap.create();
  for (  AnalyzedExpression expression : ImmutableSet.copyOf(concat(outputs,groupBys,orderBy))) {
    Expression rewritten=TreeRewriter.rewriteWith(substitution(substitutions),expression.getRewrittenExpression());
    Symbol symbol=allocator.newSymbol(rewritten,expression.getType());
    postProjectScalarAssignments.put(symbol,rewritten);
    outputSubstitutions.put(expression.getRewrittenExpression(),symbol);
  }
  return new ProjectNode(aggregationNode,postProjectScalarAssignments);
}
