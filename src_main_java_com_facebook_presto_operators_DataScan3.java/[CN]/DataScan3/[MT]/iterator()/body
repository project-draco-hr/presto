{
  return new AbstractIterator<ValueBlock>(){
    Iterator<? extends ValueBlock> valueBlocks=source.iterator();
    Iterator<? extends ValueBlock> positionBlocks=positions.iterator();
    ValueBlock currentPositionBlock=positionBlocks.next();
    @Override protected ValueBlock computeNext(){
      while (valueBlocks.hasNext()) {
        ValueBlock currentValueBlock=valueBlocks.next();
        while (currentPositionBlock.getRange().getEnd() < currentValueBlock.getRange().getStart()) {
          if (!positionBlocks.hasNext()) {
            endOfData();
            return null;
          }
          currentPositionBlock=positionBlocks.next();
        }
        ImmutableList.Builder<ValueBlock> positionsForCurrentBlock=ImmutableList.builder();
        while (positionBlocks.hasNext() && currentPositionBlock.getRange().getEnd() < currentValueBlock.getRange().getEnd()) {
          positionsForCurrentBlock.add(currentPositionBlock);
          currentPositionBlock=positionBlocks.next();
        }
        if (currentPositionBlock.getRange().overlaps(currentValueBlock.getRange())) {
          positionsForCurrentBlock.add(currentPositionBlock);
        }
        List<Long> validPositions=getValidPositions(currentValueBlock,positionsForCurrentBlock.build());
        if (!validPositions.isEmpty()) {
          return new MaskedValueBlock(currentValueBlock,validPositions);
        }
      }
      endOfData();
      return null;
    }
    private List<Long> getValidPositions(    ValueBlock currentValueBlock,    List<ValueBlock> positionsForCurrentBlock){
      ImmutableList.Builder<Long> validPositions=ImmutableList.builder();
      BlockCursor valueCursor=currentValueBlock.blockCursor();
      valueCursor.advanceNextPosition();
      for (      ValueBlock positionBlock : positionsForCurrentBlock) {
        BlockCursor positionCursor=positionBlock.blockCursor();
        while (positionCursor.advanceNextPosition()) {
          long nextPosition=positionCursor.getPosition();
          if (nextPosition > valueCursor.getRange().getEnd()) {
            break;
          }
          if (nextPosition > valueCursor.getPosition()) {
            valueCursor.advanceToPosition(nextPosition);
          }
          if (valueCursor.getPosition() == nextPosition) {
            validPositions.add(nextPosition);
          }
        }
      }
      return validPositions.build();
    }
  }
;
}
