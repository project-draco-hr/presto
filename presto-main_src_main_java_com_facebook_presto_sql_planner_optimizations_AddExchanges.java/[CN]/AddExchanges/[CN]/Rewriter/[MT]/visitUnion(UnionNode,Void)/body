{
  List<PlanNode> unpartitionedChildren=new ArrayList<>();
  List<List<Symbol>> unpartitionedOutputLayouts=new ArrayList<>();
  List<PlanNode> partitionedChildren=new ArrayList<>();
  List<List<Symbol>> partitionedOutputLayouts=new ArrayList<>();
  List<PlanNode> sources=node.getSources();
  for (int i=0; i < sources.size(); i++) {
    PlanWithProperties child=sources.get(i).accept(this,context);
    if (child.getProperties().isUnpartitioned()) {
      unpartitionedChildren.add(child.getNode());
      unpartitionedOutputLayouts.add(node.sourceOutputLayout(i));
    }
 else {
      partitionedChildren.add(child.getNode());
      partitionedOutputLayouts.add(node.sourceOutputLayout(i));
    }
  }
  PlanNode result=null;
  if (!partitionedChildren.isEmpty()) {
    result=new ExchangeNode(idAllocator.getNextId(),ExchangeNode.Type.GATHER,ImmutableList.of(),Optional.<Symbol>empty(),partitionedChildren,node.getOutputSymbols(),partitionedOutputLayouts);
    unpartitionedChildren.add(result);
    unpartitionedOutputLayouts.add(result.getOutputSymbols());
  }
  if (unpartitionedChildren.size() > 1) {
    ImmutableListMultimap.Builder<Symbol,Symbol> mappings=ImmutableListMultimap.builder();
    for (int i=0; i < node.getOutputSymbols().size(); i++) {
      for (      List<Symbol> outputLayout : unpartitionedOutputLayouts) {
        mappings.put(node.getOutputSymbols().get(i),outputLayout.get(i));
      }
    }
    result=new UnionNode(node.getId(),unpartitionedChildren,mappings.build());
  }
  return new PlanWithProperties(result,ActualProperties.of(PartitioningProperties.unpartitioned(),PlacementProperties.anywhere()));
}
