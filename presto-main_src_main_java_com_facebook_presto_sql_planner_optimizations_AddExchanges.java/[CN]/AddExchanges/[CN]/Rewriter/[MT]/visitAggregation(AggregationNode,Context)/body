{
  HashSet<Symbol> partitioningRequirement=new HashSet<>(node.getGroupingSets().get(0));
  for (int i=1; i < node.getGroupingSets().size(); i++) {
    partitioningRequirement.retainAll(node.getGroupingSets().get(i));
  }
  PreferredProperties preferredProperties=PreferredProperties.any();
  if (!node.getGroupingKeys().isEmpty()) {
    preferredProperties=PreferredProperties.partitionedWithLocal(partitioningRequirement,grouped(node.getGroupingKeys())).mergeWithParent(context.getPreferredProperties());
  }
  PlanWithProperties child=planChild(node,context.withPreferredProperties(preferredProperties));
  if (child.getProperties().isSingleNode()) {
    return rebaseAndDeriveProperties(node,child);
  }
  if (node.getGroupingKeys().isEmpty()) {
    child=withDerivedProperties(gatheringExchange(idAllocator.getNextId(),REMOTE,child.getNode()),child.getProperties());
  }
 else   if (!child.getProperties().isStreamPartitionedOn(partitioningRequirement) && !child.getProperties().isNodePartitionedOn(partitioningRequirement)) {
    child=withDerivedProperties(partitionedExchange(idAllocator.getNextId(),REMOTE,child.getNode(),node.getGroupingKeys(),node.getHashSymbol()),child.getProperties());
  }
  return rebaseAndDeriveProperties(node,child);
}
