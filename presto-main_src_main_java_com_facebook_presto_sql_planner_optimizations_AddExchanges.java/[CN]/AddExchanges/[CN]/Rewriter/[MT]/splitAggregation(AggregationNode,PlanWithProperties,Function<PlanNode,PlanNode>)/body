{
  Map<Symbol,Symbol> masks=node.getMasks();
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> intermediateCalls=new HashMap<>();
  Map<Symbol,Signature> intermediateFunctions=new HashMap<>();
  Map<Symbol,Symbol> intermediateMask=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    Signature signature=node.getFunctions().get(entry.getKey());
    InternalAggregationFunction function=metadata.getFunctionRegistry().getAggregateFunctionImplementation(signature);
    Symbol intermediateSymbol=allocator.newSymbol(signature.getName(),function.getIntermediateType());
    intermediateCalls.put(intermediateSymbol,entry.getValue());
    intermediateFunctions.put(intermediateSymbol,signature);
    if (masks.containsKey(entry.getKey())) {
      intermediateMask.put(intermediateSymbol,masks.get(entry.getKey()));
    }
    finalCalls.put(entry.getKey(),new FunctionCall(QualifiedName.of(signature.getName()),ImmutableList.<Expression>of(new QualifiedNameReference(intermediateSymbol.toQualifiedName()))));
  }
  PlanWithProperties partial=withDerivedProperties(new AggregationNode(idAllocator.getNextId(),newChild.getNode(),node.getGroupBy(),intermediateCalls,intermediateFunctions,intermediateMask,PARTIAL,node.getSampleWeight(),node.getConfidence(),node.getHashSymbol()),newChild.getProperties());
  PlanNode source=partial.getNode();
  if (exchanger != null) {
    source=exchanger.apply(source);
  }
  return withDerivedProperties(new AggregationNode(node.getId(),source,node.getGroupBy(),finalCalls,node.getFunctions(),ImmutableMap.of(),FINAL,Optional.empty(),node.getConfidence(),node.getHashSymbol()),deriveProperties(source,partial.getProperties()));
}
