{
  Map<Symbol,Symbol> masks=node.getMasks();
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> intermediateCalls=new HashMap<>();
  Map<Symbol,Signature> intermediateFunctions=new HashMap<>();
  Map<Symbol,Symbol> intermediateMask=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    Signature signature=node.getFunctions().get(entry.getKey());
    FunctionInfo function=metadata.getExactFunction(signature);
    Symbol intermediateSymbol=allocator.newSymbol(function.getSignature().getName(),metadata.getType(function.getIntermediateType()));
    intermediateCalls.put(intermediateSymbol,entry.getValue());
    intermediateFunctions.put(intermediateSymbol,signature);
    if (masks.containsKey(entry.getKey())) {
      intermediateMask.put(intermediateSymbol,masks.get(entry.getKey()));
    }
    finalCalls.put(entry.getKey(),new FunctionCall(QualifiedName.of(function.getSignature().getName()),ImmutableList.<Expression>of(new QualifiedNameReference(intermediateSymbol.toQualifiedName()))));
  }
  PlanWithProperties partial=withDerivedProperties(new AggregationNode(idAllocator.getNextId(),newChild.getNode(),node.getGroupBy(),intermediateCalls,intermediateFunctions,intermediateMask,PARTIAL,node.getSampleWeight(),node.getConfidence(),node.getHashSymbol()),newChild.getProperties());
  PlanNode exchange=exchanger.apply(partial.getNode());
  return withDerivedProperties(new AggregationNode(node.getId(),exchange,node.getGroupBy(),finalCalls,node.getFunctions(),ImmutableMap.of(),FINAL,Optional.empty(),node.getConfidence(),node.getHashSymbol()),deriveProperties(exchange,partial.getProperties()));
}
