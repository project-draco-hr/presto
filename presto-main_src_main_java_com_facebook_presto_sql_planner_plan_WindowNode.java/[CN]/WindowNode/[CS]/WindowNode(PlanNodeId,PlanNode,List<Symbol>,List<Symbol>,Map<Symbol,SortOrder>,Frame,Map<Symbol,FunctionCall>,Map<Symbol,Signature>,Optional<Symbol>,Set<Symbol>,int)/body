{
  super(id);
  requireNonNull(source,"source is null");
  requireNonNull(partitionBy,"partitionBy is null");
  requireNonNull(orderBy,"orderBy is null");
  checkArgument(orderings.size() == orderBy.size(),"orderBy and orderings sizes don't match");
  checkArgument(orderings.keySet().containsAll(orderBy),"Every orderBy symbol must have an ordering direction");
  requireNonNull(frame,"frame is null");
  requireNonNull(windowFunctions,"windowFunctions is null");
  requireNonNull(signatures,"signatures is null");
  checkArgument(windowFunctions.keySet().equals(signatures.keySet()),"windowFunctions does not match signatures");
  requireNonNull(hashSymbol,"hashSymbol is null");
  checkArgument(partitionBy.containsAll(prePartitionedInputs),"prePartitionedInputs must be contained in partitionBy");
  checkArgument(preSortedOrderPrefix <= orderBy.size(),"Cannot have sorted more symbols than those requested");
  checkArgument(preSortedOrderPrefix == 0 || ImmutableSet.copyOf(prePartitionedInputs).equals(ImmutableSet.copyOf(partitionBy)),"preSortedOrderPrefix can only be greater than zero if all partition symbols are pre-partitioned");
  this.source=source;
  this.prePartitionedInputs=ImmutableSet.copyOf(prePartitionedInputs);
  this.specification=new Specification(partitionBy,orderBy,orderings,frame);
  this.windowFunctions=ImmutableMap.copyOf(windowFunctions);
  this.functionHandles=ImmutableMap.copyOf(signatures);
  this.hashSymbol=hashSymbol;
  this.preSortedOrderPrefix=preSortedOrderPrefix;
}
