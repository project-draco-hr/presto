{
  super(id);
  checkNotNull(source,"source is null");
  checkNotNull(partitionBy,"partitionBy is null");
  checkNotNull(orderBy,"orderBy is null");
  checkArgument(orderings.size() == orderBy.size(),"orderBy and orderings sizes don't match");
  checkArgument(orderings.keySet().containsAll(orderBy),"Every orderBy symbol must have an ordering direction");
  checkNotNull(frame,"frame is null");
  checkNotNull(windowFunctions,"windowFunctions is null");
  checkNotNull(signatures,"signatures is null");
  checkArgument(windowFunctions.keySet().equals(signatures.keySet()),"windowFunctions does not match signatures");
  checkNotNull(hashSymbol,"hashSymbol is null");
  checkArgument(partitionBy.containsAll(prePartitionedInputs),"prePartitionedInputs must be contained in partitionBy");
  checkArgument(preSortedOrderPrefix <= orderBy.size(),"Cannot have sorted more symbols than those requested");
  checkArgument(preSortedOrderPrefix == 0 || ImmutableSet.copyOf(prePartitionedInputs).equals(ImmutableSet.copyOf(partitionBy)),"preSortedOrderPrefix can only be greater than zero if all partition symbols are pre-partitioned");
  this.source=source;
  this.partitionBy=ImmutableList.copyOf(partitionBy);
  this.prePartitionedInputs=ImmutableSet.copyOf(prePartitionedInputs);
  this.orderBy=ImmutableList.copyOf(orderBy);
  this.orderings=ImmutableMap.copyOf(orderings);
  this.frame=frame;
  this.windowFunctions=ImmutableMap.copyOf(windowFunctions);
  this.functionHandles=ImmutableMap.copyOf(signatures);
  this.hashSymbol=hashSymbol;
  this.preSortedOrderPrefix=preSortedOrderPrefix;
}
