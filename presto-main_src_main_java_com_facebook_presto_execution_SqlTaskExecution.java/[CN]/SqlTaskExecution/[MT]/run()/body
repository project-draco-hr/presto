{
  taskOutput.getStats().recordExecutionStart();
  try {
    List<PlanFragmentSource> splits=this.splits.getAndSet(null);
    if (splits == null) {
      return;
    }
    final SourceHashProviderFactory sourceHashProviderFactory=new SourceHashProviderFactory(maxOperatorMemoryUsage);
    if (splits.size() <= 1) {
      PlanFragmentSource split=splits.isEmpty() ? null : splits.get(0);
      SplitWorker worker=new SplitWorker(session,taskOutput,fragment,split,exchangeSources,sourceHashProviderFactory,sourceProvider,metadata,maxOperatorMemoryUsage);
      worker.call();
    }
 else {
      List<Callable<Void>> workers=ImmutableList.copyOf(Lists.transform(splits,new Function<PlanFragmentSource,Callable<Void>>(){
        @Override public Callable<Void> apply(        PlanFragmentSource split){
          return new SplitWorker(session,taskOutput,fragment,split,exchangeSources,sourceHashProviderFactory,sourceProvider,metadata,maxOperatorMemoryUsage);
        }
      }
));
      List<FutureTask<Void>> results=shardExecutor.processBatch(workers);
      for (      FutureTask<Void> worker : Lists.reverse(results)) {
        if (taskOutput.getState().isDone()) {
          worker.cancel(true);
        }
 else {
          worker.run();
        }
      }
      checkQueryResults(results);
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
    taskOutput.queryFailed(e);
    throw Throwables.propagate(e);
  }
catch (  Throwable e) {
    taskOutput.queryFailed(e);
    throw Throwables.propagate(e);
  }
 finally {
    taskOutput.finish();
  }
}
