{
  Preconditions.checkNotNull(session,"session is null");
  Preconditions.checkNotNull(queryId,"queryId is null");
  Preconditions.checkNotNull(stageId,"stageId is null");
  Preconditions.checkNotNull(taskId,"taskId is null");
  Preconditions.checkNotNull(fragment,"fragment is null");
  Preconditions.checkNotNull(initialSources,"initialSources is null");
  Preconditions.checkNotNull(initialOutputIds,"initialOutputIds is null");
  Preconditions.checkArgument(pageBufferMax > 0,"pageBufferMax must be at least 1");
  Preconditions.checkNotNull(metadata,"metadata is null");
  Preconditions.checkNotNull(shardExecutor,"shardExecutor is null");
  Preconditions.checkNotNull(maxOperatorMemoryUsage,"maxOperatorMemoryUsage is null");
  this.session=session;
  this.taskId=taskId;
  this.fragment=fragment;
  this.dataStreamProvider=dataStreamProvider;
  this.exchangeOperatorFactory=exchangeOperatorFactory;
  this.shardExecutor=shardExecutor;
  this.metadata=metadata;
  this.maxOperatorMemoryUsage=maxOperatorMemoryUsage;
  this.taskOutput=new TaskOutput(queryId,stageId,taskId,location,initialOutputIds,pageBufferMax);
  taskOutput.getStats().recordExecutionStart();
  sourceIds=ImmutableSet.copyOf(transform(fragment.getSources(),new Function<PlanNode,PlanNodeId>(){
    @Override public PlanNodeId apply(    PlanNode input){
      return input.getId();
    }
  }
));
  Set<Split> initialSplits=ImmutableSet.of();
  for (  Entry<PlanNodeId,Set<Split>> entry : initialSources.entrySet()) {
    if (!entry.getKey().equals(fragment.getPartitionedSource())) {
      unpartitionedSources.putAll(entry.getKey(),entry.getValue());
    }
 else {
      initialSplits=entry.getValue();
    }
  }
  if (!fragment.isPartitioned()) {
    scheduleSplitWorker(null,null);
  }
 else {
    for (    Split initialSplit : initialSplits) {
      addSplit(fragment.getPartitionedSource(),initialSplit);
    }
  }
}
