{
  try (SetThreadName setThreadName=new SetThreadName("Task-%s",taskId)){
    this.taskId=checkNotNull(taskId,"taskId is null");
    this.location=checkNotNull(location,"location is null");
    this.taskExecutor=checkNotNull(taskExecutor,"driverExecutor is null");
    this.notificationExecutor=checkNotNull(notificationExecutor,"notificationExecutor is null");
    this.taskStateMachine=new TaskStateMachine(taskId,notificationExecutor);
    taskStateMachine.addStateChangeListener(new StateChangeListener<TaskState>(){
      @Override public void stateChanged(      TaskState taskState){
        if (taskState.isDone()) {
          SqlTaskExecution.this.taskExecutor.removeTask(taskHandle);
          sharedBuffer.destroy();
        }
      }
    }
);
    this.taskContext=new TaskContext(taskStateMachine,notificationExecutor,session,checkNotNull(maxTaskMemoryUsage,"maxTaskMemoryUsage is null"),checkNotNull(operatorPreAllocatedMemory,"operatorPreAllocatedMemory is null"),cpuTimerEnabled);
    this.sharedBuffer=new SharedBuffer(taskId,notificationExecutor,checkNotNull(maxBufferSize,"maxBufferSize is null"),outputBuffers);
    sharedBuffer.addStateChangeListener(new StateChangeListener<QueueState>(){
      @Override public void stateChanged(      QueueState taskState){
        if (taskState == QueueState.FINISHED) {
          checkTaskCompletion();
        }
      }
    }
);
    this.queryMonitor=checkNotNull(queryMonitor,"queryMonitor is null");
    taskHandle=taskExecutor.addTask(taskId);
    LocalExecutionPlan localExecutionPlan=planner.plan(session,fragment.getRoot(),fragment.getSymbols(),new TaskOutputFactory(sharedBuffer));
    List<DriverFactory> driverFactories=localExecutionPlan.getDriverFactories();
    DriverSplitRunnerFactory partitionedDriverFactory=null;
    ImmutableList.Builder<DriverSplitRunnerFactory> unpartitionedDriverFactories=ImmutableList.builder();
    for (    DriverFactory driverFactory : driverFactories) {
      if (driverFactory.getSourceIds().contains(fragment.getPartitionedSource())) {
        checkState(partitionedDriverFactory == null,"multiple partitioned sources are not supported");
        partitionedDriverFactory=new DriverSplitRunnerFactory(driverFactory);
      }
 else {
        unpartitionedDriverFactories.add(new DriverSplitRunnerFactory(driverFactory));
      }
    }
    this.unpartitionedDriverFactories=unpartitionedDriverFactories.build();
    if (fragment.getDistribution() == PlanDistribution.SOURCE) {
      checkArgument(partitionedDriverFactory != null,"Fragment is partitioned, but no partitioned driver found");
    }
    this.partitionedSourceId=fragment.getPartitionedSource();
    this.partitionedDriverFactory=partitionedDriverFactory;
  }
 }
