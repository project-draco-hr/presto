{
  checkArgument(maxSizePerThread > 0,"max size must be greater than zero");
  cache=new ThreadLocal<LinkedHashMap<K,V>>(){
    @SuppressWarnings({"CloneableClassWithoutClone","ClassExtendsConcreteCollection"}) @Override protected LinkedHashMap<K,V> initialValue(){
      return new LinkedHashMap<K,V>(){
        @Override protected boolean removeEldestEntry(        Map.Entry<K,V> eldest){
          return size() > maxSizePerThread;
        }
      }
;
    }
  }
;
}
