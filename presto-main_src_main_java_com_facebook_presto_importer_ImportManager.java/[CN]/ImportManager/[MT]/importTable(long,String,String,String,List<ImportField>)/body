{
  checkNotNull(sourceName,"sourceName is null");
  checkNotNull(databaseName,"databaseName is null");
  checkNotNull(tableName,"tableName is null");
  checkNotNull(fields,"fields is null");
  checkArgument(!fields.isEmpty(),"fields is empty");
  shardManager.createImportTable(tableId,sourceName,databaseName,tableName);
  Set<String> activePartitions=retry().stopOnIllegalExceptions().runUnchecked(new Callable<Set<String>>(){
    @Override public Set<String> call() throws Exception {
      ImportClient importClient=importClientManager.getClient(sourceName);
      return ImmutableSet.copyOf(importClient.getPartitionNames(databaseName,tableName));
    }
  }
);
  log.info("Found %d current remote partitions: table %d",activePartitions.size(),tableId);
  Set<String> allPartitions=shardManager.getAllPartitions(tableId);
  Set<String> committedPartitions=shardManager.getCommittedPartitions(new NativeTableHandle(tableId));
  Set<String> uncommittedPartitions=Sets.difference(allPartitions,committedPartitions);
  Set<String> operatingPartitions=partitionOperationTracker.getOperatingPartitions(tableId);
  Set<String> erroredPartitions=Sets.difference(uncommittedPartitions,operatingPartitions);
  Set<String> repairPartitions=Sets.intersection(erroredPartitions,activePartitions);
  log.info("Repairing %d failed partitions from before: table %d",repairPartitions.size(),tableId);
  Set<String> partitionsToAdd=Sets.difference(activePartitions,allPartitions);
  Set<String> partitionsToRemove=Sets.difference(allPartitions,activePartitions);
  ImmutableSet.Builder<ListenableFuture<?>> builder=ImmutableSet.builder();
  for (  String partition : Iterables.concat(partitionsToRemove,repairPartitions)) {
    ListenableFutureTask<Void> dropFuture=ListenableFutureTask.create(new PartitionDropJob(tableId,partition),null);
    builder.add(dropFuture);
    partitionBoundedExecutor.execute(PartitionMarker.from(tableId,partition),dropFuture);
  }
  log.info("Dropping %d old partitions: table %d",partitionsToRemove.size(),tableId);
  List<String> columns=transform(fields,compose(columnNameGetter(),sourceColumnHandleGetter()));
  for (  String partition : Iterables.concat(partitionsToAdd,repairPartitions)) {
    PartitionChunkSupplier supplier=new PartitionChunkSupplier(importClientManager,sourceName,databaseName,tableName,partition,columns);
    ListenableFutureTask<Void> importJob=ListenableFutureTask.create(new PartitionImportJob(tableId,sourceName,partition,supplier,fields),null);
    builder.add(importJob);
    partitionBoundedExecutor.execute(PartitionMarker.from(tableId,partition),importJob);
  }
  log.info("Loading %d new partitions: table %d",partitionsToAdd.size(),tableId);
  return Futures.allAsList(builder.build());
}
