{
  final AsyncSemaphore<Runnable> asyncSemaphore=new AsyncSemaphore<>(2,executor,new Function<Runnable,ListenableFuture<?>>(){
    @Override public ListenableFuture<?> apply(    Runnable task){
      return executor.submit(task);
    }
  }
);
  final AtomicInteger count=new AtomicInteger();
  final AtomicInteger concurrency=new AtomicInteger();
  final CountDownLatch startLatch=new CountDownLatch(1);
  final CountDownLatch completionLatch=new CountDownLatch(100);
  for (int i=0; i < 100; i++) {
    executor.execute(new Runnable(){
      @Override public void run(){
        Uninterruptibles.awaitUninterruptibly(startLatch,1,TimeUnit.MINUTES);
        asyncSemaphore.submit(new Runnable(){
          @Override public void run(){
            count.incrementAndGet();
            int currentConcurrency=concurrency.incrementAndGet();
            assertLessThanOrEqual(currentConcurrency,2);
            Uninterruptibles.sleepUninterruptibly(1,TimeUnit.MILLISECONDS);
            concurrency.decrementAndGet();
            completionLatch.countDown();
          }
        }
);
      }
    }
);
  }
  startLatch.countDown();
  Uninterruptibles.awaitUninterruptibly(completionLatch,1,TimeUnit.MINUTES);
  Assert.assertEquals(count.get(),100);
}
