{
  final AtomicInteger successCount=new AtomicInteger();
  final AtomicInteger failureCount=new AtomicInteger();
  final AtomicInteger concurrency=new AtomicInteger();
  final CountDownLatch completionLatch=new CountDownLatch(1000);
  AsyncSemaphore<Runnable> asyncSemaphore=new AsyncSemaphore<>(2,executor,new Function<Runnable,ListenableFuture<?>>(){
    @Override public ListenableFuture<?> apply(    Runnable task){
      int currentConcurrency=concurrency.incrementAndGet();
      assertLessThanOrEqual(currentConcurrency,2);
      Uninterruptibles.sleepUninterruptibly(1,TimeUnit.MILLISECONDS);
      concurrency.decrementAndGet();
      throw new IllegalStateException();
    }
  }
);
  List<ListenableFuture<?>> futures=new ArrayList<>();
  for (int i=0; i < 1000; i++) {
    ListenableFuture<?> future=asyncSemaphore.submit(new Runnable(){
      @Override public void run(){
        Assert.fail();
      }
    }
);
    Futures.addCallback(future,new FutureCallback<Object>(){
      @Override public void onSuccess(      @Nullable Object result){
        successCount.incrementAndGet();
        completionLatch.countDown();
      }
      @Override public void onFailure(      Throwable t){
        failureCount.incrementAndGet();
        completionLatch.countDown();
      }
    }
);
    futures.add(future);
  }
  completionLatch.await(1,TimeUnit.MINUTES);
  for (  ListenableFuture<?> future : futures) {
    try {
      future.get();
      Assert.fail();
    }
 catch (    Exception ignored) {
    }
  }
  Assert.assertEquals(successCount.get(),0);
  Assert.assertEquals(failureCount.get(),1000);
}
