{
  List<Expression> leftConjuncts=new ArrayList<>();
  List<Expression> rightConjuncts=new ArrayList<>();
  for (  Expression conjunct : ExpressionUtils.extractConjuncts(context.getInheritedPredicate())) {
    Set<Symbol> symbols=DependencyExtractor.extract(conjunct);
    if (node.getLeft().getOutputSymbols().containsAll(symbols)) {
      leftConjuncts.add(conjunct);
    }
 else     if (node.getRight().getOutputSymbols().containsAll(symbols)) {
      rightConjuncts.add(conjunct);
    }
  }
  Expression leftPredicate=BooleanLiteral.TRUE_LITERAL;
  if (!leftConjuncts.isEmpty() && node.getType() != JoinNode.Type.LEFT) {
    leftPredicate=ExpressionUtils.and(leftConjuncts);
  }
  Expression rightPredicate=BooleanLiteral.TRUE_LITERAL;
  if (!rightConjuncts.isEmpty() && node.getType() != JoinNode.Type.LEFT) {
    rightPredicate=ExpressionUtils.and(rightConjuncts);
  }
  NodeSplits leftSplits=node.getLeft().accept(this,new VisitorContext(leftPredicate,context.getPartitionPredicate()));
  NodeSplits rightSplits=node.getRight().accept(this,new VisitorContext(rightPredicate,context.getPartitionPredicate()));
  if (leftSplits.dataSource.isPresent() && rightSplits.dataSource.isPresent()) {
    throw new IllegalArgumentException("Both left and right join nodes are partitioned");
  }
  if (leftSplits.dataSource.isPresent()) {
    return leftSplits;
  }
 else {
    return rightSplits;
  }
}
