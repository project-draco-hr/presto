{
  OrcTypeKind type=types.get(streamId.getColumn()).getOrcTypeKind();
  int compressionOffsets=compressionKind != UNCOMPRESSED ? 1 : 0;
  List<Long> offsetPositions=positionsList;
  if (streamId.getStreamKind() == PRESENT) {
    return offsetPositions.subList(0,BITFIELD_POSITIONS + compressionOffsets);
  }
  if (availableStreams.contains(PRESENT)) {
    offsetPositions=offsetPositions.subList(BITFIELD_POSITIONS + compressionOffsets,offsetPositions.size());
  }
  if (streamId.getStreamKind() == DATA) {
switch (type) {
case BYTE:
case SHORT:
case INT:
case LONG:
{
        int start;
        if (columnEncoding == DICTIONARY && availableStreams.contains(IN_DICTIONARY)) {
          start=BITFIELD_POSITIONS + compressionOffsets;
        }
 else {
          start=0;
        }
        int end;
        if (columnEncoding == DWRF_DIRECT) {
          end=start + BYTE_STREAM_POSITIONS + compressionOffsets;
        }
 else {
          end=start + INT_POSITIONS + compressionOffsets;
        }
        return offsetPositions.subList(start,end);
      }
case BOOLEAN:
case FLOAT:
case DOUBLE:
case DATE:
case STRUCT:
case MAP:
case LIST:
case UNION:
    return offsetPositions;
case STRING:
case BINARY:
  if (columnEncoding == DIRECT || columnEncoding == DIRECT_V2 || columnEncoding == DWRF_DIRECT) {
    return offsetPositions.subList(0,BYTE_STREAM_POSITIONS + compressionOffsets);
  }
 else   if (columnEncoding == DICTIONARY || columnEncoding == DICTIONARY_V2) {
    int start;
    if (availableStreams.contains(ROW_GROUP_DICTIONARY)) {
      start=(BYTE_STREAM_POSITIONS + compressionOffsets) + (ROW_GROUP_DICTIONARY_LENGTH_POSITIONS + compressionOffsets);
    }
 else {
      start=0;
    }
    int end=start + INT_POSITIONS + compressionOffsets;
    return offsetPositions.subList(start,end);
  }
 else {
    throw new IllegalArgumentException("Unsupported encoding " + columnEncoding);
  }
case TIMESTAMP:
return offsetPositions.subList(0,INT_POSITIONS + compressionOffsets);
default :
throw new IllegalArgumentException("Unknown type " + type);
}
}
if (streamId.getStreamKind() == LENGTH) {
switch (type) {
case STRING:
case BINARY:
if (columnEncoding == DIRECT || columnEncoding == DIRECT_V2 || columnEncoding == DWRF_DIRECT) {
int start=BYTE_STREAM_POSITIONS + compressionOffsets;
int end=start + INT_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
 else if (columnEncoding == DICTIONARY || columnEncoding == DICTIONARY_V2) {
int start=0;
if (availableStreams.contains(DICTIONARY_DATA)) {
start=BYTE_STREAM_POSITIONS + compressionOffsets;
}
int end=start + INT_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
 else {
throw new IllegalArgumentException("Unsupported encoding " + columnEncoding);
}
case MAP:
case LIST:
return offsetPositions;
}
}
if (streamId.getStreamKind() == SECONDARY && type == TIMESTAMP) {
int start=INT_POSITIONS + compressionOffsets;
int end=start + INT_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
if (streamId.getStreamKind() == ROW_GROUP_DICTIONARY) {
switch (type) {
case STRING:
case BINARY:
int start=0;
int end=start + BYTE_STREAM_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
}
if (streamId.getStreamKind() == ROW_GROUP_DICTIONARY_LENGTH) {
switch (type) {
case STRING:
case BINARY:
int start=BYTE_STREAM_POSITIONS + compressionOffsets;
int end=start + ROW_GROUP_DICTIONARY_LENGTH_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
}
if (streamId.getStreamKind() == IN_DICTIONARY) {
switch (type) {
case BYTE:
case SHORT:
case INT:
case LONG:
{
int start=0;
int end=start + BITFIELD_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
case STRING:
case BINARY:
{
int start=(BYTE_STREAM_POSITIONS + compressionOffsets) + (ROW_GROUP_DICTIONARY_LENGTH_POSITIONS + compressionOffsets) + (INT_POSITIONS + compressionOffsets);
int end=start + BITFIELD_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
}
}
throw new IllegalArgumentException("Unsupported column type " + type + " for stream "+ streamId);
}
