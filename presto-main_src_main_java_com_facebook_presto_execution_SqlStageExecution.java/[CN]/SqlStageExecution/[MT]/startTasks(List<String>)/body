{
  Preconditions.checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
    if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
      return;
    }
  }
  List<Partition> partitions;
  if (!splits.isPresent()) {
    ArrayList<Node> nodes=new ArrayList<>(nodeManager.getActiveNodes());
    Preconditions.checkState(!nodes.isEmpty(),"Cluster does not have any active nodes");
    Collections.shuffle(nodes,random);
    Node node=nodes.get(0);
    partitions=ImmutableList.of(new Partition(node,ImmutableList.<Split>of()));
  }
 else {
    Multimap<Node,Split> nodeSplits=SplitAssignments.balancedNodeAssignment(queryState,splits.get());
    ImmutableList.Builder<Partition> partitionBuilder=ImmutableList.builder();
    for (    Entry<Node,Collection<Split>> entry : nodeSplits.asMap().entrySet()) {
      partitionBuilder.add(new Partition(entry.getKey(),entry.getValue()));
    }
    partitions=partitionBuilder.build();
  }
  List<String> nodeIds=IterableTransformer.on(partitions).transform(nodeIdentifierGetter()).list();
  for (  StageExecution subStage : subStages.values()) {
    subStage.startTasks(nodeIds);
  }
  Set<ExchangeNode> exchanges=IterableTransformer.on(plan.getSources()).select(Predicates.instanceOf(ExchangeNode.class)).cast(ExchangeNode.class).set();
  int nextTaskId=0;
  for (  Partition partition : partitions) {
    String nodeIdentifier=partition.getNode().getNodeIdentifier();
    ImmutableMap.Builder<PlanNodeId,Set<Split>> fixedSources=ImmutableMap.builder();
    for (    ExchangeNode exchange : exchanges) {
      StageExecution childStage=subStages.get(exchange.getSourceFragmentId());
      Set<Split> exchangeSplits=childStage.getSplitsForExchange(nodeIdentifier);
      fixedSources.put(exchange.getId(),exchangeSplits);
    }
    String taskId=stageId + '.' + nextTaskId++;
    RemoteTask task=remoteTaskFactory.createRemoteTask(session,queryId,stageId,taskId,partition.getNode(),plan,fixedSources.build(),outputIds);
    tasks.add(task);
    try {
      task.start();
      if (plan.getPartitionedSource() != null) {
        for (        Split split : partition.getSplits()) {
          task.addSource(plan.getPartitionedSource(),split);
        }
        task.noMoreSources(plan.getPartitionedSource());
      }
    }
 catch (    Throwable e) {
synchronized (this) {
        failureCauses.add(e);
        transitionToState(StageState.FAILED);
      }
      log.error(e,"Stage %s failed to start",stageId);
      cancel();
      throw Throwables.propagate(e);
    }
  }
  transitionToState(StageState.SCHEDULED);
}
