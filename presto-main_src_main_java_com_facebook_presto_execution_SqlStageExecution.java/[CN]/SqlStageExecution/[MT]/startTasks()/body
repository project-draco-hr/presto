{
  try {
    Preconditions.checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
      if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
        return;
      }
    }
    AtomicInteger nextTaskId=new AtomicInteger(0);
    if (!splits.isPresent()) {
      ArrayList<Node> nodes=new ArrayList<>(nodeManager.getActiveNodes());
      Preconditions.checkState(!nodes.isEmpty(),"Cluster does not have any active nodes");
      Collections.shuffle(nodes,random);
      Node randomNode=nodes.get(0);
      scheduleTask(nextTaskId,randomNode,null);
    }
 else {
      final Object2IntOpenHashMap<Node> nodeSplits=new Object2IntOpenHashMap<>();
      Comparator<Node> byAssignedSplitsCount=new Comparator<Node>(){
        @Override public int compare(        Node o1,        Node o2){
          return Ints.compare(nodeSplits.getInt(o1),nodeSplits.getInt(o2));
        }
      }
;
      for (      SplitAssignments assignment : splits.get()) {
        if (getState().isDone()) {
          break;
        }
        Node chosen=Ordering.from(byAssignedSplitsCount).min(assignment.getNodes());
        nodeSplits.add(chosen,1);
        RemoteTask task=tasks.get(chosen);
        if (task == null) {
          scheduleTask(nextTaskId,chosen,assignment.getSplit());
        }
 else {
          task.addSplit(assignment.getSplit());
        }
      }
      for (      RemoteTask task : tasks.values()) {
        task.noMoreSplits();
      }
    }
    transitionToState(StageState.SCHEDULED);
    notifyParentSubStageFinishedScheduling();
    for (    SafeStageExecution subStage : subStages.values()) {
      subStage.noMoreOutputBuffers();
    }
    addNewExchangesAndBuffers();
  }
 catch (  Throwable e) {
    if (!getState().isDone()) {
      transitionToState(StageState.FAILED);
      log.error(e,"Error while starting stage %s",stageId);
      throw e;
    }
  }
}
