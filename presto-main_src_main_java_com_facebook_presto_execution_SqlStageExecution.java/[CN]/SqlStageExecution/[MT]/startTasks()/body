{
  try {
    Preconditions.checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
      if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
        return;
      }
    }
    AtomicInteger nextTaskId=new AtomicInteger(0);
    if (!dataSource.isPresent()) {
      scheduleTask(nextTaskId,nodeSelector.selectRandomNode(),null);
    }
 else {
      long getSplitStart=System.nanoTime();
      for (      Split split : dataSource.get().getSplits()) {
        stageStats.addGetSplitDuration(Duration.nanosSince(getSplitStart));
        long scheduleSplitStart=System.nanoTime();
        Node chosen=chooseNode(nodeSelector,split);
        if (getState().isDone()) {
          break;
        }
        RemoteTask task=tasks.get(chosen);
        if (task == null) {
          scheduleTask(nextTaskId,chosen,split);
          stageStats.addScheduleTaskDuration(Duration.nanosSince(scheduleSplitStart));
        }
 else {
          task.addSplit(split);
          stageStats.addAddSplitDuration(Duration.nanosSince(scheduleSplitStart));
        }
        getSplitStart=System.nanoTime();
      }
      for (      RemoteTask task : tasks.values()) {
        task.noMoreSplits();
      }
    }
    transitionToState(StageState.SCHEDULED);
    notifyParentSubStageFinishedScheduling();
    for (    StageExecutionNode subStage : subStages.values()) {
      subStage.noMoreOutputBuffers();
    }
    addNewExchangesAndBuffers(true);
  }
 catch (  Throwable e) {
    if (!getState().isDone()) {
synchronized (this) {
        failureCauses.add(e);
        transitionToState(StageState.FAILED);
      }
      log.error(e,"Error while starting stage %s",stageId);
      cancelAll();
      throw e;
    }
    Throwables.propagateIfInstanceOf(e,Error.class);
    log.debug(e,"Error while starting stage in done query %s",stageId);
  }
}
