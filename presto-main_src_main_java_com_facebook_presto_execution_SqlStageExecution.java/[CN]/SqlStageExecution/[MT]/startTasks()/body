{
  try (SetThreadName ignored=new SetThreadName("Stage-%s",stageId)){
    try {
      checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
        if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
          return;
        }
      }
      if (fragment.getDistribution() == PlanDistribution.SINGLE) {
        scheduleFixedNodeCount(1);
      }
 else       if (fragment.getDistribution() == PlanDistribution.FIXED) {
        scheduleFixedNodeCount(initialHashPartitions);
      }
 else       if (fragment.getDistribution() == PlanDistribution.SOURCE) {
        scheduleSourcePartitionedNodes();
      }
 else       if (fragment.getDistribution() == PlanDistribution.COORDINATOR_ONLY) {
        scheduleOnCurrentNode();
      }
 else {
        throw new IllegalStateException("Unsupported partitioning: " + fragment.getDistribution());
      }
      schedulingComplete.set(DateTime.now());
      stageState.compareAndSet(StageState.SCHEDULING,StageState.SCHEDULED);
      updateNewExchangesAndBuffers(true);
    }
 catch (    Throwable e) {
      if (!getState().isDone()) {
synchronized (this) {
          failureCauses.add(e);
          stageState.set(StageState.FAILED);
        }
        log.error(e,"Error while starting stage %s",stageId);
        abort();
        if (e instanceof InterruptedException) {
          Thread.currentThread().interrupt();
        }
        throw Throwables.propagate(e);
      }
      Throwables.propagateIfInstanceOf(e,Error.class);
      log.debug(e,"Error while starting stage in done query %s",stageId);
    }
 finally {
      doUpdateState();
    }
  }
 }
