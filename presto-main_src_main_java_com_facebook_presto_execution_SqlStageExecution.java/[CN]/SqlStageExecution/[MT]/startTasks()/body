{
  try {
    Preconditions.checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
      if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
        return;
      }
    }
    AtomicInteger nextTaskId=new AtomicInteger(0);
    if (!splits.isPresent()) {
      ArrayList<Node> nodes=new ArrayList<>(nodeManager.getActiveNodes());
      Preconditions.checkState(!nodes.isEmpty(),"Cluster does not have any active nodes");
      Collections.shuffle(nodes,ThreadLocalRandom.current());
      Node randomNode=nodes.get(0);
      scheduleTask(nextTaskId,randomNode,null);
    }
 else {
      for (      SplitAssignments assignment : splits.get()) {
        Node chosen=chooseNode(assignment);
        if (getState().isDone()) {
          break;
        }
        RemoteTask task=tasks.get(chosen);
        if (task == null) {
          scheduleTask(nextTaskId,chosen,assignment.getSplit());
        }
 else {
          task.addSplit(assignment.getSplit());
        }
      }
      for (      RemoteTask task : tasks.values()) {
        task.noMoreSplits();
      }
    }
    transitionToState(StageState.SCHEDULED);
    notifyParentSubStageFinishedScheduling();
    for (    StageExecutionNode subStage : subStages.values()) {
      subStage.noMoreOutputBuffers();
    }
    addNewExchangesAndBuffers(true);
  }
 catch (  Throwable e) {
    if (!getState().isDone()) {
      transitionToState(StageState.FAILED);
      log.error(e,"Error while starting stage %s",stageId);
      throw e;
    }
    Throwables.propagateIfInstanceOf(e,Error.class);
    log.debug(e,"Error while starting stage in done query %s",stageId);
  }
}
