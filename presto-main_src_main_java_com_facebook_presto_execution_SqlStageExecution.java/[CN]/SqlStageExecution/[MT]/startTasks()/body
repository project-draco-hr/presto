{
  try (SetThreadName setThreadName=new SetThreadName("Stage-%s",stageId)){
    try {
      Preconditions.checkState(!Thread.holdsLock(this),"Can not start while holding a lock on this");
synchronized (this) {
        if (!stageState.compareAndSet(StageState.PLANNED,StageState.SCHEDULING)) {
          return;
        }
      }
      if (fragment.getPartitioning() == PlanFragment.Partitioning.NONE) {
        scheduleNotPartitioned();
      }
 else       if (fragment.getPartitioning() == PlanFragment.Partitioning.HASH) {
        scheduleHashPartitioned();
      }
 else       if (fragment.getPartitioning() == PlanFragment.Partitioning.SOURCE) {
        scheduleSourcePartitioned();
      }
 else {
        throw new IllegalStateException("Unsupported partitioning: " + fragment.getPartitioning());
      }
      stageState.set(StageState.SCHEDULED);
      for (      StageExecutionNode subStage : subStages.values()) {
        subStage.noMoreOutputBuffers();
      }
      updateNewExchangesAndBuffers(true);
    }
 catch (    Throwable e) {
      if (!getState().isDone()) {
synchronized (this) {
          failureCauses.add(e);
          stageState.set(StageState.FAILED);
        }
        log.error(e,"Error while starting stage %s",stageId);
        cancel(true);
        throw e;
      }
      Throwables.propagateIfInstanceOf(e,Error.class);
      log.debug(e,"Error while starting stage in done query %s",stageId);
    }
 finally {
      doUpdateState();
    }
  }
 }
