{
  while (true) {
    if (getState().isDone()) {
      return null;
    }
    Node chosen=nodeSelector.selectNode(split);
    RemoteTask task=tasks.get(chosen);
    if (task == null || task.getQueuedSplits() < maxPendingSplitsPerNode) {
      return chosen;
    }
    if (!subStages.isEmpty()) {
      nodeSelector.lockDownNodes();
      for (      Node node : Sets.difference(new HashSet<>(nodeSelector.allNodes()),tasks.keySet())) {
        scheduleTask(nextTaskId.getAndIncrement(),node);
      }
      setNoMoreStageNodes();
    }
synchronized (this) {
      try {
        TimeUnit.SECONDS.timedWait(this,1);
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw Throwables.propagate(e);
      }
    }
    updateNewExchangesAndBuffers(false);
  }
}
