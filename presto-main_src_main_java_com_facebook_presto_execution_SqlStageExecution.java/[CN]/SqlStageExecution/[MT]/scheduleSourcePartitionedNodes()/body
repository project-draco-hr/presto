{
  AtomicInteger nextTaskId=new AtomicInteger(0);
  try (SplitSource splitSource=this.dataSource.get()){
    while (!splitSource.isFinished()) {
      if (getState().isDone()) {
        break;
      }
      long start=System.nanoTime();
      Set<Split> pendingSplits=ImmutableSet.copyOf(getFutureValue(splitSource.getNextBatch(splitBatchSize)));
      getSplitDistribution.add(System.nanoTime() - start);
      while (!pendingSplits.isEmpty() && !getState().isDone()) {
        Multimap<Node,Split> splitAssignment=nodeSelector.computeAssignments(pendingSplits,tasks.values());
        pendingSplits=ImmutableSet.copyOf(Sets.difference(pendingSplits,ImmutableSet.copyOf(splitAssignment.values())));
        assignSplits(nextTaskId,splitAssignment);
        if (!pendingSplits.isEmpty()) {
          waitForFreeNode(nextTaskId);
        }
      }
    }
  }
   for (  RemoteTask task : tasks.values()) {
    task.noMoreSplits(fragment.getPartitionedSource());
  }
  completeSources.add(fragment.getPartitionedSource());
  setNoMoreStageNodes();
}
