{
  Preconditions.checkState(!Thread.holdsLock(this),"Can not update state while holding a lock on this");
  for (  RemoteTask task : tasks.values()) {
    try {
      task.updateState();
    }
 catch (    Exception e) {
      log.debug(e,"Error updating task info");
    }
  }
  for (  StageExecutionNode subStage : subStages.values()) {
    subStage.updateState();
  }
synchronized (this) {
    StageState currentState=stageState.get();
    if (currentState.isDone()) {
      return;
    }
    List<StageState> subStageStates=ImmutableList.copyOf(transform(transform(subStages.values(),stageInfoGetter()),stageStateGetter()));
    if (any(subStageStates,equalTo(StageState.FAILED))) {
      transitionToState(StageState.FAILED);
    }
 else {
      List<TaskState> taskStates=ImmutableList.copyOf(transform(transform(tasks.values(),taskInfoGetter()),taskStateGetter()));
      if (any(taskStates,equalTo(TaskState.FAILED))) {
        transitionToState(StageState.FAILED);
      }
 else       if (currentState != StageState.PLANNED && currentState != StageState.SCHEDULING) {
        if (all(taskStates,TaskState.inDoneState())) {
          transitionToState(StageState.FINISHED);
        }
 else         if (any(taskStates,equalTo(TaskState.RUNNING))) {
          transitionToState(StageState.RUNNING);
        }
 else         if (any(taskStates,equalTo(TaskState.QUEUED))) {
          transitionToState(StageState.SCHEDULED);
        }
      }
    }
  }
  if (stageState.get().isDone()) {
    cancelAll();
  }
}
