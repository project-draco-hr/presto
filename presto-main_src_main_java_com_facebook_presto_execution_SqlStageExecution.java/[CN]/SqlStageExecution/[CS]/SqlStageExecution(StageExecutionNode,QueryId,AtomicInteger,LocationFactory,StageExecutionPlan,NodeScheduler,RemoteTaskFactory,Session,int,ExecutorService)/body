{
  Preconditions.checkNotNull(queryId,"queryId is null");
  Preconditions.checkNotNull(nextStageId,"nextStageId is null");
  Preconditions.checkNotNull(locationFactory,"locationFactory is null");
  Preconditions.checkNotNull(plan,"plan is null");
  Preconditions.checkNotNull(nodeScheduler,"nodeScheduler is null");
  Preconditions.checkNotNull(remoteTaskFactory,"remoteTaskFactory is null");
  Preconditions.checkNotNull(session,"session is null");
  Preconditions.checkArgument(maxPendingSplitsPerNode > 0,"maxPendingSplitsPerNode must be greater than 0");
  Preconditions.checkNotNull(executor,"executor is null");
  this.stageId=new StageId(queryId,String.valueOf(nextStageId.getAndIncrement()));
  try (SetThreadName setThreadName=new SetThreadName("Stage-%s",stageId)){
    this.parent=parent;
    this.location=locationFactory.createStageLocation(stageId);
    this.fragment=plan.getFragment();
    this.outputReceivers=plan.getOutputReceivers();
    this.dataSource=plan.getDataSource();
    this.remoteTaskFactory=remoteTaskFactory;
    this.session=session;
    this.maxPendingSplitsPerNode=maxPendingSplitsPerNode;
    this.executor=executor;
    tupleInfos=fragment.getTupleInfos();
    ImmutableMap.Builder<PlanFragmentId,StageExecutionNode> subStages=ImmutableMap.builder();
    for (    StageExecutionPlan subStagePlan : plan.getSubStages()) {
      PlanFragmentId subStageFragmentId=subStagePlan.getFragment().getId();
      StageExecutionNode subStage=new SqlStageExecution(this,queryId,nextStageId,locationFactory,subStagePlan,nodeScheduler,remoteTaskFactory,session,maxPendingSplitsPerNode,executor);
      subStage.addStateChangeListener(new StateChangeListener<StageInfo>(){
        @Override public void stateChanged(        StageInfo stageInfo){
          doUpdateState();
        }
      }
);
      subStages.put(subStageFragmentId,subStage);
    }
    this.subStages=subStages.build();
    String dataSourceName=dataSource.isPresent() ? dataSource.get().getDataSourceName() : null;
    this.nodeSelector=nodeScheduler.createNodeSelector(dataSourceName,Ordering.natural().onResultOf(new Function<Node,Integer>(){
      @Override public Integer apply(      Node input){
        RemoteTask task=tasks.get(input);
        return task == null ? 0 : task.getQueuedSplits();
      }
    }
));
    stageState=new StateMachine<>("stage " + stageId,this.executor,StageState.PLANNED);
    stageState.addStateChangeListener(new StateChangeListener<StageState>(){
      @Override public void stateChanged(      StageState newValue){
        log.debug("Stage %s is %s",stageId,newValue);
      }
    }
);
  }
 }
