{
  Statement statement;
  try {
    statement=SqlParser.createStatement(sql);
  }
 catch (  RecognitionException e) {
    throw Throwables.propagate(e);
  }
  SessionMetadata sessionMetadata=new SessionMetadata(metadata);
  sessionMetadata.using(TpchSchema.CATALOG_NAME,TpchSchema.SCHEMA_NAME);
  Analyzer analyzer=new Analyzer(sessionMetadata);
  AnalysisResult analysis=analyzer.analyze(statement);
  Planner planner=new Planner();
  PlanNode plan=planner.plan((Query)statement,analysis);
  new PlanPrinter().print(plan,analysis.getTypes());
  FragmentPlanner fragmentPlanner=new FragmentPlanner(sessionMetadata);
  List<PlanFragment> fragments=fragmentPlanner.createFragments(plan,analysis.getSymbolAllocator(),true);
  TableScan tableScan=(TableScan)Iterables.getOnlyElement(fragments).getSources().get(0);
  TpchTableHandle table=(TpchTableHandle)tableScan.getTable();
  Split split=new TpchSplit(table);
  ExecutionPlanner executionPlanner=new ExecutionPlanner(new SessionMetadata(metadata),dataProvider,analysis.getTypes(),ImmutableMap.<Integer,Operator>of(),split);
  Operator operator=executionPlanner.plan(plan);
  TupleInfo outputTupleInfo=ExecutionPlanner.toTupleInfo(analysis,plan.getOutputSymbols());
  ImmutableList.Builder<Tuple> output=ImmutableList.builder();
  for (  Page page : operator) {
    ImmutableList.Builder<BlockCursor> cursorBuilder=ImmutableList.builder();
    for (    Block block : page.getBlocks()) {
      cursorBuilder.add(block.cursor());
    }
    List<BlockCursor> cursors=cursorBuilder.build();
    boolean done=false;
    while (!done) {
      TupleInfo.Builder outputBuilder=outputTupleInfo.builder();
      done=true;
      for (      BlockCursor cursor : cursors) {
        if (!cursor.advanceNextPosition()) {
          break;
        }
        done=false;
        outputBuilder.append(cursor.getTuple());
      }
      if (!done) {
        output.add(outputBuilder.build());
      }
    }
  }
  return output.build();
}
