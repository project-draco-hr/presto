{
  List<ParametricFunction> candidates=IterableTransformer.on(functions.get(name)).select(new Predicate<ParametricFunction>(){
    @Override public boolean apply(    ParametricFunction input){
      return input.isScalar() || input.isApproximate() == approximate;
    }
  }
).list();
  List<Type> resolvedTypes=resolveTypes(parameterTypes,typeManager);
  FunctionInfo match=null;
  for (  ParametricFunction function : candidates) {
    if (function.getSignature().match(resolvedTypes,false,typeManager)) {
      checkArgument(match == null,"Ambiguous call to %s with parameters %s",name,parameterTypes);
      match=function.specialize(resolvedTypes);
    }
  }
  if (match != null) {
    return match;
  }
  for (  ParametricFunction function : candidates) {
    if (function.getSignature().match(resolvedTypes,true,typeManager)) {
      return function.specialize(resolvedTypes);
    }
  }
  List<String> expectedParameters=new ArrayList<>();
  for (  ParametricFunction function : candidates) {
    expectedParameters.add(format("%s(%s)",name,Joiner.on(", ").join(function.getSignature().getArgumentTypes())));
  }
  String parameters=Joiner.on(", ").join(parameterTypes);
  String message=format("Function %s not registered",name);
  if (!expectedParameters.isEmpty()) {
    String expected=Joiner.on(", ").join(expectedParameters);
    message=format("Unexpected parameters (%s) for function %s. Expected: %s",parameters,name,expected);
  }
  if (name.getSuffix().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) {
    String typeName=name.getSuffix().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length());
    Type type=typeManager.getType(typeName);
    checkNotNull(type,"Type %s not registered",typeName);
    checkArgument(parameterTypes.size() == 1,"Expected one argument to literal function, but got %s",parameterTypes);
    Type parameterType=typeManager.getType(parameterTypes.get(0));
    checkNotNull(parameterType,"Type %s not foudn",parameterTypes.get(0));
    checkArgument(parameterType.getJavaType() == type.getJavaType(),"Expected type %s to use Java type %s, but Java type is %s",type,parameterType.getJavaType(),type.getJavaType());
    MethodHandle identity=MethodHandles.identity(parameterType.getJavaType());
    return new FunctionInfo(getMagicLiteralFunctionSignature(type),null,true,identity,true,false,ImmutableList.of(false));
  }
  throw new PrestoException(StandardErrorCode.FUNCTION_NOT_FOUND.toErrorCode(),message);
}
