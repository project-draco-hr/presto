{
  checkArgument(signature.getKind() == AGGREGATE || signature.getKind() == APPROXIMATE_AGGREGATE,"%s is not an aggregate function",signature);
  checkArgument(signature.getTypeVariableConstraints().isEmpty(),"%s has unbound type parameters",signature);
  Iterable<SqlFunction> candidates=functions.get(QualifiedName.of(signature.getName()));
  for (  SqlFunction operator : candidates) {
    Type returnType=typeManager.getType(signature.getReturnType());
    List<Type> argumentTypes=resolveTypes(signature.getArgumentTypes(),typeManager);
    Map<String,Type> boundTypeParameters=operator.getSignature().bindTypeVariables(returnType,argumentTypes,false,typeManager);
    if (boundTypeParameters != null) {
      try {
        Map<String,OptionalLong> boundLiteralParameters=operator.getSignature().bindLongVariables(signature.getArgumentTypes());
        BoundVariables boundVariables=new BoundVariables(boundTypeParameters,boundLiteralParameters);
        return specializedAggregationCache.getUnchecked(new SpecializedFunctionKey(operator,boundVariables,signature.getArgumentTypes().size()));
      }
 catch (      UncheckedExecutionException e) {
        throw Throwables.propagate(e.getCause());
      }
    }
  }
  throw new PrestoException(FUNCTION_IMPLEMENTATION_MISSING,format("%s not found",signature));
}
