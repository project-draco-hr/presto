{
  checkArgument(signature.getKind() == SCALAR,"%s is not a scalar function",signature);
  checkArgument(signature.getTypeVariableConstraints().isEmpty(),"%s has unbound type parameters",signature);
  Iterable<SqlFunction> candidates=functions.get(QualifiedName.of(signature.getName()));
  Type returnType=typeManager.getType(signature.getReturnType());
  List<Type> argumentTypes=resolveTypes(signature.getArgumentTypes(),typeManager);
  for (  SqlFunction operator : candidates) {
    Optional<BoundVariables> boundVariables=new SignatureBinder(typeManager,operator.getSignature(),false).bindVariables(argumentTypes,returnType);
    if (boundVariables.isPresent()) {
      try {
        return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(operator,boundVariables.get(),argumentTypes.size()));
      }
 catch (      UncheckedExecutionException e) {
        throw Throwables.propagate(e.getCause());
      }
    }
  }
  if (signature.getName().startsWith(MAGIC_LITERAL_FUNCTION_PREFIX)) {
    List<TypeSignature> parameterTypes=signature.getArgumentTypes();
    String typeName=signature.getName().substring(MAGIC_LITERAL_FUNCTION_PREFIX.length());
    Type type=typeManager.getType(parseTypeSignature(typeName));
    requireNonNull(type,format("Type %s not registered",typeName));
    checkArgument(parameterTypes.size() == 1,"Expected one argument to literal function, but got %s",parameterTypes);
    Type parameterType=typeManager.getType(parameterTypes.get(0));
    requireNonNull(parameterType,format("Type %s not found",parameterTypes.get(0)));
    MethodHandle methodHandle=null;
    if (parameterType.getJavaType() == type.getJavaType()) {
      methodHandle=MethodHandles.identity(parameterType.getJavaType());
    }
    if (parameterType.getJavaType() == Slice.class) {
      if (type.getJavaType() == Block.class) {
        methodHandle=BlockSerdeUtil.READ_BLOCK.bindTo(blockEncodingSerde);
      }
    }
    checkArgument(methodHandle != null,"Expected type %s to use (or can be converted into) Java type %s, but Java type is %s",type,parameterType.getJavaType(),type.getJavaType());
    return new ScalarFunctionImplementation(false,ImmutableList.of(false),methodHandle,true);
  }
  if (!signature.getArgumentTypes().isEmpty() && signature.getArgumentTypes().get(0).getBase().equals(StandardTypes.ROW)) {
    SqlFunction fieldReference=getRowFieldReference(signature.getName(),signature.getArgumentTypes().get(0));
    if (fieldReference != null) {
      Optional<BoundVariables> boundVariables=new SignatureBinder(typeManager,fieldReference.getSignature(),false).bindVariables(argumentTypes,returnType);
      checkState(boundVariables.isPresent());
      return specializedScalarCache.getUnchecked(new SpecializedFunctionKey(fieldReference,boundVariables.get(),argumentTypes.size()));
    }
  }
  throw new PrestoException(FUNCTION_IMPLEMENTATION_MISSING,format("%s not found",signature));
}
