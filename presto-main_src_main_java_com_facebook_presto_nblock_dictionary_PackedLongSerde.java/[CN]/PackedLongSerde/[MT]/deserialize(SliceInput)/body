{
  checkArgument(sliceInput.available() >= Footer.BYTE_SIZE,"sliceInput not large enough to read a footer");
  checkArgument((sliceInput.available() - Footer.BYTE_SIZE) % (SizeOf.SIZE_OF_LONG) == 0,"sliceInput byte alignment incorrect");
  int totalBytes=sliceInput.available();
  sliceInput.skipBytes(totalBytes - Footer.BYTE_SIZE);
  final Footer footer=Footer.deserialize(sliceInput.readSlice(Footer.BYTE_SIZE).getInput());
  sliceInput.setPosition(0);
  final int packCapacity=Long.SIZE / footer.getBitWidth();
  return new Iterable<Long>(){
    @Override public Iterator<Long> iterator(){
      return new AbstractIterator<Long>(){
        private int itemIndex=0;
        private int packInternalIndex=0;
        private long packValue=0;
        @Override protected Long computeNext(){
          if (itemIndex >= footer.getItemCount()) {
            return endOfData();
          }
          if (packInternalIndex == 0) {
            packValue=sliceInput.readLong();
          }
          long value=(packValue << (Long.SIZE - ((packInternalIndex + 1) * footer.getBitWidth()))) >> (Long.SIZE - footer.getBitWidth());
          itemIndex++;
          packInternalIndex=(packInternalIndex + 1) % packCapacity;
          return value;
        }
      }
;
    }
  }
;
}
