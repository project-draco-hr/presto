{
  if (value == null) {
    return null;
  }
  TypeSignature signature=parseTypeSignature(type);
  if (signature.getBase().equals("array")) {
    List<Object> fixedValue=new ArrayList<>();
    for (    Object object : List.class.cast(value)) {
      fixedValue.add(fixValue(signature.getParameters().get(0).toString(),object));
    }
    return fixedValue;
  }
  if (signature.getBase().equals("map")) {
    String keyType=signature.getParameters().get(0).toString();
    String valueType=signature.getParameters().get(1).toString();
    Map<Object,Object> fixedValue=new HashMap<>();
    for (    Map.Entry<?,?> entry : (Set<Map.Entry<?,?>>)Map.class.cast(value).entrySet()) {
      fixedValue.put(fixValue(keyType,entry.getKey()),fixValue(valueType,entry.getValue()));
    }
    return fixedValue;
  }
  if (signature.getBase().equals(StandardTypes.ROW)) {
    Map<String,Object> fixedValue=new LinkedHashMap<>();
    List<Object> listValue=List.class.cast(value);
    checkArgument(listValue.size() == signature.getLiteralParameters().size(),"Mismatched data values and row type");
    for (int i=0; i < listValue.size(); i++) {
      String key=(String)signature.getLiteralParameters().get(i);
      fixedValue.put(key,fixValue(signature.getParameters().get(i).toString(),listValue.get(i)));
    }
    return fixedValue;
  }
switch (type) {
case "bigint":
    if (value instanceof String) {
      return Long.parseLong((String)value);
    }
  return ((Number)value).longValue();
case "double":
if (value instanceof String) {
  return Double.parseDouble((String)value);
}
return ((Number)value).doubleValue();
case "boolean":
if (value instanceof String) {
return Boolean.parseBoolean((String)value);
}
return Boolean.class.cast(value);
case "varchar":
case "json":
case "time":
case "time with time zone":
case "timestamp":
case "timestamp with time zone":
case "date":
case "interval year to month":
case "interval day to second":
return String.class.cast(value);
default :
if (value instanceof String) {
return BaseEncoding.base64().decode((String)value);
}
return value;
}
}
