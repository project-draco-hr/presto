{
  TypedByteCodeNode value=process(node.getExpression(),context);
  Block block=new Block(context);
  block.append(value.node);
  if (value.type == void.class) {
switch (node.getType()) {
case "BOOLEAN":
      block.loadJavaDefault(boolean.class);
    return typedByteCodeNode(block,boolean.class);
case "BIGINT":
  block.loadJavaDefault(long.class);
return typedByteCodeNode(block,long.class);
case "DOUBLE":
block.loadJavaDefault(double.class);
return typedByteCodeNode(block,double.class);
case "VARCHAR":
block.loadJavaDefault(Slice.class);
return typedByteCodeNode(block,Slice.class);
}
}
 else {
LabelNode end=new LabelNode("end");
switch (node.getType()) {
case "BOOLEAN":
block.append(ifWasNullPopAndGoto(context,end,boolean.class,value.type));
block.invokeStatic(Operations.class,"castToBoolean",boolean.class,value.type);
return typedByteCodeNode(block.visitLabel(end),boolean.class);
case "BIGINT":
block.append(ifWasNullPopAndGoto(context,end,long.class,value.type));
block.invokeStatic(Operations.class,"castToLong",long.class,value.type);
return typedByteCodeNode(block.visitLabel(end),long.class);
case "DOUBLE":
block.append(ifWasNullPopAndGoto(context,end,double.class,value.type));
block.invokeStatic(Operations.class,"castToDouble",double.class,value.type);
return typedByteCodeNode(block.visitLabel(end),double.class);
case "VARCHAR":
block.append(ifWasNullPopAndGoto(context,end,Slice.class,value.type));
block.invokeStatic(Operations.class,"castToSlice",Slice.class,value.type);
return typedByteCodeNode(block.visitLabel(end),Slice.class);
}
}
throw new UnsupportedOperationException("Unsupported type: " + node.getType());
}
