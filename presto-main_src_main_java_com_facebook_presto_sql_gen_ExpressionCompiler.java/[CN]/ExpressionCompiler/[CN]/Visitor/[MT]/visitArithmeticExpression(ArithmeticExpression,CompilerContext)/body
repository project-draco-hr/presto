{
  TypedByteCodeNode left=process(node.getLeft(),context);
  if (left.type == void.class) {
    return left;
  }
  TypedByteCodeNode right=process(node.getRight(),context);
  if (right.type == void.class) {
    return right;
  }
  Class<?> type=getType(left,right);
  if (!isNumber(type)) {
    throw new UnsupportedOperationException(format("not yet implemented: %s(%s, %s)",node.getType(),left.type,right.type));
  }
  Block block=new Block(context).comment(node.toString());
  LabelNode end=new LabelNode("end");
  block.append(coerceToType(context,left,type).node);
  block.append(ifWasNullPopAndGoto(context,end,type,left.type));
  block.append(coerceToType(context,right,type).node);
  block.append(ifWasNullPopAndGoto(context,end,type,type,right.type));
switch (node.getType()) {
case ADD:
    block.invokeStatic(Operations.class,"add",type,type,type);
  break;
case SUBTRACT:
block.invokeStatic(Operations.class,"subtract",type,type,type);
break;
case MULTIPLY:
block.invokeStatic(Operations.class,"multiply",type,type,type);
break;
case DIVIDE:
block.invokeStatic(Operations.class,"divide",type,type,type);
break;
case MODULUS:
block.invokeStatic(Operations.class,"modulus",type,type,type);
break;
default :
throw new UnsupportedOperationException(format("not yet implemented: %s(%s, %s)",node.getType(),left.type,right.type));
}
return typedByteCodeNode(block.visitLabel(end),type);
}
