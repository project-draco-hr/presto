{
  ClassDefinition classDefinition=new ClassDefinition(new CompilerContext(bootstrapMethod),a(PUBLIC,FINAL),typeFromPathName("FilterAndProjectOperator_" + CLASS_ID.incrementAndGet()),type(AbstractFilterAndProjectOperator.class));
  FieldDefinition sessionField=classDefinition.declareField(a(PRIVATE,FINAL),"session",Session.class);
  classDefinition.declareConstructor(new CompilerContext(bootstrapMethod),a(PUBLIC),arg("operatorContext",OperatorContext.class),arg("types",type(Iterable.class,Type.class))).getBody().comment("super(operatorContext, types);").pushThis().getVariable("operatorContext").getVariable("types").invokeConstructor(AbstractFilterAndProjectOperator.class,OperatorContext.class,Iterable.class).comment("this.session = operatorContext.getSession();").pushThis().getVariable("operatorContext").invokeVirtual(OperatorContext.class,"getSession",Session.class).putField(sessionField).ret();
  generateFilterAndProjectRowOriented(classDefinition,projections,expressionTypes);
  generateFilterMethod(classDefinition,filter,expressionTypes,true,timeZoneKey);
  generateFilterMethod(classDefinition,filter,expressionTypes,false,timeZoneKey);
  List<Type> types=new ArrayList<>();
  int projectionIndex=0;
  for (  Expression projection : projections) {
    generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,expressionTypes,true,timeZoneKey);
    generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,expressionTypes,false,timeZoneKey);
    types.add(expressionTypes.get(projection));
    projectionIndex++;
  }
  classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"toString",type(String.class)).getBody().push(toStringHelper(classDefinition.getType().getJavaClassName()).add("filter",filter).add("projections",projections).toString()).retObject();
  Class<? extends Operator> filterAndProjectClass=defineClass(classDefinition,Operator.class,classLoader);
  return new TypedOperatorClass(filterAndProjectClass,types);
}
