{
  ClassInfoLoader classInfoLoader=ClassInfoLoader.createClassInfoLoader(classDefinitions,classLoader);
  if (DUMP_BYTE_CODE_TREE) {
    DumpByteCodeVisitor dumpByteCode=new DumpByteCodeVisitor(System.out);
    for (    ClassDefinition classDefinition : classDefinitions) {
      dumpByteCode.visitClass(classDefinition);
    }
  }
  Map<String,byte[]> byteCodes=new LinkedHashMap<>();
  for (  ClassDefinition classDefinition : classDefinitions) {
    ClassWriter cw=new SmartClassWriter(classInfoLoader);
    classDefinition.visit(cw);
    byte[] byteCode=cw.toByteArray();
    if (RUN_ASM_VERIFIER) {
      ClassReader reader=new ClassReader(byteCode);
      CheckClassAdapter.verify(reader,classLoader,true,new PrintWriter(System.out));
    }
    byteCodes.put(classDefinition.getType().getJavaClassName(),byteCode);
  }
  String dumpClassPath=DUMP_CLASS_FILES_TO.get();
  if (dumpClassPath != null) {
    for (    Entry<String,byte[]> entry : byteCodes.entrySet()) {
      File file=new File(dumpClassPath,ParameterizedType.typeFromJavaClassName(entry.getKey()).getClassName() + ".class");
      try {
        log.debug("ClassFile: " + file.getAbsolutePath());
        Files.createParentDirs(file);
        Files.write(entry.getValue(),file);
      }
 catch (      IOException e) {
        log.error(e,"Failed to write generated class file to: %s" + file.getAbsolutePath());
      }
    }
  }
  if (DUMP_BYTE_CODE_RAW) {
    for (    byte[] byteCode : byteCodes.values()) {
      ClassReader classReader=new ClassReader(byteCode);
      classReader.accept(new TraceClassVisitor(new PrintWriter(System.err)),ClassReader.SKIP_FRAMES);
    }
  }
  Map<String,Class<?>> classes=classLoader.defineClasses(byteCodes);
  generatedClasses.addAndGet(classes.size());
  return classes;
}
