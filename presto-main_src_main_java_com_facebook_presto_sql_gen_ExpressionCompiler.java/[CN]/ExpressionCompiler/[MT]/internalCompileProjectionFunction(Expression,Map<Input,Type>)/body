{
  ClassDefinition classDefinition=new ClassDefinition(new CompilerContext(bootstrapMethod),a(PUBLIC,FINAL),typeFromPathName("ProjectionFunction_" + CLASS_ID.incrementAndGet()),type(Object.class),type(ProjectionFunction.class));
  FieldDefinition sessionField=classDefinition.declareField(a(PRIVATE,FINAL),"session",Session.class);
  classDefinition.declareConstructor(new CompilerContext(bootstrapMethod),a(PUBLIC),arg("session",Session.class)).getBody().pushThis().invokeConstructor(Object.class).comment("this.session = session;").pushThis().getVariable("session").putField(sessionField).ret();
  MethodDefinition projectionMethod=classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"project",type(void.class),arg("channels",TupleReadable[].class),arg("output",BlockBuilder.class));
  projectionMethod.getBody().pushThis();
  int channels=Ordering.natural().max(transform(inputTypes.keySet(),Input.channelGetter())) + 1;
  for (int i=0; i < channels; i++) {
    projectionMethod.getBody().getVariable("channels").push(i).getObjectArrayElement();
  }
  projectionMethod.getBody().getVariable("output");
  projectionMethod.getBody().invokeVirtual(classDefinition.getType(),"project",type(void.class),ImmutableList.<ParameterizedType>builder().addAll(nCopies(channels,type(TupleReadable.class))).add(type(BlockBuilder.class)).build());
  projectionMethod.getBody().ret();
  Class<?> type=generateProjectMethod(classDefinition,"project",expression,inputTypes,false);
  generateProjectMethod(classDefinition,"project",expression,inputTypes,true);
  MethodDefinition getTupleInfoMethod=classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"getTupleInfo",type(TupleInfo.class));
  if (type == boolean.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_BOOLEAN",type(TupleInfo.class)).retObject();
  }
 else   if (type == long.class || type == void.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_LONG",type(TupleInfo.class)).retObject();
  }
 else   if (type == double.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_DOUBLE",type(TupleInfo.class)).retObject();
  }
 else   if (type == Slice.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_VARBINARY",type(TupleInfo.class)).retObject();
  }
 else {
    throw new IllegalStateException("Type " + type.getName() + "can be output");
  }
  classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"toString",type(String.class)).getBody().push(toStringHelper(classDefinition.getType().getJavaClassName()).add("projection",expression).toString()).retObject();
  Class<? extends ProjectionFunction> projectionClass=defineClasses(ImmutableList.of(classDefinition),createClassLoader()).values().iterator().next().asSubclass(ProjectionFunction.class);
  try {
    final Constructor<? extends ProjectionFunction> constructor=projectionClass.getConstructor(Session.class);
    return new Function<Session,ProjectionFunction>(){
      @Override public ProjectionFunction apply(      Session session){
        try {
          ProjectionFunction function=constructor.newInstance(session);
          return function;
        }
 catch (        Throwable e) {
          throw Throwables.propagate(e);
        }
      }
    }
;
  }
 catch (  Throwable e) {
    throw Throwables.propagate(e);
  }
}
