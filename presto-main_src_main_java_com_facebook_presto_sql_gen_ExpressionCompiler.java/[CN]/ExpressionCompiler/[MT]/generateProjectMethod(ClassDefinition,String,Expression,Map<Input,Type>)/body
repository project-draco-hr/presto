{
  ImmutableList.Builder<NamedParameterDefinition> parameters=ImmutableList.builder();
  parameters.addAll(toTupleReaderParameters(inputTypes));
  parameters.add(arg("output",BlockBuilder.class));
  MethodDefinition projectionMethod=classDefinition.declareMethod(new CompilerContext(),a(PUBLIC),methodName,type(void.class),parameters.build());
  CompilerContext context=projectionMethod.getCompilerContext();
  context.declareVariable(type(boolean.class),"wasNull");
  TypedByteCodeNode body=new Visitor(metadata,inputTypes).process(projection,context);
  if (body.type != void.class) {
    projectionMethod.getBody().loadConstant(false).storeVariable("wasNull").loadVariable("output").append(body.node);
    Block notNullBlock=new Block(context);
    if (body.type == long.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,long.class);
    }
 else     if (body.type == double.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,double.class);
    }
 else     if (body.type == Slice.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,Slice.class);
    }
 else {
      throw new UnsupportedOperationException("Type " + body.type + " can not be output yet");
    }
    Block nullBlock=new Block(context).pop(body.type).invokeVirtual(BlockBuilder.class,"appendNull",BlockBuilder.class);
    projectionMethod.getBody().append(new IfStatement(context,new Block(context).loadVariable("wasNull"),nullBlock,notNullBlock)).ret();
  }
 else {
    projectionMethod.getBody().loadVariable("output").invokeVirtual(BlockBuilder.class,"appendNull",BlockBuilder.class).ret();
  }
  return body.type;
}
