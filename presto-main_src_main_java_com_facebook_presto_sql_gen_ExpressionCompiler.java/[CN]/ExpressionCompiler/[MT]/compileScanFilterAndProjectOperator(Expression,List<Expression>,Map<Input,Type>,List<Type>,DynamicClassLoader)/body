{
  ClassDefinition classDefinition=new ClassDefinition(new CompilerContext(bootstrapMethod),a(PUBLIC,FINAL),typeFromPathName("ScanFilterAndProjectOperator_" + CLASS_ID.incrementAndGet()),type(AbstractScanFilterAndProjectOperator.class));
  FieldDefinition sessionField=classDefinition.declareField(a(PRIVATE,FINAL),"session",Session.class);
  classDefinition.declareConstructor(new CompilerContext(bootstrapMethod),a(PUBLIC),arg("operatorContext",OperatorContext.class),arg("sourceId",PlanNodeId.class),arg("dataStreamProvider",DataStreamProvider.class),arg("columns",type(Iterable.class,ColumnHandle.class)),arg("tupleInfos",type(Iterable.class,TupleInfo.class))).getBody().comment("super(operatorContext, sourceId, dataStreamProvider, columns, tupleInfos);").pushThis().getVariable("operatorContext").getVariable("sourceId").getVariable("dataStreamProvider").getVariable("columns").getVariable("tupleInfos").invokeConstructor(AbstractScanFilterAndProjectOperator.class,OperatorContext.class,PlanNodeId.class,DataStreamProvider.class,Iterable.class,Iterable.class).comment("this.session = operatorContext.getSession();").pushThis().getVariable("operatorContext").invokeVirtual(OperatorContext.class,"getSession",Session.class).putField(sessionField).ret();
  generateFilterAndProjectRowOriented(classDefinition,projections,inputTypes);
  generateFilterAndProjectCursorMethod(classDefinition,projections);
  generateFilterMethod(classDefinition,filter,inputTypes,true);
  generateFilterMethod(classDefinition,filter,inputTypes,false);
  List<TupleInfo> tupleInfos=new ArrayList<>();
  int projectionIndex=0;
  for (int i=0; i < projections.size(); i++) {
    Type outputType=outputTypes.get(i);
    checkArgument(outputType != Type.NULL,"NULL output type is not supported");
    tupleInfos.add(new TupleInfo(outputType.getRawType()));
    Expression projection=projections.get(i);
    Class<?> type=generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,inputTypes,true);
    generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,inputTypes,false);
    if (type == boolean.class) {
      checkState(outputType == Type.BOOLEAN);
    }
 else     if (type == long.class) {
      checkState(outputType == Type.BIGINT);
    }
 else     if (type == double.class) {
      checkState(outputType == Type.DOUBLE);
    }
 else     if (type == Slice.class) {
      checkState(outputType == Type.VARCHAR);
    }
 else     if (type == void.class) {
    }
 else {
      throw new IllegalStateException("Type " + type.getName() + "can be output");
    }
    projectionIndex++;
  }
  classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"toString",type(String.class)).getBody().push(toStringHelper(classDefinition.getType().getJavaClassName()).add("filter",filter).add("projections",projections).toString()).retObject();
  Class<? extends SourceOperator> filterAndProjectClass=defineClass(classDefinition,SourceOperator.class,classLoader);
  return new TypedOperatorClass(filterAndProjectClass,tupleInfos);
}
