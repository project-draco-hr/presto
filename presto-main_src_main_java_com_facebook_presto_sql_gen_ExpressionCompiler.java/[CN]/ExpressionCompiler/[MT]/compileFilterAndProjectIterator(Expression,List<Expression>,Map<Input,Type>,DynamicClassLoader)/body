{
  ClassDefinition classDefinition=new ClassDefinition(new CompilerContext(bootstrapMethod),a(PUBLIC,FINAL),typeFromPathName("FilterAndProjectIterator_" + CLASS_ID.incrementAndGet()),type(AbstractFilterAndProjectIterator.class));
  FieldDefinition sessionField=classDefinition.declareField(a(PRIVATE,FINAL),"session",Session.class);
  FieldDefinition operatorStatsField=classDefinition.declareField(a(PRIVATE,FINAL),"operatorStats",OperatorStats.class);
  FieldDefinition currentCompletedSizeField=classDefinition.declareField(a(PRIVATE),"currentCompletedSize",long.class);
  classDefinition.declareConstructor(new CompilerContext(bootstrapMethod),a(PUBLIC),arg("tupleInfos",type(Iterable.class,TupleInfo.class)),arg("pageIterator",PageIterator.class),arg("session",Session.class),arg("operatorStats",OperatorStats.class)).getBody().comment("super(tupleInfos, pageIterator);").pushThis().getVariable("tupleInfos").getVariable("pageIterator").getVariable("operatorStats").invokeConstructor(AbstractFilterAndProjectIterator.class,Iterable.class,PageIterator.class,OperatorStats.class).comment("this.session = session;").pushThis().getVariable("session").putField(sessionField).comment("this.operatorStats = operatorStats;").pushThis().getVariable("operatorStats").putField(operatorStatsField).ret();
  generateFilterAndProjectCursorMethod(classDefinition,projections,operatorStatsField,currentCompletedSizeField);
  generateFilterAndProjectIteratorMethod(classDefinition,projections,inputTypes);
  generateFilterMethod(classDefinition,filter,inputTypes,true);
  generateFilterMethod(classDefinition,filter,inputTypes,false);
  List<TupleInfo> tupleInfos=new ArrayList<>();
  int projectionIndex=0;
  for (  Expression projection : projections) {
    Class<?> type=generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,inputTypes,true);
    generateProjectMethod(classDefinition,"project_" + projectionIndex,projection,inputTypes,false);
    if (type == boolean.class) {
      tupleInfos.add(TupleInfo.SINGLE_BOOLEAN);
    }
 else     if (type == long.class || type == void.class) {
      tupleInfos.add(TupleInfo.SINGLE_LONG);
    }
 else     if (type == double.class) {
      tupleInfos.add(TupleInfo.SINGLE_DOUBLE);
    }
 else     if (type == Slice.class) {
      tupleInfos.add(TupleInfo.SINGLE_VARBINARY);
    }
 else {
      throw new IllegalStateException("Type " + type.getName() + "can be output");
    }
    projectionIndex++;
  }
  classDefinition.declareMethod(new CompilerContext(bootstrapMethod),a(PUBLIC),"toString",type(String.class)).getBody().push(toStringHelper(classDefinition.getType().getJavaClassName()).add("filter",filter).add("projections",projections).toString()).retObject();
  Class<? extends PageIterator> filterAndProjectClass=defineClasses(ImmutableList.of(classDefinition),classLoader).values().iterator().next().asSubclass(PageIterator.class);
  return new TypedPageIteratorClass(filterAndProjectClass,tupleInfos);
}
