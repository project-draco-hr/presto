{
  expression=TreeRewriter.rewriteWith(new SymbolToInputRewriter(layout),expression);
  ClassDefinition classDefinition=new ClassDefinition(new CompilerContext(),a(PUBLIC,FINAL),typeFromPathName("ProjectionFunction_" + CLASS_ID.incrementAndGet()),type(Object.class),type(ProjectionFunction.class));
  classDefinition.declareConstructor(new CompilerContext(),a(PUBLIC)).getBody().loadThis().invokeConstructor(Object.class).ret();
  MethodDefinition projectionMethod=classDefinition.declareMethod(new CompilerContext(),a(PUBLIC),"project",type(void.class),NamedParameterDefinition.arg("channels",TupleReadable[].class),NamedParameterDefinition.arg("output",BlockBuilder.class));
  CompilerContext context=projectionMethod.getCompilerContext();
  context.declareVariable(type(boolean.class),"wasNull");
  TypedByteCodeNode body=new Visitor(metadata,inputTypes).process(expression,context);
  if (body.type != void.class) {
    projectionMethod.getBody().loadConstant(false).storeVariable("wasNull").loadVariable("output").append(body.node);
    Block notNullBlock=new Block(context);
    if (body.type == long.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,long.class);
    }
 else     if (body.type == double.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,double.class);
    }
 else     if (body.type == String.class) {
      notNullBlock.invokeVirtual(BlockBuilder.class,"append",BlockBuilder.class,String.class);
    }
 else {
      throw new UnsupportedOperationException("Type " + body.type + " can not be output yet");
    }
    Block nullBlock=new Block(context).pop(body.type).invokeVirtual(BlockBuilder.class,"appendNull",BlockBuilder.class);
    projectionMethod.getBody().append(new IfStatement(context,new Block(context).loadVariable("wasNull"),nullBlock,notNullBlock)).ret();
  }
 else {
    projectionMethod.getBody().loadVariable("output").invokeVirtual(BlockBuilder.class,"appendNull",BlockBuilder.class).ret();
  }
  MethodDefinition getTupleInfoMethod=classDefinition.declareMethod(new CompilerContext(),a(PUBLIC),"getTupleInfo",type(TupleInfo.class));
  if (body.type == long.class || body.type == void.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_LONG",type(TupleInfo.class)).retObject();
  }
 else   if (body.type == double.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_DOUBLE",type(TupleInfo.class)).retObject();
  }
 else   if (body.type == String.class) {
    getTupleInfoMethod.getBody().getStaticField(type(TupleInfo.class),"SINGLE_VARBINARY",type(TupleInfo.class)).retObject();
  }
  Class<? extends ProjectionFunction> projectionClass=defineClasses(ImmutableList.of(classDefinition)).values().iterator().next().asSubclass(ProjectionFunction.class);
  try {
    ProjectionFunction function=projectionClass.newInstance();
    return function;
  }
 catch (  Throwable e) {
    throw Throwables.propagate(e);
  }
}
