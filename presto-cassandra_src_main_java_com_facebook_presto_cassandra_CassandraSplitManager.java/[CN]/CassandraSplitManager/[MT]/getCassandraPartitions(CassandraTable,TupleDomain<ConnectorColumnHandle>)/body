{
  if (tupleDomain.isNone()) {
    return ImmutableList.of();
  }
  Set<List<Comparable<?>>> partitionKeysSet=getPartitionKeysSet(table,tupleDomain);
  if (partitionKeysSet.isEmpty()) {
    return schemaProvider.getAllPartitions(table);
  }
  ImmutableList.Builder<ListenableFuture<List<CassandraPartition>>> getPartitionResults=ImmutableList.builder();
  for (  final List<Comparable<?>> partitionKeys : partitionKeysSet) {
    getPartitionResults.add(executor.submit(new Callable<List<CassandraPartition>>(){
      @Override public List<CassandraPartition> call(){
        return schemaProvider.getPartitions(table,partitionKeys);
      }
    }
));
  }
  ImmutableList.Builder<CassandraPartition> partitions=ImmutableList.builder();
  for (  ListenableFuture<List<CassandraPartition>> result : getPartitionResults.build()) {
    try {
      partitions.addAll(result.get());
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
      throw Throwables.propagate(e);
    }
catch (    ExecutionException e) {
      throw new PrestoException(EXTERNAL.toErrorCode(),"Error fetching cassandra partitions",e);
    }
  }
  return partitions.build();
}
