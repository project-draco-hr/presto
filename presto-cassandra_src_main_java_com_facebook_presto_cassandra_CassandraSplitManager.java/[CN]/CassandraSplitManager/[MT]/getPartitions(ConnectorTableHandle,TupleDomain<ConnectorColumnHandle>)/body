{
  CassandraTableHandle cassandraTableHandle=checkType(tableHandle,CassandraTableHandle.class,"tableHandle");
  checkNotNull(tupleDomain,"tupleDomain is null");
  CassandraTable table=schemaProvider.getTable(cassandraTableHandle);
  List<CassandraColumnHandle> partitionKeys=table.getPartitionKeyColumns();
  List<Comparable<?>> filterPrefix=new ArrayList<>();
  for (int i=0; i < partitionKeys.size(); i++) {
    CassandraColumnHandle columnHandle=partitionKeys.get(i);
    if (filterPrefix.size() == i && !tupleDomain.isNone()) {
      Domain domain=tupleDomain.getDomains().get(columnHandle);
      if (domain != null && domain.getRanges().getRangeCount() == 1) {
        Range range=Iterables.getOnlyElement(domain.getRanges());
        if (range.isSingleValue()) {
          Comparable<?> value=range.getLow().getValue();
          checkArgument(value instanceof Boolean || value instanceof String || value instanceof Double|| value instanceof Long,"Only Boolean, String, Double and Long partition keys are supported");
          filterPrefix.add(value);
        }
      }
    }
  }
  List<CassandraPartition> allPartitions=schemaProvider.getPartitions(table,filterPrefix);
  log.debug("%s.%s #partitions: %d",cassandraTableHandle.getSchemaName(),cassandraTableHandle.getTableName(),allPartitions.size());
  List<ConnectorPartition> partitions=FluentIterable.from(allPartitions).filter(partitionMatches(tupleDomain)).filter(ConnectorPartition.class).toList();
  TupleDomain<ConnectorColumnHandle> remainingTupleDomain=TupleDomain.none();
  if (!tupleDomain.isNone()) {
    if (partitions.size() == 1 && ((CassandraPartition)partitions.get(0)).isUnpartitioned()) {
      remainingTupleDomain=tupleDomain;
    }
 else {
      @SuppressWarnings({"rawtypes","unchecked"}) List<ConnectorColumnHandle> partitionColumns=(List)partitionKeys;
      remainingTupleDomain=TupleDomain.withColumnDomains(Maps.filterKeys(tupleDomain.getDomains(),not(in(partitionColumns))));
    }
  }
  if (partitions.size() == 1 && ((CassandraPartition)partitions.get(0)).isUnpartitioned()) {
    Map<ConnectorColumnHandle,Domain> domains=tupleDomain.getDomains();
    List<ConnectorColumnHandle> indexedColumns=Lists.newArrayList();
    StringBuilder sb=new StringBuilder();
    for (    Map.Entry<ConnectorColumnHandle,Domain> entry : domains.entrySet()) {
      CassandraColumnHandle column=(CassandraColumnHandle)entry.getKey();
      Domain domain=entry.getValue();
      if (column.isIndexed() && domain.isSingleValue()) {
        sb.append(CassandraCqlUtils.validColumnName(column.getName())).append(" = ").append(CassandraCqlUtils.cqlValue(entry.getValue().getSingleValue().toString(),column.getCassandraType()));
        indexedColumns.add(column);
        break;
      }
    }
    if (sb.length() > 0) {
      CassandraPartition partition=(CassandraPartition)partitions.get(0);
      TupleDomain<ConnectorColumnHandle> filterIndexedColumn=TupleDomain.withColumnDomains(Maps.filterKeys(remainingTupleDomain.getDomains(),not(in(indexedColumns))));
      partitions=Lists.newArrayList();
      partitions.add(new CassandraPartition(partition.getKey(),sb.toString(),filterIndexedColumn,true));
      return new ConnectorPartitionResult(partitions,filterIndexedColumn);
    }
  }
  return new ConnectorPartitionResult(partitions,remainingTupleDomain);
}
