{
  return new Iterable<T>(){
    @Override public Iterator<T> iterator(){
      return new AbstractIterator<T>(){
        List<T> list=Lists.newArrayList(iterable);
        int limit=list.size();
        @Override protected T computeNext(){
          if (limit == 0) {
            return endOfData();
          }
          int position=ThreadLocalRandom.current().nextInt(limit);
          T result=list.get(position);
          list.set(position,list.get(limit - 1));
          limit--;
          return result;
        }
      }
;
    }
  }
;
}
