{
  Multimap<Node,Split> assignment=HashMultimap.create();
  Map<Node,Integer> assignmentCount=new HashMap<>();
  for (  Node node : nodeMap.get().get().getNodesByHostAndPort().values()) {
    assignmentCount.put(node,0);
  }
  Map<Node,Integer> splitCountByNode=new HashMap<>();
  Map<String,Integer> queuedSplitCountByNode=new HashMap<>();
  for (  RemoteTask task : existingTasks) {
    String nodeId=task.getNodeId();
    queuedSplitCountByNode.put(nodeId,queuedSplitCountByNode.getOrDefault(nodeId,0) + task.getQueuedPartitionedSplitCount());
  }
  ResettableRandomizedIterator<Node> randomCandidates=randomizedNodes();
  for (  Split split : splits) {
    randomCandidates.reset();
    List<Node> candidateNodes;
    NodeMap nodeMap=this.nodeMap.get().get();
    if (!split.isRemotelyAccessible()) {
      candidateNodes=selectNodesBasedOnHint(nodeMap,split.getAddresses());
    }
 else {
      candidateNodes=selectNodes(minCandidates,randomCandidates);
    }
    if (candidateNodes.isEmpty()) {
      log.debug("No nodes available to schedule %s. Available nodes %s",split,nodeMap.getNodesByHost().keys());
      throw new PrestoException(NO_NODES_AVAILABLE,"No nodes available to run query");
    }
    for (    Node node : candidateNodes) {
      if (!splitCountByNode.containsKey(node)) {
        splitCountByNode.put(node,nodeTaskMap.getPartitionedSplitsOnNode(node));
      }
    }
    Node chosenNode=null;
    int min=Integer.MAX_VALUE;
    for (    Node node : candidateNodes) {
      int totalSplitCount=assignmentCount.getOrDefault(node,0) + splitCountByNode.get(node);
      if (totalSplitCount < min && totalSplitCount < maxSplitsPerNode) {
        chosenNode=node;
        min=totalSplitCount;
      }
    }
    if (chosenNode == null) {
      for (      Node node : candidateNodes) {
        int assignedSplitCount=assignmentCount.getOrDefault(node,0);
        int queuedSplitCount=queuedSplitCountByNode.getOrDefault(node.getNodeIdentifier(),0);
        int totalSplitCount=queuedSplitCount + assignedSplitCount;
        if (totalSplitCount < min && totalSplitCount < maxSplitsPerNodePerTaskWhenFull) {
          chosenNode=node;
          min=totalSplitCount;
        }
      }
    }
    if (chosenNode != null) {
      assignment.put(chosenNode,split);
      assignmentCount.put(chosenNode,assignmentCount.getOrDefault(chosenNode,0) + 1);
    }
  }
  return assignment;
}
