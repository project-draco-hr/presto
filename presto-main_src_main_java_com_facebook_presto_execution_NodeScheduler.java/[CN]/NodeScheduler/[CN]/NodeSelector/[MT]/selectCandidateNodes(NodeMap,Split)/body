{
  Set<Node> chosen=new LinkedHashSet<>(minCandidates);
  for (  HostAddress hint : split.getAddresses()) {
    for (    Node node : nodeMap.getNodesByHostAndPort().get(hint)) {
      if (chosen.add(node)) {
        scheduleLocal.incrementAndGet();
      }
    }
    InetAddress address;
    try {
      address=hint.toInetAddress();
    }
 catch (    UnknownHostException e) {
      continue;
    }
    if (!hint.hasPort() || split.isRemotelyAccessible()) {
      for (      Node node : nodeMap.getNodesByHost().get(address)) {
        if (chosen.add(node)) {
          scheduleLocal.incrementAndGet();
        }
      }
    }
  }
  if (split.isRemotelyAccessible() && chosen.size() < minCandidates) {
    for (    HostAddress hint : split.getAddresses()) {
      InetAddress address;
      try {
        address=hint.toInetAddress();
      }
 catch (      UnknownHostException e) {
        continue;
      }
      for (      Node node : nodeMap.getNodesByRack().get(Rack.of(address))) {
        if (chosen.add(node)) {
          scheduleRack.incrementAndGet();
        }
        if (chosen.size() == minCandidates) {
          break;
        }
      }
      if (chosen.size() == minCandidates) {
        break;
      }
    }
  }
  if (split.isRemotelyAccessible()) {
    if (chosen.size() < minCandidates) {
      for (      Node node : lazyShuffle(nodeMap.getNodesByHost().values())) {
        if (chosen.add(node)) {
          scheduleRandom.incrementAndGet();
        }
        if (chosen.size() == minCandidates) {
          break;
        }
      }
    }
  }
  return ImmutableList.copyOf(chosen);
}
