{
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> intermediateCalls=new HashMap<>();
  Map<Symbol,Signature> intermediateFunctions=new HashMap<>();
  Map<Symbol,Symbol> intermediateMask=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : aggregations.entrySet()) {
    Signature signature=functions.get(entry.getKey());
    FunctionInfo function=metadata.getExactFunction(signature);
    Symbol intermediateSymbol=allocator.newSymbol(function.getName().getSuffix(),metadata.getType(function.getIntermediateType()));
    intermediateCalls.put(intermediateSymbol,entry.getValue());
    intermediateFunctions.put(intermediateSymbol,signature);
    if (masks.containsKey(entry.getKey())) {
      intermediateMask.put(intermediateSymbol,masks.get(entry.getKey()));
    }
    finalCalls.put(entry.getKey(),new FunctionCall(function.getName(),ImmutableList.<Expression>of(new QualifiedNameReference(intermediateSymbol.toQualifiedName()))));
  }
  AggregationNode partialAggregation=new AggregationNode(idAllocator.getNextId(),plan.getRoot(),groupBy,intermediateCalls,intermediateFunctions,intermediateMask,PARTIAL,sampleWeight,confidence,hashSymbol);
  plan.setRoot(partialAggregation);
  RemoteSourceNode source=new RemoteSourceNode(idAllocator.getNextId(),plan.getId(),plan.getRoot().getOutputSymbols());
  AggregationNode finalAggregation=new AggregationNode(idAllocator.getNextId(),source,groupBy,finalCalls,functions,ImmutableMap.of(),FINAL,Optional.empty(),confidence,hashSymbol);
  if (groupBy.isEmpty()) {
    plan=createSingleNodePlan(finalAggregation).addChild(plan.build());
  }
 else {
    plan.setHashOutputPartitioning(groupBy,hashSymbol);
    plan=createFixedDistributionPlan(finalAggregation).addChild(plan.build());
  }
  return plan;
}
