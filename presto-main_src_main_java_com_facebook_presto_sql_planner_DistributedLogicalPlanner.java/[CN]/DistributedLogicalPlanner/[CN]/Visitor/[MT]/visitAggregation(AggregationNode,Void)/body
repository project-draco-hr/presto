{
  SubPlanBuilder current=node.getSource().accept(this,context);
  if (!current.isPartitioned()) {
    current.setRoot(new AggregationNode(current.getRoot(),node.getGroupBy(),node.getAggregations(),node.getFunctions(),SINGLE));
    return current;
  }
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> intermediateCalls=new HashMap<>();
  Map<Symbol,FunctionHandle> intermediateFunctions=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    FunctionHandle functionHandle=node.getFunctions().get(entry.getKey());
    FunctionInfo function=metadata.getFunction(functionHandle);
    Symbol intermediateSymbol=allocator.newSymbol(function.getName().getSuffix(),Type.fromRaw(function.getIntermediateType()));
    intermediateCalls.put(intermediateSymbol,entry.getValue());
    intermediateFunctions.put(intermediateSymbol,functionHandle);
    finalCalls.put(entry.getKey(),new FunctionCall(function.getName(),ImmutableList.<Expression>of(new QualifiedNameReference(intermediateSymbol.toQualifiedName()))));
  }
  current.setRoot(new AggregationNode(current.getRoot(),node.getGroupBy(),intermediateCalls,intermediateFunctions,PARTIAL));
  ExchangeNode source=new ExchangeNode(current.getId(),current.getRoot().getOutputSymbols());
  AggregationNode merged=new AggregationNode(source,node.getGroupBy(),finalCalls,node.getFunctions(),FINAL);
  current=newSubPlan(merged).setPartitioned(false).addChild(current.build());
  return current;
}
