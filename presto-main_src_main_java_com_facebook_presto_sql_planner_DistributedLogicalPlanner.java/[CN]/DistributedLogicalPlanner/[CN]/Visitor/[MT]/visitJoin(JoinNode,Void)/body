{
  SubPlanBuilder left=node.getLeft().accept(this,context);
  SubPlanBuilder right=node.getRight().accept(this,context);
  if (left.isDistributed() || right.isDistributed()) {
    List<Symbol> leftSymbols=Lists.transform(node.getCriteria(),leftGetter());
    List<Symbol> rightSymbols=Lists.transform(node.getCriteria(),rightGetter());
switch (node.getType()) {
case INNER:
case LEFT:
      right.setRoot(new SinkNode(idAllocator.getNextId(),right.getRoot(),right.getRoot().getOutputSymbols()));
    if (distributedJoins) {
      right.setHashOutputPartitioning(rightSymbols,node.getRightHashSymbol().transform(channelGetter(right.getRoot())));
      left=hashDistributeSubplan(left,leftSymbols,node.getLeftHashSymbol());
    }
  left.setRoot(new JoinNode(node.getId(),node.getType(),left.getRoot(),new ExchangeNode(idAllocator.getNextId(),right.getId(),right.getRoot().getOutputSymbols()),node.getCriteria(),node.getLeftHashSymbol(),node.getRightHashSymbol()));
left.addChild(right.build());
return left;
case RIGHT:
left.setRoot(new SinkNode(idAllocator.getNextId(),left.getRoot(),left.getRoot().getOutputSymbols()));
if (distributedJoins) {
left.setHashOutputPartitioning(leftSymbols,node.getLeftHashSymbol().transform(channelGetter(left.getRoot())));
right=hashDistributeSubplan(right,rightSymbols,node.getRightHashSymbol());
}
right.setRoot(new JoinNode(node.getId(),node.getType(),new ExchangeNode(idAllocator.getNextId(),left.getId(),left.getRoot().getOutputSymbols()),right.getRoot(),node.getCriteria(),node.getLeftHashSymbol(),node.getRightHashSymbol()));
right.addChild(left.build());
return right;
default :
throw new UnsupportedOperationException("Unsupported join type: " + node.getType());
}
}
 else {
JoinNode join=new JoinNode(node.getId(),node.getType(),left.getRoot(),right.getRoot(),node.getCriteria(),node.getLeftHashSymbol(),node.getRightHashSymbol());
return createSingleNodePlan(join).setChildren(Iterables.concat(left.getChildren(),right.getChildren()));
}
}
