{
  MethodHandle methodHandle;
  boolean nullable=false;
  TypedByteCodeNode patternNode=arguments.get(1);
  if (patternNode.getNode() instanceof Constant) {
switch (name) {
case "regexp_like":
      methodHandle=constantRegexpLike;
    break;
case "regexp_replace":
  methodHandle=constantRegexpReplace;
if (arguments.size() == 2) {
  methodHandle=MethodHandles.insertArguments(methodHandle,2,Slices.EMPTY_SLICE);
}
break;
case "regexp_extract":
methodHandle=constantRegexpExtract;
nullable=true;
if (arguments.size() == 2) {
methodHandle=MethodHandles.insertArguments(methodHandle,2,0L);
}
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
Slice patternSlice=(Slice)((Constant)patternNode.getNode()).getValue();
Pattern pattern=Pattern.compile(patternSlice.toString(UTF_8));
methodHandle=MethodHandles.insertArguments(methodHandle,1,pattern);
arguments=new ArrayList<>(arguments);
arguments.remove(1);
arguments=ImmutableList.copyOf(arguments);
}
 else {
switch (name) {
case "regexp_like":
methodHandle=dynamicRegexpLike;
break;
case "regexp_replace":
methodHandle=dynamicRegexpReplace;
if (arguments.size() == 2) {
methodHandle=MethodHandles.insertArguments(methodHandle,3,Slices.EMPTY_SLICE);
}
break;
case "regexp_extract":
methodHandle=dynamicRegexpExtract;
nullable=true;
if (arguments.size() == 2) {
methodHandle=MethodHandles.insertArguments(methodHandle,3,0L);
}
break;
default :
throw new IllegalArgumentException("Unsupported method " + name);
}
methodHandle=methodHandle.bindTo(new PatternCache(100));
}
return DefaultFunctionBinder.bindConstantArguments(bindingId,name,getSessionByteCode,arguments,methodHandle,nullable);
}
