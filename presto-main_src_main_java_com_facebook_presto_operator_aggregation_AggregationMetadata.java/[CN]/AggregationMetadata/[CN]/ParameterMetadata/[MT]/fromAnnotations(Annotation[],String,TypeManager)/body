{
  List<Annotation> baseTypes=IterableTransformer.on(annotations).select(new Predicate<Annotation>(){
    @Override public boolean apply(    @Nullable Annotation input){
      return input instanceof SqlType || input instanceof BlockIndex || input instanceof SampleWeight;
    }
  }
).list();
  boolean nullable=!FluentIterable.from(Arrays.asList(annotations)).filter(NullablePosition.class).isEmpty();
  checkArgument(baseTypes.size() == 1,"Parameter of %s must have exactly one of @SqlType, @BlockIndex, and @SampleWeight",methodName);
  Annotation annotation=baseTypes.get(0);
  checkArgument(!nullable || (annotation instanceof SqlType),"%s contains a parameters with @Nullable that is not @SqlType",methodName);
  if (annotation instanceof SqlType) {
    TypeSignature signature=parseTypeSignature(((SqlType)annotation).value());
    if (nullable) {
      return new ParameterMetadata(NULLABLE_INPUT_CHANNEL,typeManager.getType(signature));
    }
 else {
      return new ParameterMetadata(INPUT_CHANNEL,typeManager.getType(signature));
    }
  }
 else   if (annotation instanceof BlockIndex) {
    return new ParameterMetadata(BLOCK_INDEX);
  }
 else   if (annotation instanceof SampleWeight) {
    return new ParameterMetadata(SAMPLE_WEIGHT);
  }
 else {
    throw new IllegalArgumentException("Unsupported annotation: " + annotation);
  }
}
