{
  this.outputType=requireNonNull(outputType);
  this.inputMetadata=ImmutableList.copyOf(requireNonNull(inputMetadata,"inputMetadata is null"));
  checkArgument((intermediateInputFunction == null) == (intermediateInputMetadata == null),"intermediate input parameters must be specified iff an intermediate function is provided");
  if (intermediateInputMetadata != null) {
    this.intermediateInputMetadata=ImmutableList.copyOf(intermediateInputMetadata);
  }
 else {
    this.intermediateInputMetadata=null;
  }
  this.name=requireNonNull(name,"name is null");
  this.inputFunction=requireNonNull(inputFunction,"inputFunction is null");
  checkArgument(combineFunction == null || intermediateInputFunction == null,"Aggregation cannot have both a combine and a intermediate input method");
  checkArgument(combineFunction != null || intermediateInputFunction != null,"Aggregation must have either a combine or a intermediate input method");
  this.intermediateInputFunction=intermediateInputFunction;
  this.combineFunction=combineFunction;
  this.outputFunction=requireNonNull(outputFunction,"outputFunction is null");
  this.stateSerializer=requireNonNull(stateSerializer,"stateSerializer is null");
  this.stateFactory=requireNonNull(stateFactory,"stateFactory is null");
  this.approximate=approximate;
  verifyInputFunctionSignature(inputFunction,inputMetadata,stateInterface);
  if (intermediateInputFunction != null) {
    checkArgument(countInputChannels(intermediateInputMetadata) == 1,"Intermediate input function may only have one input channel");
    verifyInputFunctionSignature(intermediateInputFunction,intermediateInputMetadata,stateInterface);
  }
  if (combineFunction != null) {
    verifyCombineFunction(combineFunction,stateInterface);
  }
  if (approximate) {
    verifyApproximateOutputFunction(outputFunction,stateInterface);
  }
 else {
    verifyExactOutputFunction(outputFunction,stateInterface);
  }
}
