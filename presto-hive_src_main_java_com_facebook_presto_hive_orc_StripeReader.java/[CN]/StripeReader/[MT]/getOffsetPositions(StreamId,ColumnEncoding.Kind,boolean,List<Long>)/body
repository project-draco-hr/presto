{
  Type.Kind type=types.get(streamId.getColumn()).getKind();
  int compressionOffsets=compressionKind != NONE ? 1 : 0;
  List<Long> offsetPositions=positionsList;
  if (streamId.getKind() == PRESENT) {
    return offsetPositions.subList(0,BITFIELD_POSITIONS + compressionOffsets);
  }
  if (hasNulls) {
    offsetPositions=offsetPositions.subList(BITFIELD_POSITIONS + compressionOffsets,offsetPositions.size());
  }
  if (streamId.getKind() == DATA) {
switch (type) {
case BOOLEAN:
case BYTE:
case SHORT:
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case DATE:
case STRUCT:
case MAP:
case LIST:
case UNION:
      return offsetPositions;
case STRING:
case BINARY:
    if (columnEncoding == DIRECT || columnEncoding == DIRECT_V2) {
      return offsetPositions.subList(0,BYTE_STREAM_POSITIONS + compressionOffsets);
    }
 else     if (columnEncoding == DICTIONARY || columnEncoding == DICTIONARY_V2) {
      return offsetPositions.subList(0,RUN_LENGTH_INT_POSITIONS + compressionOffsets);
    }
 else {
      throw new IllegalArgumentException("Unsupported encoding " + columnEncoding);
    }
case TIMESTAMP:
  return offsetPositions.subList(0,RUN_LENGTH_INT_POSITIONS + compressionOffsets);
default :
throw new IllegalArgumentException("Unknown type " + type);
}
}
if (streamId.getKind() == LENGTH) {
switch (type) {
case STRING:
case BINARY:
int start=BYTE_STREAM_POSITIONS + compressionOffsets;
int end=start + RUN_LENGTH_INT_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
case MAP:
case LIST:
return offsetPositions;
}
}
if (streamId.getKind() == SECONDARY && type == Type.Kind.TIMESTAMP) {
int start=RUN_LENGTH_INT_POSITIONS + compressionOffsets;
int end=start + RUN_LENGTH_INT_POSITIONS + compressionOffsets;
return offsetPositions.subList(start,end);
}
throw new IllegalArgumentException("Unsupported column type " + type + " for stream "+ streamId);
}
