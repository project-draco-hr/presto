{
  checkArgument(columnIds.size() == stagedFiles.size(),"columnId list does not match file list");
  ImmutableList.Builder<BlockIterable> sourcesBuilder=ImmutableList.builder();
  ImmutableList.Builder<BlocksFileWriter> writersBuilder=ImmutableList.builder();
  ImmutableList.Builder<File> optimizedFilesBuilder=ImmutableList.builder();
  File shardPath=getShardPath(baseStorageDir,shardId);
  if (!stagedFiles.get(0).exists()) {
    ImmutableList.Builder<File> outputFiles=ImmutableList.builder();
    for (    File file : stagedFiles) {
      outputFiles.add(new File(shardPath,file.getName()));
    }
    return outputFiles.build();
  }
  for (int i=0; i < stagedFiles.size(); i++) {
    long columnId=columnIds.get(i);
    File stagedFile=stagedFiles.get(i);
    Slice slice=mappedFileCache.getUnchecked(stagedFile.getAbsoluteFile());
    BlocksFileReader blocks=BlocksFileReader.readBlocks(slice);
    BlocksFileStats stats=blocks.getStats();
    boolean rleEncode=stats.getAvgRunLength() > RUN_LENGTH_AVERAGE_CUTOFF;
    boolean dicEncode=stats.getUniqueCount() < DICTIONARY_CARDINALITY_CUTOFF;
    BlocksFileEncoding encoding=BlocksFileEncoding.RAW;
    if (dicEncode && rleEncode) {
      encoding=BlocksFileEncoding.DIC_RLE;
    }
 else     if (dicEncode) {
      encoding=BlocksFileEncoding.DIC_RAW;
    }
 else     if (rleEncode) {
      encoding=BlocksFileEncoding.RLE;
    }
    if (!enableOptimization) {
      encoding=BlocksFileEncoding.RAW;
    }
    File outputFile=getColumnFile(shardPath,columnId,encoding);
    Files.createParentDirs(outputFile);
    optimizedFilesBuilder.add(outputFile);
    if (encoding == BlocksFileEncoding.RAW) {
      Files.move(stagedFile,outputFile);
    }
 else {
      sourcesBuilder.add(blocks);
      writersBuilder.add(new BlocksFileWriter(encoding,createOutputSupplier(outputFile)));
    }
  }
  List<BlockIterable> sources=sourcesBuilder.build();
  List<BlocksFileWriter> writers=writersBuilder.build();
  if (!sources.isEmpty()) {
    AlignmentOperator source=new AlignmentOperator(sources);
    ImportingOperator.importData(source,writers);
  }
  return optimizedFilesBuilder.build();
}
