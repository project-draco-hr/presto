{
  checkArgument(extractionSpecs != null && !extractionSpecs.isEmpty(),"Extraction Spec is required");
  InputSupplier<InputStreamReader> readerSupplier;
  if (csvFile != null) {
    readerSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    readerSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(System.in,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableSortedMap.Builder<Integer,Type> schemaBuilder=ImmutableSortedMap.naturalOrder();
  ImmutableList.Builder<OutputSupplier<? extends OutputStream>> outputSupplierBuilder=ImmutableList.builder();
  for (  String extractionSpec : extractionSpecs) {
    List<String> parts=ImmutableList.copyOf(Splitter.on(':').split(extractionSpec));
    checkState(parts.size() == 3,"type format: <column_index>:<data_type>:<encoding> (e.g. 0:long:raw, 3:string:rle)");
    Integer columnIndex;
    try {
      columnIndex=Integer.parseInt(parts.get(0));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException("Malformed column index: " + parts.get(0));
    }
    String dataTypeName=parts.get(1);
    String encodingName=parts.get(2);
    schemaBuilder.put(columnIndex,TupleInfo.Type.fromName(dataTypeName));
    outputSupplierBuilder.add(newOutputStreamSupplier(new File(outputDir,String.format("column%d.%s_%s.data",columnIndex,dataTypeName,encodingName))));
  }
  ImmutableSortedMap<Integer,Type> schema=schemaBuilder.build();
  ImmutableList<OutputSupplier<? extends OutputStream>> outputSuppliers=outputSupplierBuilder.build();
  ImmutableList.Builder<RecordProjection> recordProjectionBuilder=ImmutableList.builder();
  ImmutableList.Builder<BlockWriterFactory> writersBuilder=ImmutableList.builder();
  for (int index=0; index <= schema.lastKey(); index++) {
    Type type=VARIABLE_BINARY;
    if (schema.containsKey(index)) {
      type=schema.get(index);
    }
    recordProjectionBuilder.add(RecordProjections.createProjection(index,type));
    writersBuilder.add(new SerdeBlockWriterFactory(FileEncoding.RAW,outputSuppliers.get(index)));
  }
  List<RecordProjection> recordProjections=recordProjectionBuilder.build();
  List<BlockWriterFactory> writers=writersBuilder.build();
  DelimitedRecordIterable records=new DelimitedRecordIterable(readerSupplier,Splitter.on(toChar(columnSeparator)));
  Operator source=new RecordProjectOperator(records,recordProjections);
  long rowCount=ImportingOperator.importData(source,writers);
  log.info("Importoed %d rows",rowCount);
}
