{
  checkArgument(extractionSpecs != null && !extractionSpecs.isEmpty(),"Extraction Spec is required");
  InputSupplier<InputStreamReader> inputSupplier;
  if (csvFile != null) {
    inputSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    inputSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(System.in,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableSortedMap.Builder<Integer,Type> schemaBuilder=ImmutableSortedMap.naturalOrder();
  ImmutableList.Builder<Integer> extractionColumnsBuilder=ImmutableList.builder();
  ImmutableList.Builder<TupleStreamSerializer> serializerBuilder=ImmutableList.builder();
  ImmutableList.Builder<OutputSupplier<? extends OutputStream>> outputSupplierBuilder=ImmutableList.builder();
  for (  String extractionSpec : extractionSpecs) {
    List<String> parts=ImmutableList.copyOf(Splitter.on(':').split(extractionSpec));
    checkState(parts.size() == 3,"type format: <column_index>:<data_type>:<encoding> (e.g. 0:long:raw, 3:string:rle)");
    Integer columnIndex;
    try {
      columnIndex=Integer.parseInt(parts.get(0));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException("Malformed column index: " + parts.get(0));
    }
    String dataTypeName=parts.get(1);
    String encodingName=parts.get(2);
    schemaBuilder.put(columnIndex,TupleInfo.Type.fromName(dataTypeName));
    extractionColumnsBuilder.add(columnIndex);
    serializerBuilder.add(TupleStreamSerdes.Encoding.fromName(encodingName).createSerde().createSerializer());
    outputSupplierBuilder.add(newOutputStreamSupplier(new File(outputDir,String.format("column%d.%s_%s.data",columnIndex,dataTypeName,encodingName))));
  }
  ImmutableSortedMap<Integer,Type> schema=schemaBuilder.build();
  ImmutableList<Integer> extractionColumns=extractionColumnsBuilder.build();
  ImmutableList<TupleStreamSerializer> serializers=serializerBuilder.build();
  ImmutableList<OutputSupplier<? extends OutputStream>> outputSuppliers=outputSupplierBuilder.build();
  ImmutableList.Builder<Type> inferredTypes=ImmutableList.builder();
  for (int index=0; index <= schema.lastKey(); index++) {
    if (schema.containsKey(index)) {
      inferredTypes.add(schema.get(index));
    }
 else {
      inferredTypes.add(Type.VARIABLE_BINARY);
    }
  }
  TupleInfo tupleInfo=new TupleInfo(inferredTypes.build());
  try (InputStreamReader input=inputSupplier.getInput()){
    DelimitedTupleStream delimitedTupleStream=new DelimitedTupleStream(input,Splitter.on(toChar(columnSeparator)),tupleInfo);
    ColumnMappingTupleStream projectedStream=new ColumnMappingTupleStream(delimitedTupleStream,extractionColumns);
    ImmutableList.Builder<StreamWriterTupleValueSink> tupleValueSinkBuilder=ImmutableList.builder();
    for (int index=0; index < extractionColumns.size(); index++) {
      tupleValueSinkBuilder.add(new StreamWriterTupleValueSink(outputSuppliers.get(index),serializers.get(index)));
    }
    long rowCount=TupleStreamImporter.importFrom(projectedStream,tupleValueSinkBuilder.build());
    log.info("Imported %d rows",rowCount);
  }
 }
