{
  checkArgument(extractionSpecs != null && !extractionSpecs.isEmpty(),"Extraction Spec is required");
  InputSupplier<InputStreamReader> inputSupplier;
  if (csvFile != null) {
    inputSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    inputSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(System.in,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableList.Builder<DelimitedBlockExtractor.ColumnDefinition> columnDefinitionBuilder=ImmutableList.builder();
  ImmutableList.Builder<BlockDataImporter.ColumnImportSpec> columnImportSpecBuilder=ImmutableList.builder();
  for (  String extractionSpec : extractionSpecs) {
    List<String> parts=ImmutableList.copyOf(Splitter.on('_').split(extractionSpec));
    checkState(parts.size() == 3,"type format: <column_index>_<data_type>_<encoding> (e.g. 0_long_raw, 3_string_rle)");
    Integer columnIndex=Integer.parseInt(parts.get(0));
    String dataTypeName=parts.get(1);
    String encodingName=parts.get(2);
    TupleInfo.Type type;
switch (dataTypeName) {
case "long":
      type=Type.FIXED_INT_64;
    break;
case "double":
  type=Type.DOUBLE;
break;
case "string":
type=Type.VARIABLE_BINARY;
break;
case "fmillis":
type=Type.DOUBLE;
break;
default :
throw new IllegalArgumentException("Unsupported type " + dataTypeName);
}
columnDefinitionBuilder.add(new DelimitedBlockExtractor.ColumnDefinition(columnIndex,type));
columnImportSpecBuilder.add(new BlockDataImporter.ColumnImportSpec(TupleStreamSerdes.createTupleStreamSerde(encodingName),newOutputStreamSupplier(new File(outputDir,String.format("column%d.%s_%s.data",columnIndex,dataTypeName,encodingName)))));
}
BlockExtractor blockExtractor=new DelimitedBlockExtractor(columnDefinitionBuilder.build(),Splitter.on(toChar(columnSeparator)));
BlockDataImporter importer=new BlockDataImporter(blockExtractor,columnImportSpecBuilder.build());
importer.importFrom(inputSupplier);
}
