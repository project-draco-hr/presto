{
  Preconditions.checkArgument(types != null && !types.isEmpty(),"Type is required");
  File dir=new File(outputDir);
  InputSupplier<InputStreamReader> inputSupplier;
  if (csvFile != null) {
    inputSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    inputSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(System.in,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableList.Builder<TupleInfo.Type> typeBuilder=ImmutableList.builder();
  ImmutableList.Builder<CsvColumnProcessor> csvColumns=ImmutableList.builder();
  for (  String type : types) {
switch (type) {
case "long":
      typeBuilder.add(FIXED_INT_64);
    csvColumns.add(csvNumericColumn());
  break;
case "double":
typeBuilder.add(DOUBLE);
csvColumns.add(csvDoubleColumn());
break;
case "string":
typeBuilder.add(VARIABLE_BINARY);
csvColumns.add(csvStringColumn());
break;
case "fmillis":
typeBuilder.add(FIXED_INT_64);
csvColumns.add(csvFloatMillisColumn());
break;
default :
throw new IllegalArgumentException("Unsupported type " + type);
}
}
ImmutableList<TupleInfo.Type> columnTypes=typeBuilder.build();
TupleInfo tupleInfo=new TupleInfo(columnTypes);
CsvReader csvReader=new CsvReader(tupleInfo,inputSupplier,toChar(columnSeparator),csvColumns.build());
ImmutableList.Builder<ColumnProcessor> processorsBuilder=ImmutableList.builder();
ImmutableList.Builder<RowSource> rowSources=ImmutableList.builder();
ImmutableList.Builder<OutputStream> outputs=ImmutableList.builder();
for (int index=0; index < columnTypes.size(); index++) {
TupleInfo.Type type=columnTypes.get(index);
RowSource rowSource=csvReader.getInput();
File file=new File(dir,"column" + index + ".data");
OutputStream out=new FileOutputStream(file);
processorsBuilder.add(new UncompressedColumnWriter(type,index,rowSource.cursor(),out));
rowSources.add(rowSource);
outputs.add(out);
}
List<ColumnProcessor> processors=processorsBuilder.build();
ColumnProcessors.process(processors);
for (ColumnProcessor processor : processors) {
processor.finish();
}
for (RowSource rowSource : rowSources.build()) {
rowSource.close();
}
for (OutputStream out : outputs.build()) {
out.close();
}
}
