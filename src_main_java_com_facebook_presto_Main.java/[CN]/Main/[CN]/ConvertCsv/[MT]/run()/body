{
  checkArgument(extractionSpecs != null && !extractionSpecs.isEmpty(),"Extraction Spec is required");
  InputSupplier<InputStreamReader> inputSupplier;
  if (csvFile != null) {
    inputSupplier=Files.newReaderSupplier(new File(csvFile),Charsets.UTF_8);
  }
 else {
    inputSupplier=new InputSupplier<InputStreamReader>(){
      public InputStreamReader getInput(){
        return new InputStreamReader(System.in,Charsets.UTF_8);
      }
    }
;
  }
  ImmutableList.Builder<ColumnDefinition> columnDefinitionBuilder=ImmutableList.builder();
  ImmutableList.Builder<ColumnImportSpec> columnImportSpecBuilder=ImmutableList.builder();
  for (  String extractionSpec : extractionSpecs) {
    List<String> parts=ImmutableList.copyOf(Splitter.on(':').split(extractionSpec));
    checkState(parts.size() == 3,"type format: <column_index>:<data_type>:<encoding> (e.g. 0:long:raw, 3:string:rle)");
    Integer columnIndex;
    try {
      columnIndex=Integer.parseInt(parts.get(0));
    }
 catch (    NumberFormatException e) {
      throw new IllegalArgumentException("Malformed column index: " + parts.get(0));
    }
    String dataTypeName=parts.get(1);
    String encodingName=parts.get(2);
    columnDefinitionBuilder.add(new ColumnDefinition(columnIndex,TupleInfo.Type.fromName(dataTypeName)));
    columnImportSpecBuilder.add(new ColumnImportSpec(TupleStreamSerdes.createTupleStreamSerde(TupleStreamSerdes.Encoding.fromName(encodingName)),newOutputStreamSupplier(new File(outputDir,String.format("column%d.%s_%s.data",columnIndex,dataTypeName,encodingName.replace('/','-'))))));
  }
  BlockExtractor blockExtractor=new DelimitedBlockExtractor(Splitter.on(toChar(columnSeparator)),columnDefinitionBuilder.build());
  BlockDataImporter importer=new BlockDataImporter(blockExtractor,columnImportSpecBuilder.build());
  importer.importFrom(inputSupplier);
}
