{
  if (types.isEmpty()) {
    Type unknownArray=typeManager.getParameterizedType(ARRAY.getName(),ImmutableList.of(UnknownType.NAME));
    return new FunctionInfo(arrayConstructorSignature(unknownArray,ImmutableList.<Type>of()),"",true,EMPTY_ARRAY_CONSTRUCTOR,true,false,ImmutableList.<Boolean>of());
  }
  checkArgument(ImmutableSet.copyOf(types).size() == 1,"Can only construct arrays from exactly matching types");
  ImmutableList.Builder<Class<?>> builder=ImmutableList.builder();
  for (  Type type : types) {
    if (type.getJavaType().isPrimitive()) {
      builder.add(Primitives.wrap(type.getJavaType()));
    }
 else {
      builder.add(type.getJavaType());
    }
  }
  ImmutableList<Class<?>> stackTypes=builder.build();
  Class<?> clazz=generateArrayConstructor(stackTypes);
  MethodHandle methodHandle;
  try {
    Method method=clazz.getMethod("arrayConstructor",stackTypes.toArray(new Class<?>[stackTypes.size()]));
    methodHandle=lookup().unreflect(method);
  }
 catch (  ReflectiveOperationException e) {
    throw Throwables.propagate(e);
  }
  Type arrayType=typeManager.getParameterizedType(ARRAY.getName(),ImmutableList.of(types.get(0).getName()));
  List<Boolean> nullableParameters=ImmutableList.copyOf(Collections.nCopies(stackTypes.size(),true));
  return new FunctionInfo(arrayConstructorSignature(arrayType,types),"Constructs an array of the given elements",true,methodHandle,true,false,nullableParameters);
}
