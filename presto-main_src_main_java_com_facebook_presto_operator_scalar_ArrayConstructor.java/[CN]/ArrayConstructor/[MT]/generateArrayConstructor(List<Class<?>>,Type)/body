{
  List<String> stackTypeNames=FluentIterable.from(stackTypes).transform(new Function<Class<?>,String>(){
    @Override public String apply(    Class<?> input){
      return input.getSimpleName();
    }
  }
).toList();
  ClassDefinition definition=new ClassDefinition(new CompilerContext(null),a(PUBLIC,FINAL),CompilerUtils.makeClassName(Joiner.on("").join(stackTypeNames) + "ArrayConstructor"),type(Object.class));
  definition.declareDefaultConstructor(a(PRIVATE));
  ImmutableList.Builder<NamedParameterDefinition> parameters=ImmutableList.builder();
  for (int i=0; i < stackTypes.size(); i++) {
    Class<?> stackType=stackTypes.get(i);
    parameters.add(arg("arg" + i,stackType));
  }
  CompilerContext context=new CompilerContext(null);
  Block body=definition.declareMethod(context,a(PUBLIC,STATIC),"arrayConstructor",type(Slice.class),parameters.build()).getBody();
  Variable valuesVariable=context.declareVariable(List.class,"values");
  body.comment("List<Object> values = new ArrayList();").newObject(ArrayList.class).dup().invokeConstructor(ArrayList.class).putVariable(valuesVariable);
  for (int i=0; i < stackTypes.size(); i++) {
    body.comment("values.add(arg" + i + ");").getVariable(valuesVariable).getVariable("arg" + i);
    Class<?> stackType=stackTypes.get(i);
    if (stackType.isPrimitive()) {
      body.append(ByteCodeUtils.boxPrimitiveIfNecessary(context,stackType));
    }
    body.invokeInterface(List.class,"add",boolean.class,Object.class);
  }
  if (elementType instanceof ArrayType || elementType instanceof MapType) {
    body.comment("return rawSlicesToStackRepresentation(values);").getVariable(valuesVariable).invokeStatic(ArrayType.class,"rawSlicesToStackRepresentation",Slice.class,List.class).retObject();
  }
 else {
    body.comment("return toStackRepresentation(values);").getVariable(valuesVariable).invokeStatic(ArrayType.class,"toStackRepresentation",Slice.class,List.class).retObject();
  }
  return defineClass(definition,Object.class,new DynamicClassLoader());
}
