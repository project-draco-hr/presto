{
  checkNotNull(tableHandle,"tableHandle is null");
  checkNotNull(effectivePredicate,"effectivePredicate is null");
  SchemaTableName tableName=getTableName(tableHandle);
  List<FieldSchema> partitionKeys;
  Optional<HiveBucket> bucket;
  try {
    Table table=metastore.getTable(tableName.getSchemaName(),tableName.getTableName());
    String protectMode=table.getParameters().get(ProtectMode.PARAMETER_NAME);
    if (protectMode != null && getProtectModeFromString(protectMode).offline) {
      throw new TableOfflineException(tableName);
    }
    String prestoOffline=table.getParameters().get(PRESTO_OFFLINE);
    if (!isNullOrEmpty(prestoOffline)) {
      throw new TableOfflineException(tableName,format("Table '%s' is offline for Presto: %s",tableName,prestoOffline));
    }
    partitionKeys=table.getPartitionKeys();
    bucket=getHiveBucket(table,effectivePredicate.extractFixedValues());
  }
 catch (  NoSuchObjectException e) {
    throw new TableNotFoundException(tableName);
  }
  ImmutableMap.Builder<String,ConnectorColumnHandle> partitionKeysByNameBuilder=ImmutableMap.builder();
  List<String> filterPrefix=new ArrayList<>();
  for (int i=0; i < partitionKeys.size(); i++) {
    FieldSchema field=partitionKeys.get(i);
    HiveType hiveType=getSupportedHiveType(field.getType());
    HiveColumnHandle columnHandle=new HiveColumnHandle(connectorId,field.getName(),i,hiveType,getType(field.getType()).getTypeSignature(),-1,true);
    partitionKeysByNameBuilder.put(field.getName(),columnHandle);
    if (filterPrefix.size() == i && !effectivePredicate.isNone()) {
      Domain domain=effectivePredicate.getDomains().get(columnHandle);
      if (domain != null && domain.isNullableSingleValue()) {
        Comparable<?> value=domain.getNullableSingleValue();
        if (value == null) {
          filterPrefix.add(HivePartitionKey.HIVE_DEFAULT_DYNAMIC_PARTITION);
        }
 else {
          checkArgument(value instanceof Boolean || value instanceof Slice || value instanceof Double|| value instanceof Long,"Only Boolean, Slice (UTF8 String), Double and Long partition keys are supported");
          if (value instanceof Slice) {
            filterPrefix.add(((Slice)value).toStringUtf8());
          }
 else {
            filterPrefix.add(value.toString());
          }
        }
      }
    }
  }
  List<String> partitionNames;
  try {
    if (partitionKeys.isEmpty()) {
      partitionNames=ImmutableList.of(UNPARTITIONED_ID);
    }
 else     if (filterPrefix.isEmpty()) {
      partitionNames=metastore.getPartitionNames(tableName.getSchemaName(),tableName.getTableName());
    }
 else {
      partitionNames=metastore.getPartitionNamesByParts(tableName.getSchemaName(),tableName.getTableName(),filterPrefix);
    }
  }
 catch (  NoSuchObjectException e) {
    throw new TableNotFoundException(tableName);
  }
  Map<String,ConnectorColumnHandle> partitionKeysByName=partitionKeysByNameBuilder.build();
  List<ConnectorPartition> partitions=FluentIterable.from(partitionNames).transform(toPartition(tableName,partitionKeysByName,bucket,timeZone,toHiveTupleDomain(effectivePredicate))).filter(partitionMatches(effectivePredicate)).filter(ConnectorPartition.class).toList();
  TupleDomain<ConnectorColumnHandle> remainingTupleDomain=TupleDomain.none();
  if (!effectivePredicate.isNone()) {
    remainingTupleDomain=TupleDomain.withColumnDomains(Maps.filterKeys(effectivePredicate.getDomains(),not(in(partitionKeysByName.values()))));
  }
  return new ConnectorPartitionResult(partitions,remainingTupleDomain);
}
