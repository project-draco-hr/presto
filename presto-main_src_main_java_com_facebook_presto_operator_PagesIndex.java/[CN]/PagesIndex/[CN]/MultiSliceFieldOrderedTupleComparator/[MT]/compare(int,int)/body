{
  long leftSliceAddress=sliceAddresses[leftPosition];
  Slice leftSlice=slices[((int)(leftSliceAddress >> 32))];
  int leftOffset=(int)leftSliceAddress;
  long rightSliceAddress=sliceAddresses[rightPosition];
  Slice rightSlice=slices[((int)(rightSliceAddress >> 32))];
  int rightOffset=(int)rightSliceAddress;
  for (int i=0; i < sortFields.length; i++) {
    int field=sortFields[i];
    Type type=types[field];
    int comparison;
switch (type) {
case BOOLEAN:
      comparison=Boolean.compare(tupleInfo.getBoolean(leftSlice,leftOffset,field),tupleInfo.getBoolean(rightSlice,rightOffset,field));
    break;
case FIXED_INT_64:
  comparison=Long.compare(tupleInfo.getLong(leftSlice,leftOffset,field),tupleInfo.getLong(rightSlice,rightOffset,field));
break;
case DOUBLE:
comparison=Double.compare(tupleInfo.getDouble(leftSlice,leftOffset,field),tupleInfo.getDouble(rightSlice,rightOffset,field));
break;
case VARIABLE_BINARY:
comparison=tupleInfo.getSlice(leftSlice,leftOffset,field).compareTo(tupleInfo.getSlice(rightSlice,rightOffset,field));
break;
default :
throw new AssertionError("unimplemented type: " + type);
}
if (comparison != 0) {
if (sortOrder[i]) {
return comparison;
}
 else {
return -comparison;
}
}
}
return 0;
}
