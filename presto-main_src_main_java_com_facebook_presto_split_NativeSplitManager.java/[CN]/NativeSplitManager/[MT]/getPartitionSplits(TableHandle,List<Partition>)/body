{
  Stopwatch splitTimer=new Stopwatch();
  splitTimer.start();
  checkNotNull(partitions,"partitions is null");
  if (partitions.isEmpty()) {
    return new FixedSplitSource(getConnectorId(),ImmutableList.<Split>of());
  }
  Map<String,Node> nodesById=uniqueIndex(nodeManager.getActiveNodes(),getIdentifierFunction());
  List<Split> splits=new ArrayList<>();
  Multimap<Long,Entry<UUID,String>> partitionShardNodes=shardManager.getShardNodesByPartition(tableHandle);
  for (  Partition partition : partitions) {
    checkArgument(partition instanceof NativePartition,"Partition must be a native partition");
    NativePartition nativePartition=(NativePartition)partition;
    ImmutableMultimap.Builder<UUID,String> shardNodes=ImmutableMultimap.builder();
    for (    Entry<UUID,String> shardNode : partitionShardNodes.get(nativePartition.getNativePartitionId())) {
      shardNodes.put(shardNode.getKey(),shardNode.getValue());
    }
    for (    Map.Entry<UUID,Collection<String>> entry : shardNodes.build().asMap().entrySet()) {
      List<HostAddress> addresses=getAddressesForNodes(nodesById,entry.getValue());
      checkState(addresses.size() > 0,"no host for shard %s found",entry.getKey());
      Split split=new NativeSplit(entry.getKey(),addresses);
      splits.add(split);
    }
  }
  log.debug("Split retrieval for %d partitions (%d splits): %dms",partitions.size(),splits.size(),splitTimer.elapsed(TimeUnit.MILLISECONDS));
  Collections.shuffle(splits);
  return new FixedSplitSource(getConnectorId(),splits);
}
