{
  Arrays.fill(nulls,false);
  Object rowData=deserializer.deserialize(value);
  for (int outputColumnIndex=0; outputColumnIndex < types.length; outputColumnIndex++) {
    if (isPartitionColumn[outputColumnIndex]) {
      continue;
    }
    Object fieldData=rowInspector.getStructFieldData(rowData,structFields[outputColumnIndex]);
    if (fieldData == null) {
      nulls[outputColumnIndex]=true;
    }
 else     if (hiveTypes[outputColumnIndex] == HiveType.MAP || hiveTypes[outputColumnIndex] == HiveType.LIST || hiveTypes[outputColumnIndex] == HiveType.STRUCT) {
      strings[outputColumnIndex]=SerDeUtils.getJSONString(fieldData,fieldInspectors[outputColumnIndex]).getBytes(Charsets.UTF_8);
    }
 else {
      Object fieldValue=((PrimitiveObjectInspector)fieldInspectors[outputColumnIndex]).getPrimitiveJavaObject(fieldData);
      checkState(fieldValue != null,"fieldValue should not be null");
switch (types[outputColumnIndex]) {
case BOOLEAN:
        booleans[outputColumnIndex]=(Boolean)fieldValue;
      break;
case LONG:
    longs[outputColumnIndex]=getLongOrTimestamp(fieldValue);
  break;
case DOUBLE:
doubles[outputColumnIndex]=((Number)fieldValue).doubleValue();
break;
case STRING:
if (fieldValue instanceof String) {
strings[outputColumnIndex]=((String)fieldValue).getBytes(Charsets.UTF_8);
}
 else if (fieldValue instanceof byte[]) {
strings[outputColumnIndex]=(byte[])fieldValue;
}
 else {
throw new IllegalStateException("unsupported string field type: " + fieldValue.getClass().getName());
}
break;
}
}
}
}
