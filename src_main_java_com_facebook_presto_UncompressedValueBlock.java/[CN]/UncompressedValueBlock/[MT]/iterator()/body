{
  return new AbstractIterator<Tuple>(){
    private int currentOffset=0;
    private long index=0;
    @Override protected Tuple computeNext(){
      if (index >= getCount()) {
        endOfData();
        return null;
      }
      Slice currentPositionToEnd=slice.slice(currentOffset,slice.length() - currentOffset);
      int size=info.size(currentPositionToEnd);
      index++;
      currentOffset+=size;
      Slice row=currentPositionToEnd.slice(0,size);
      return new Tuple(row,info);
    }
  }
;
}
