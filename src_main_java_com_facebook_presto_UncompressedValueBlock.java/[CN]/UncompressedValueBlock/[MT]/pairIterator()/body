{
  return Iterators.peekingIterator(new AbstractIterator<Pair>(){
    private int currentOffset=0;
    private long index=0;
    @Override protected Pair computeNext(){
      if (index >= getCount()) {
        endOfData();
        return null;
      }
      Slice currentPositionToEnd=slice.slice(currentOffset,slice.length() - currentOffset);
      int size=info.size(currentPositionToEnd);
      currentOffset+=size;
      Slice row=currentPositionToEnd.slice(0,size);
      long position=index + range.getStart();
      index++;
      return new Pair(position,new Tuple(row,info));
    }
  }
);
}
