{
  checkState(!Thread.holdsLock(this),"Can not wait for state change while holding a lock on this");
synchronized (this) {
    if (!Objects.equals(state,currentState)) {
      return Futures.immediateFuture(state);
    }
    SettableFuture<T> futureStateChange=SettableFuture.create();
    futureStateChanges.add(futureStateChange);
    Futures.addCallback(futureStateChange,new FutureCallback<T>(){
      @Override public void onSuccess(      T result){
      }
      @Override public void onFailure(      Throwable t){
synchronized (StateMachine.this) {
          futureStateChanges.remove(futureStateChange);
        }
      }
    }
);
    return futureStateChange;
  }
}
