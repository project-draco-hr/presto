{
  checkState(!Thread.holdsLock(lock),"Can not wait for state change while holding the lock");
  requireNonNull(currentState,"currentState is null");
synchronized (lock) {
    if (!state.equals(currentState)) {
      return Futures.immediateFuture(state);
    }
    SettableFuture<T> futureStateChange=SettableFuture.create();
    futureStateChanges.add(futureStateChange);
    Futures.addCallback(futureStateChange,new FutureCallback<T>(){
      @Override public void onSuccess(      T result){
      }
      @Override public void onFailure(      Throwable t){
synchronized (lock) {
          futureStateChanges.remove(futureStateChange);
        }
      }
    }
);
    return futureStateChange;
  }
}
