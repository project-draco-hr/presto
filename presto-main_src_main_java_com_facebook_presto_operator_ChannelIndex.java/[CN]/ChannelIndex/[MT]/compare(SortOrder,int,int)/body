{
  long leftSliceAddress=valueAddresses.getLong(leftPosition);
  Slice leftSlice=getSliceForSyntheticAddress(leftSliceAddress);
  int leftOffset=decodePosition(leftSliceAddress);
  long rightSliceAddress=valueAddresses.getLong(rightPosition);
  Slice rightSlice=getSliceForSyntheticAddress(rightSliceAddress);
  int rightOffset=decodePosition(rightSliceAddress);
  boolean leftIsNull=tupleInfo.isNull(leftSlice,leftOffset,0);
  boolean rightIsNull=tupleInfo.isNull(rightSlice,rightOffset,0);
  if (leftIsNull && rightIsNull) {
    return 0;
  }
  if (leftIsNull) {
    return sortOrder.isNullsFirst() ? -1 : 1;
  }
  if (rightIsNull) {
    return sortOrder.isNullsFirst() ? 1 : -1;
  }
  int comparison;
switch (type) {
case BOOLEAN:
    comparison=Boolean.compare(tupleInfo.getBoolean(leftSlice,leftOffset,0),tupleInfo.getBoolean(rightSlice,rightOffset,0));
  break;
case FIXED_INT_64:
comparison=Long.compare(tupleInfo.getLong(leftSlice,leftOffset,0),tupleInfo.getLong(rightSlice,rightOffset,0));
break;
case DOUBLE:
comparison=Double.compare(tupleInfo.getDouble(leftSlice,leftOffset,0),tupleInfo.getDouble(rightSlice,rightOffset,0));
break;
case VARIABLE_BINARY:
comparison=tupleInfo.getSlice(leftSlice,leftOffset,0).compareTo(tupleInfo.getSlice(rightSlice,rightOffset,0));
break;
default :
throw new AssertionError("unimplemented type: " + type);
}
return sortOrder.isAscending() ? comparison : -comparison;
}
