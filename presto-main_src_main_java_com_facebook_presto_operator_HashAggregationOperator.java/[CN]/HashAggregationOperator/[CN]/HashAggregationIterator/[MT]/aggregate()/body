{
  if (!iterator.hasNext()) {
    return ImmutableList.<Page>of().iterator();
  }
  ImmutableList.Builder<Aggregator> builder=ImmutableList.builder();
  for (  AggregationFunctionDefinition functionDefinition : checkNotNull(functionDefinitions,"functionDefinitions is null")) {
    builder.add(createAggregator(functionDefinition,step,expectedGroups));
  }
  final List<Aggregator> aggregates=builder.build();
  SliceHashStrategy hashStrategy=new SliceHashStrategy(groupByTupleInfo);
  Long2IntOpenCustomHashMap addressToGroupId=new Long2IntOpenCustomHashMap(expectedGroups,hashStrategy);
  addressToGroupId.defaultReturnValue(-1);
  Slice slice=Slices.allocate((int)BlockBuilder.DEFAULT_MAX_BLOCK_SIZE.toBytes());
  hashStrategy.addSlice(slice);
  BlockBuilder blockBuilder=new BlockBuilder(groupByTupleInfo,slice.length(),slice.getOutput());
  int nextGroupId=0;
  List<UncompressedBlock> groupByBlocks=new ArrayList<>();
  BlockCursor[] cursors=new BlockCursor[iterator.getChannelCount()];
  while (!isMaxMemoryExceeded(hashStrategy,aggregates) && iterator.hasNext()) {
    Page page=iterator.next();
    Block[] blocks=page.getBlocks();
    Slice groupBySlice=((UncompressedBlock)blocks[groupChannel]).getSlice();
    hashStrategy.setLookupSlice(groupBySlice);
    for (int i=0; i < blocks.length; i++) {
      cursors[i]=blocks[i].cursor();
    }
    int rows=page.getPositionCount();
    for (int position=0; position < rows; position++) {
      for (      BlockCursor cursor : cursors) {
        checkState(cursor.advanceNextPosition());
      }
      int rawOffset=cursors[groupChannel].getRawOffset();
      int groupId=addressToGroupId.get(encodeSyntheticAddress(LOOKUP_SLICE_INDEX,rawOffset));
      if (groupId < 0) {
        int length=groupByTupleInfo.size(groupBySlice,rawOffset);
        if (blockBuilder.writableBytes() < length) {
          UncompressedBlock block=blockBuilder.build();
          groupByBlocks.add(block);
          slice=Slices.allocate(Math.max((int)BlockBuilder.DEFAULT_MAX_BLOCK_SIZE.toBytes(),length));
          blockBuilder=new BlockBuilder(groupByTupleInfo,slice.length(),slice.getOutput());
          hashStrategy.addSlice(slice);
        }
        int groupByValueRawOffset=blockBuilder.size();
        blockBuilder.appendTuple(groupBySlice,rawOffset,length);
        groupId=nextGroupId++;
        addressToGroupId.put(encodeSyntheticAddress(groupByBlocks.size(),groupByValueRawOffset),groupId);
        for (        Aggregator aggregate : aggregates) {
          aggregate.initialize(groupId);
        }
      }
      for (      Aggregator aggregate : aggregates) {
        aggregate.addValue(cursors,groupId);
      }
    }
    for (    BlockCursor cursor : cursors) {
      checkState(!cursor.advanceNextPosition());
    }
  }
  Preconditions.checkState(step == Step.PARTIAL || !isMaxMemoryExceeded(hashStrategy,aggregates),"Task exceeded max memory size of %s",taskMemoryManager.getMaxMemorySize());
  if (!blockBuilder.isEmpty()) {
    UncompressedBlock block=blockBuilder.build();
    groupByBlocks.add(block);
  }
  return Iterators.transform(groupByBlocks.iterator(),new Function<UncompressedBlock,Page>(){
    private int currentPosition=0;
    @Override public Page apply(    UncompressedBlock groupByBlock){
      Block[] blocks=new Block[aggregates.size() + 1];
      blocks[0]=groupByBlock;
      int pagePositionCount=blocks[0].getPositionCount();
      for (int channel=1; channel < aggregates.size() + 1; channel++) {
        Aggregator aggregator=aggregates.get(channel - 1);
        BlockBuilder blockBuilder=new BlockBuilder(aggregator.getTupleInfo());
        for (int position=0; position < pagePositionCount; position++) {
          aggregator.evaluate(currentPosition + position,blockBuilder);
        }
        blocks[channel]=blockBuilder.build();
      }
      Page page=new Page(blocks);
      currentPosition+=pagePositionCount;
      return page;
    }
  }
);
}
