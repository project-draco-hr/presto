{
  Map<Tuple,AggregationFunctionStep[]> aggregationMap=new HashMap<>();
  BlockCursor[] cursors=new BlockCursor[source.getChannelCount()];
  PageIterator iterator=source.iterator(operatorStats);
  while (iterator.hasNext()) {
    Page page=iterator.next();
    Block[] blocks=page.getBlocks();
    for (int i=0; i < blocks.length; i++) {
      cursors[i]=blocks[i].cursor();
    }
    int rows=page.getPositionCount();
    for (int position=0; position < rows; position++) {
      for (      BlockCursor cursor : cursors) {
        checkState(cursor.advanceNextPosition());
      }
      Tuple key=cursors[groupByChannel].getTuple();
      AggregationFunctionStep[] functions=aggregationMap.get(key);
      if (functions == null) {
        Preconditions.checkState(aggregationMap.size() < maxNumberOfGroups,"Query exceeded max number of aggregation groups %s",maxNumberOfGroups);
        functions=new AggregationFunctionStep[functionProviders.size()];
        for (int i=0; i < functions.length; i++) {
          functions[i]=functionProviders.get(i).get();
        }
        aggregationMap.put(key,functions);
      }
      for (      AggregationFunctionStep function : functions) {
        function.add(cursors);
      }
    }
    for (    BlockCursor cursor : cursors) {
      checkState(!cursor.advanceNextPosition());
    }
  }
  return aggregationMap;
}
