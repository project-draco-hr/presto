{
  return new AbstractIterator<Page>(){
    private final Map<Tuple,AggregationFunction[]> aggregationMap=new HashMap<>();
    private Iterator<Entry<Tuple,AggregationFunction[]>> aggregations;
    private long position;
    @Override protected Page computeNext(){
      if (aggregations == null) {
        aggregate();
      }
      if (!aggregations.hasNext()) {
        endOfData();
        return null;
      }
      BlockBuilder[] outputs=new BlockBuilder[projections.size()];
      for (int i=0; i < outputs.length; i++) {
        outputs[i]=new BlockBuilder(projections.get(i).getTupleInfo());
      }
      while (!isFull(outputs) && aggregations.hasNext()) {
        Entry<Tuple,AggregationFunction[]> aggregation=aggregations.next();
        Tuple[] results=new Tuple[functionProviders.size() + 1];
        results[0]=aggregation.getKey();
        AggregationFunction[] aggregations=aggregation.getValue();
        for (int i=1; i < results.length; i++) {
          results[i]=aggregations[i - 1].evaluate();
        }
        for (int i=0; i < projections.size(); i++) {
          projections.get(i).project(results,outputs[i]);
        }
      }
      if (outputs[0].isEmpty()) {
        return endOfData();
      }
      Block[] blocks=new Block[projections.size()];
      for (int i=0; i < blocks.length; i++) {
        blocks[i]=outputs[i].build();
      }
      Page page=new Page(blocks);
      position+=blocks[0].getPositionCount();
      return page;
    }
    private boolean isFull(    BlockBuilder... outputs){
      for (      BlockBuilder output : outputs) {
        if (output.isFull()) {
          return true;
        }
      }
      return false;
    }
    private void aggregate(){
      BlockCursor[] cursors=new BlockCursor[source.getChannelCount()];
      for (      Page page : source) {
        Block[] blocks=page.getBlocks();
        for (int i=0; i < blocks.length; i++) {
          cursors[i]=blocks[i].cursor();
        }
        int rows=page.getPositionCount();
        for (int position=0; position < rows; position++) {
          for (          BlockCursor cursor : cursors) {
            checkState(cursor.advanceNextPosition());
          }
          Tuple key=cursors[groupByChannel].getTuple();
          AggregationFunction[] functions=aggregationMap.get(key);
          if (functions == null) {
            functions=new AggregationFunction[functionProviders.size()];
            for (int i=0; i < functions.length; i++) {
              functions[i]=functionProviders.get(i).get();
            }
            aggregationMap.put(key,functions);
          }
          for (          AggregationFunction function : functions) {
            function.add(cursors);
          }
        }
        for (        BlockCursor cursor : cursors) {
          checkState(!cursor.advanceNextPosition());
        }
      }
      this.aggregations=aggregationMap.entrySet().iterator();
    }
  }
;
}
