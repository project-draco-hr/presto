{
  PlanNode source=node.getSource();
  Operator sourceOperator=plan(source);
  Map<Symbol,Integer> symbolToChannelMappings=mapSymbolsToChannels(source.getOutputSymbols());
  List<Provider<AggregationFunctionStep>> aggregationFunctions=new ArrayList<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    List<Input> arguments=new ArrayList<>();
    for (    Expression argument : entry.getValue().getArguments()) {
      int channel=symbolToChannelMappings.get(Symbol.fromQualifiedName(((QualifiedNameReference)argument).getName()));
      int field=0;
      arguments.add(new Input(channel,field));
    }
    FunctionHandle functionHandle=node.getFunctions().get(entry.getKey());
    Provider<AggregationFunction> boundFunction=metadata.getFunction(functionHandle).bind(arguments);
    Provider<AggregationFunctionStep> aggregation;
switch (node.getStep()) {
case PARTIAL:
      aggregation=AggregationFunctions.partialAggregation(boundFunction);
    break;
case FINAL:
  aggregation=AggregationFunctions.finalAggregation(boundFunction);
break;
case SINGLE:
aggregation=AggregationFunctions.singleNodeAggregation(boundFunction);
break;
default :
throw new UnsupportedOperationException("not yet implemented: " + node.getStep());
}
aggregationFunctions.add(aggregation);
}
List<ProjectionFunction> projections=new ArrayList<>();
for (int i=0; i < node.getOutputSymbols().size(); ++i) {
Symbol symbol=node.getOutputSymbols().get(i);
projections.add(ProjectionFunctions.singleColumn(types.get(symbol).getRawType(),i,0));
}
if (node.getGroupBy().isEmpty()) {
return new AggregationOperator(sourceOperator,aggregationFunctions,projections);
}
Preconditions.checkArgument(node.getGroupBy().size() <= 1,"Only single GROUP BY key supported at this time");
Symbol groupBySymbol=Iterables.getOnlyElement(node.getGroupBy());
return new HashAggregationOperator(sourceOperator,symbolToChannelMappings.get(groupBySymbol),aggregationFunctions,projections);
}
