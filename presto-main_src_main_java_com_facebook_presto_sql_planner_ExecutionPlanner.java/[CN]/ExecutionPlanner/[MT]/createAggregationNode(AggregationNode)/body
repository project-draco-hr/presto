{
  PlanNode source=Iterables.getOnlyElement(node.getSources());
  Operator sourceOperator=plan(source);
  Map<Slot,Integer> slotToChannelMappings=mapSlotsToChannels(source.getOutputs());
  List<Provider<AggregationFunctionStep>> aggregationFunctions=new ArrayList<>();
  for (  Map.Entry<Slot,FunctionCall> entry : node.getAggregations().entrySet()) {
    List<Input> arguments=new ArrayList<>();
    for (    Expression argument : entry.getValue().getArguments()) {
      Slot slot=((SlotReference)argument).getSlot();
      int channel=slotToChannelMappings.get(slot);
      int field=0;
      arguments.add(new Input(channel,field));
    }
    Provider<AggregationFunction> boundFunction=node.getFunctionInfos().get(entry.getKey()).bind(arguments);
    Provider<AggregationFunctionStep> aggregation;
switch (node.getStep()) {
case PARTIAL:
      aggregation=AggregationFunctions.partialAggregation(boundFunction);
    break;
case FINAL:
  aggregation=AggregationFunctions.finalAggregation(boundFunction);
break;
case SINGLE:
aggregation=AggregationFunctions.singleNodeAggregation(boundFunction);
break;
default :
throw new UnsupportedOperationException("not yet implemented: " + node.getStep());
}
aggregationFunctions.add(aggregation);
}
List<ProjectionFunction> projections=new ArrayList<>();
for (int i=0; i < node.getOutputs().size(); ++i) {
Slot slot=node.getOutputs().get(i);
projections.add(ProjectionFunctions.singleColumn(slot.getType().getRawType(),i,0));
}
if (node.getGroupBy().isEmpty()) {
return new AggregationOperator(sourceOperator,aggregationFunctions,projections);
}
Preconditions.checkArgument(node.getGroupBy().size() <= 1,"Only single GROUP BY key supported at this time");
Slot groupBySlot=Iterables.getOnlyElement(node.getGroupBy());
return new HashAggregationOperator(sourceOperator,slotToChannelMappings.get(groupBySlot),aggregationFunctions,projections);
}
