{
  this.recordReader=checkNotNull(recordReader,"recordReader is null");
  this.orcDataSource=checkNotNull(orcDataSource,"orcDataSource is null");
  Map<String,HivePartitionKey> partitionKeysByName=uniqueIndex(checkNotNull(partitionKeys,"partitionKeys is null"),HivePartitionKey.nameGetter());
  int size=checkNotNull(columns,"columns is null").size();
  this.isStructuralType=new boolean[size];
  this.constantBlocks=new Block[size];
  this.hiveColumnIndexes=new int[size];
  ImmutableList.Builder<String> namesBuilder=ImmutableList.builder();
  ImmutableList.Builder<Type> typesBuilder=ImmutableList.builder();
  for (int columnIndex=0; columnIndex < columns.size(); columnIndex++) {
    HiveColumnHandle column=columns.get(columnIndex);
    String name=column.getName();
    Type type=typeManager.getType(column.getTypeSignature());
    namesBuilder.add(name);
    typesBuilder.add(type);
    String typeBase=column.getTypeSignature().getBase();
    isStructuralType[columnIndex]=ARRAY.equals(typeBase) || MAP.equals(typeBase);
    hiveColumnIndexes[columnIndex]=column.getHiveColumnIndex();
    if (column.isPartitionKey()) {
      HivePartitionKey partitionKey=partitionKeysByName.get(name);
      checkArgument(partitionKey != null,"No value provided for partition key %s",name);
      byte[] bytes=partitionKey.getValue().getBytes(Charsets.UTF_8);
      BlockBuilder blockBuilder=type.createBlockBuilder(new BlockBuilderStatus());
      if (HiveUtil.isHiveNull(bytes)) {
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          blockBuilder.appendNull();
        }
      }
 else       if (type.equals(BOOLEAN)) {
        boolean value;
        if (isTrue(bytes,0,bytes.length)) {
          value=true;
        }
 else         if (isFalse(bytes,0,bytes.length)) {
          value=false;
        }
 else {
          String valueString=new String(bytes,Charsets.UTF_8);
          throw new IllegalArgumentException(String.format("Invalid partition value '%s' for BOOLEAN partition key %s",valueString,name));
        }
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          BOOLEAN.writeBoolean(blockBuilder,value);
        }
      }
 else       if (type.equals(BIGINT)) {
        if (bytes.length == 0) {
          throw new IllegalArgumentException(String.format("Invalid partition value '' for BIGINT partition key %s",name));
        }
        long value=parseLong(bytes,0,bytes.length);
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          BIGINT.writeLong(blockBuilder,value);
        }
      }
 else       if (type.equals(DOUBLE)) {
        if (bytes.length == 0) {
          throw new IllegalArgumentException(String.format("Invalid partition value '' for DOUBLE partition key %s",name));
        }
        double value=parseDouble(bytes,0,bytes.length);
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          DOUBLE.writeDouble(blockBuilder,value);
        }
      }
 else       if (type.equals(VARCHAR)) {
        Slice value=Slices.wrappedBuffer(bytes);
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          VARCHAR.writeSlice(blockBuilder,value);
        }
      }
 else       if (type.equals(DATE)) {
        long value=ISODateTimeFormat.date().withZone(DateTimeZone.UTC).parseMillis(partitionKey.getValue());
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          DATE.writeLong(blockBuilder,value);
        }
      }
 else       if (type.equals(TIMESTAMP)) {
        long value=parseHiveTimestamp(partitionKey.getValue(),hiveStorageTimeZone);
        for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
          DATE.writeLong(blockBuilder,value);
        }
      }
 else {
        throw new UnsupportedOperationException("Partition key " + name + " had an unsupported column type "+ type);
      }
      constantBlocks[columnIndex]=blockBuilder.build();
    }
 else     if (!recordReader.isColumnPresent(column)) {
      BlockBuilder blockBuilder=type.createBlockBuilder(new BlockBuilderStatus());
      for (int i=0; i < MAX_VECTOR_LENGTH; i++) {
        blockBuilder.appendNull();
      }
      constantBlocks[columnIndex]=blockBuilder.build();
    }
  }
  types=typesBuilder.build();
  columnNames=namesBuilder.build();
}
