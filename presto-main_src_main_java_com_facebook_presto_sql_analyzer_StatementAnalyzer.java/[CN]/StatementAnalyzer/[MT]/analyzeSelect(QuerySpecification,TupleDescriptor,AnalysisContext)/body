{
  ImmutableList.Builder<FieldOrExpression> outputExpressionBuilder=ImmutableList.builder();
  for (  SelectItem item : node.getSelect().getSelectItems()) {
    if (item instanceof AllColumns) {
      Optional<QualifiedName> starPrefix=((AllColumns)item).getPrefix();
      List<Field> fields=tupleDescriptor.resolveFieldsWithPrefix(starPrefix);
      if (fields.isEmpty()) {
        if (starPrefix.isPresent()) {
          throw new SemanticException(MISSING_TABLE,item,"Table '%s' not found",starPrefix.get());
        }
 else {
          throw new SemanticException(WILDCARD_WITHOUT_FROM,item,"SELECT * not allowed in queries without FROM clause");
        }
      }
      for (      Field field : fields) {
        int fieldIndex=tupleDescriptor.indexOf(field);
        outputExpressionBuilder.add(new FieldOrExpression(fieldIndex));
        if (node.getSelect().isDistinct() && !field.getType().isComparable()) {
          throw new SemanticException(TYPE_MISMATCH,node.getSelect(),"DISTINCT can only be applied to comparable types (actual: %s)",field.getType());
        }
      }
    }
 else     if (item instanceof SingleColumn) {
      SingleColumn column=(SingleColumn)item;
      ExpressionAnalysis expressionAnalysis=analyzeExpression(column.getExpression(),tupleDescriptor,context);
      analysis.addInPredicates(node,expressionAnalysis.getSubqueryInPredicates());
      outputExpressionBuilder.add(new FieldOrExpression(column.getExpression()));
      Type type=expressionAnalysis.getType(column.getExpression());
      if (node.getSelect().isDistinct() && !type.isComparable()) {
        throw new SemanticException(TYPE_MISMATCH,node.getSelect(),"DISTINCT can only be applied to comparable types (actual: %s): %s",type,column.getExpression());
      }
    }
 else {
      throw new IllegalArgumentException("Unsupported SelectItem type: " + item.getClass().getName());
    }
  }
  ImmutableList<FieldOrExpression> result=outputExpressionBuilder.build();
  analysis.setOutputExpressions(node,result);
  return result;
}
