{
  JoinCriteria criteria=node.getCriteria().orElse(null);
  if (criteria instanceof NaturalJoin) {
    throw new SemanticException(NOT_SUPPORTED,node,"Natural join not supported");
  }
  AnalysisContext leftContext=new AnalysisContext(context);
  RelationType left=process(node.getLeft(),context);
  leftContext.setLateralTupleDescriptor(left);
  RelationType right=process(node.getRight(),leftContext);
  Sets.SetView<QualifiedName> duplicateAliases=Sets.intersection(left.getRelationAliases(),right.getRelationAliases());
  if (!duplicateAliases.isEmpty()) {
    throw new SemanticException(DUPLICATE_RELATION,node,"Relations appear more than once: %s",duplicateAliases);
  }
  RelationType output=left.joinWith(right);
  if (node.getType() == Join.Type.CROSS || node.getType() == Join.Type.IMPLICIT) {
    analysis.setOutputDescriptor(node,output);
    return output;
  }
  if (criteria instanceof JoinUsing) {
    List<String> columns=((JoinUsing)criteria).getColumns();
    List<Expression> expressions=new ArrayList<>();
    for (    String column : columns) {
      Expression leftExpression=new QualifiedNameReference(QualifiedName.of(column));
      Expression rightExpression=new QualifiedNameReference(QualifiedName.of(column));
      ExpressionAnalysis leftExpressionAnalysis=analyzeExpression(leftExpression,left,context);
      ExpressionAnalysis rightExpressionAnalysis=analyzeExpression(rightExpression,right,context);
      checkState(leftExpressionAnalysis.getSubqueryInPredicates().isEmpty(),"INVARIANT");
      checkState(rightExpressionAnalysis.getSubqueryInPredicates().isEmpty(),"INVARIANT");
      addCoercionForJoinCriteria(node,leftExpression,rightExpression);
      expressions.add(new ComparisonExpression(EQUAL,leftExpression,rightExpression));
    }
    analysis.setJoinCriteria(node,ExpressionUtils.and(expressions));
  }
 else   if (criteria instanceof JoinOn) {
    Expression expression=((JoinOn)criteria).getExpression();
    ExpressionAnalyzer analyzer=ExpressionAnalyzer.create(analysis,session,metadata,sqlParser,accessControl,experimentalSyntaxEnabled);
    analyzer.analyze(expression,output,context);
    Analyzer.verifyNoAggregatesOrWindowFunctions(metadata,expression,"JOIN");
    Expression canonicalized=CanonicalizeExpressions.canonicalizeExpression(expression);
    analyzer.analyze(canonicalized,output,context);
    Object optimizedExpression=expressionOptimizer(canonicalized,metadata,session,analyzer.getExpressionTypes()).optimize(NoOpSymbolResolver.INSTANCE);
    if (!(optimizedExpression instanceof Expression) && optimizedExpression instanceof Boolean) {
      if (optimizedExpression.equals(Boolean.TRUE)) {
        optimizedExpression=new ComparisonExpression(EQUAL,new LongLiteral("0"),new LongLiteral("0"));
      }
 else {
        optimizedExpression=new ComparisonExpression(EQUAL,new LongLiteral("0"),new LongLiteral("1"));
      }
    }
    if (!(optimizedExpression instanceof Expression)) {
      throw new SemanticException(TYPE_MISMATCH,node,"Join clause must be a boolean expression");
    }
    analyzer=ExpressionAnalyzer.create(analysis,session,metadata,sqlParser,accessControl,experimentalSyntaxEnabled);
    analyzer.analyze((Expression)optimizedExpression,output,context);
    analysis.addCoercions(analyzer.getExpressionCoercions());
    for (    Expression conjunct : ExpressionUtils.extractConjuncts((Expression)optimizedExpression)) {
      conjunct=ExpressionUtils.normalize(conjunct);
      if (!(conjunct instanceof ComparisonExpression)) {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins not supported: %s",conjunct);
      }
      ComparisonExpression comparison=(ComparisonExpression)conjunct;
      Set<QualifiedName> firstDependencies=DependencyExtractor.extractNames(comparison.getLeft(),analyzer.getColumnReferences());
      Set<QualifiedName> secondDependencies=DependencyExtractor.extractNames(comparison.getRight(),analyzer.getColumnReferences());
      Expression leftExpression;
      Expression rightExpression;
      if (firstDependencies.stream().allMatch(left.canResolvePredicate()) && secondDependencies.stream().allMatch(right.canResolvePredicate())) {
        leftExpression=comparison.getLeft();
        rightExpression=comparison.getRight();
      }
 else       if (firstDependencies.stream().allMatch(right.canResolvePredicate()) && secondDependencies.stream().allMatch(left.canResolvePredicate())) {
        leftExpression=comparison.getRight();
        rightExpression=comparison.getLeft();
      }
 else {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins not supported: %s",conjunct);
      }
      ExpressionAnalysis leftExpressionAnalysis=analyzeExpression(leftExpression,left,context);
      ExpressionAnalysis rightExpressionAnalysis=analyzeExpression(rightExpression,right,context);
      addCoercionForJoinCriteria(node,leftExpression,rightExpression);
      analysis.addJoinInPredicates(node,new Analysis.JoinInPredicates(leftExpressionAnalysis.getSubqueryInPredicates(),rightExpressionAnalysis.getSubqueryInPredicates()));
    }
    analysis.setJoinCriteria(node,(Expression)optimizedExpression);
  }
 else {
    throw new UnsupportedOperationException("unsupported join criteria: " + criteria.getClass().getName());
  }
  analysis.setOutputDescriptor(node,output);
  return output;
}
