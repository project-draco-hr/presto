{
  List<SortItem> items=node.getOrderBy();
  ImmutableList.Builder<FieldOrExpression> orderByExpressionsBuilder=ImmutableList.builder();
  if (!items.isEmpty()) {
    Multimap<QualifiedName,AliasedExpression> byAlias=IterableTransformer.on(node.getSelect().getSelectItems()).select(instanceOf(AliasedExpression.class)).cast(AliasedExpression.class).index(compose(QualifiedName.fromStringFunction(),aliasGetter()));
    for (    SortItem item : items) {
      Expression expression=item.getSortKey();
      FieldOrExpression orderByExpression=null;
      if (expression instanceof QualifiedNameReference && !((QualifiedNameReference)expression).getName().getPrefix().isPresent()) {
        QualifiedName name=((QualifiedNameReference)expression).getName();
        Collection<AliasedExpression> expressions=byAlias.get(name);
        if (expressions.size() > 1) {
          throw new SemanticException(AMBIGUOUS_ATTRIBUTE,expression,"'%s' in ORDER BY is ambiguous",name.getSuffix());
        }
 else         if (expressions.size() == 1) {
          orderByExpression=new FieldOrExpression(unalias(Iterables.getOnlyElement(expressions)));
        }
      }
 else       if (expression instanceof LongLiteral) {
        long ordinal=((LongLiteral)expression).getValue();
        if (ordinal < 1 || ordinal > outputExpressions.size()) {
          throw new SemanticException(INVALID_ORDINAL,expression,"ORDER BY position %s is not in select list",ordinal);
        }
        orderByExpression=outputExpressions.get((int)(ordinal - 1));
      }
      if (orderByExpression == null) {
        orderByExpression=new FieldOrExpression(expression);
      }
      if (orderByExpression.isExpression()) {
        Analyzer.analyzeExpression(metadata,tupleDescriptor,analysis,orderByExpression.getExpression());
      }
      orderByExpressionsBuilder.add(orderByExpression);
    }
  }
  List<FieldOrExpression> orderByExpressions=orderByExpressionsBuilder.build();
  analysis.setOrderByExpressions(node,orderByExpressions);
  if (node.getSelect().isDistinct() && !outputExpressions.containsAll(orderByExpressions)) {
    throw new SemanticException(ORDER_BY_MUST_BE_IN_SELECT,node.getSelect(),"For SELECT DISTINCT, ORDER BY expressions must appear in select list");
  }
  return orderByExpressions;
}
