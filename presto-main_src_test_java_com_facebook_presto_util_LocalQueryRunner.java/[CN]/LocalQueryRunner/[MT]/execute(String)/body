{
  Statement statement=SqlParser.createStatement(sql);
  Analyzer analyzer=new Analyzer(session,metadata);
  AnalysisResult analysis=analyzer.analyze(statement);
  PlanNodeIdAllocator idAllocator=new PlanNodeIdAllocator();
  PlanNode plan=new LogicalPlanner(session,metadata,idAllocator).plan(analysis);
  new PlanPrinter().print(plan,analysis.getTypes());
  SubPlan subplan=new DistributedLogicalPlanner(metadata,idAllocator).createSubplans(plan,analysis.getSymbolAllocator(),true);
  assertTrue(subplan.getChildren().isEmpty(),"Expected subplan to have no children");
  ImmutableMap.Builder<PlanNodeId,PlanFragmentSource> builder=ImmutableMap.builder();
  for (  PlanNode source : subplan.getFragment().getSources()) {
    TableScanNode tableScan=(TableScanNode)source;
    Split split=createSplit(tableScan.getTable());
    builder.put(tableScan.getId(),new TableScanPlanFragmentSource(split));
  }
  DataSize maxOperatorMemoryUsage=new DataSize(50,MEGABYTE);
  LocalExecutionPlanner executionPlanner=new LocalExecutionPlanner(session,metadata,new HackPlanFragmentSourceProvider(dataStreamProvider,null,new QueryManagerConfig()),analysis.getTypes(),builder.build(),new OperatorStats(),new SourceHashProviderFactory(maxOperatorMemoryUsage),maxOperatorMemoryUsage);
  Operator operator=executionPlanner.plan(plan);
  return materialize(operator);
}
