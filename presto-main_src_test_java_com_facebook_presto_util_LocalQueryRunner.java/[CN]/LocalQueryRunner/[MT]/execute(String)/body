{
  Statement statement=SqlParser.createStatement(sql);
  Analyzer analyzer=new Analyzer(session,metadata);
  AnalysisResult analysis=analyzer.analyze(statement);
  PlanNodeIdAllocator idAllocator=new PlanNodeIdAllocator();
  PlanOptimizersFactory planOptimizersFactory=new PlanOptimizersFactory(metadata);
  PlanNode plan=new LogicalPlanner(session,planOptimizersFactory,idAllocator).plan(analysis);
  new PlanPrinter().print(plan,analysis.getTypes());
  SubPlan subplan=new DistributedLogicalPlanner(metadata,idAllocator).createSubplans(plan,analysis.getSymbolAllocator(),true);
  assertTrue(subplan.getChildren().isEmpty(),"Expected subplan to have no children");
  DataSize maxOperatorMemoryUsage=new DataSize(50,MEGABYTE);
  LocalExecutionPlanner executionPlanner=new LocalExecutionPlanner(session,metadata,analysis.getTypes(),new OperatorStats(),new SourceHashProviderFactory(maxOperatorMemoryUsage),maxOperatorMemoryUsage,dataStreamProvider,null);
  LocalExecutionPlan localExecutionPlan=executionPlanner.plan(subplan.getFragment().getRoot());
  Map<PlanNodeId,SourceOperator> sourceOperators=localExecutionPlan.getSourceOperators();
  for (  PlanNode source : subplan.getFragment().getSources()) {
    TableScanNode tableScan=(TableScanNode)source;
    SourceOperator sourceOperator=sourceOperators.get(tableScan.getId());
    Preconditions.checkArgument(sourceOperator != null,"Unknown plan source %s; known sources are %s",tableScan.getId(),sourceOperators.keySet());
    sourceOperator.addSplit(createSplit(tableScan.getTable()));
  }
  for (  SourceOperator sourceOperator : sourceOperators.values()) {
    sourceOperator.noMoreSplits();
  }
  return materialize(localExecutionPlan.getRootOperator());
}
