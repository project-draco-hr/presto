{
  Statement statement=SqlParser.createStatement(sql);
  if (printPlan) {
    assertFormattedSql(statement);
  }
  PlanNodeIdAllocator idAllocator=new PlanNodeIdAllocator();
  AnalyzerConfig analyzerConfig=new AnalyzerConfig().setApproximateQueriesEnabled(true);
  PlanOptimizersFactory planOptimizersFactory=new PlanOptimizersFactory(metadata,splitManager,analyzerConfig);
  QueryExplainer queryExplainer=new QueryExplainer(session,planOptimizersFactory.get(),metadata,new MockPeriodicImportManager(),new MockStorageManager(),analyzerConfig.isApproximateQueriesEnabled());
  Analyzer analyzer=new Analyzer(session,metadata,Optional.of(queryExplainer),analyzerConfig.isApproximateQueriesEnabled());
  Analysis analysis=analyzer.analyze(statement);
  Plan plan=new LogicalPlanner(session,planOptimizersFactory.get(),idAllocator,metadata,new MockPeriodicImportManager(),new MockStorageManager()).plan(analysis);
  if (printPlan) {
    System.out.println(PlanPrinter.textLogicalPlan(plan.getRoot(),plan.getTypes()));
  }
  SubPlan subplan=new DistributedLogicalPlanner(metadata,idAllocator).createSubPlans(plan,true);
  assertTrue(subplan.getChildren().isEmpty(),"Expected subplan to have no children");
  LocalExecutionPlanner executionPlanner=new LocalExecutionPlanner(new NodeInfo(new NodeConfig().setEnvironment("test").setNodeId("test-node")),metadata,dataStreamProvider,storageManager,recordSinkManager,null,compiler);
  LocalExecutionPlan localExecutionPlan=executionPlanner.plan(session,subplan.getFragment().getRoot(),plan.getTypes(),outputFactory);
  List<TaskSource> sources=new ArrayList<>();
  long sequenceId=0;
  for (  PlanNode sourceNode : subplan.getFragment().getSources()) {
    TableScanNode tableScan=(TableScanNode)sourceNode;
    SplitSource splitSource=splitManager.getPartitionSplits(tableScan.getTable(),getPartitions(tableScan));
    ImmutableSet.Builder<ScheduledSplit> scheduledSplits=ImmutableSet.builder();
    while (!splitSource.isFinished()) {
      try {
        for (        Split split : splitSource.getNextBatch(1000)) {
          scheduledSplits.add(new ScheduledSplit(sequenceId++,split));
        }
      }
 catch (      InterruptedException e) {
        Thread.currentThread().interrupt();
        throw Throwables.propagate(e);
      }
    }
    sources.add(new TaskSource(tableScan.getId(),scheduledSplits.build(),true));
  }
  List<Driver> drivers=new ArrayList<>();
  Map<PlanNodeId,Driver> driversBySource=new HashMap<>();
  for (  DriverFactory driverFactory : localExecutionPlan.getDriverFactories()) {
    DriverContext driverContext=taskContext.addPipelineContext(driverFactory.isInputDriver(),driverFactory.isOutputDriver()).addDriverContext();
    Driver driver=driverFactory.createDriver(driverContext);
    drivers.add(driver);
    for (    PlanNodeId sourceId : driver.getSourceIds()) {
      driversBySource.put(sourceId,driver);
    }
    driverFactory.close();
  }
  for (  TaskSource source : sources) {
    for (    Driver driver : driversBySource.values()) {
      driver.updateSource(source);
    }
  }
  return ImmutableList.copyOf(drivers);
}
