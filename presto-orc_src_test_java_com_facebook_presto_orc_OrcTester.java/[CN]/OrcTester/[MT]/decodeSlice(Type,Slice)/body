{
  String base=type.getTypeSignature().getBase();
  if (base.equals(ARRAY)) {
    Block block=new VariableWidthBlockEncoding().readBlock(slice.getInput());
    Type elementType=type.getTypeParameters().get(0);
    List<Object> array=new ArrayList<>();
    for (int position=0; position < block.getPositionCount(); position++) {
      array.add(getBlockValue(block,position,elementType));
    }
    return array;
  }
 else   if (base.equals(ROW)) {
    Block block=new VariableWidthBlockEncoding().readBlock(slice.getInput());
    List<Type> fieldTypes=type.getTypeParameters();
    List<Object> row=new ArrayList<>();
    for (int field=0; field < block.getPositionCount(); field++) {
      row.add(getBlockValue(block,field,fieldTypes.get(field)));
    }
    return row;
  }
 else   if (base.equals(MAP)) {
    Block block=new VariableWidthBlockEncoding().readBlock(slice.getInput());
    Type keyType=type.getTypeParameters().get(0);
    Type valueType=type.getTypeParameters().get(1);
    Map<Object,Object> map=new LinkedHashMap<>();
    int entryCount=block.getPositionCount() / 2;
    for (int entry=0; entry < entryCount; entry++) {
      int blockPosition=entry * 2;
      Object key=getBlockValue(block,blockPosition,keyType);
      if (key != null) {
        Object value=getBlockValue(block,blockPosition + 1,valueType);
        map.put(key,value);
      }
    }
    return map;
  }
  if (type.equals(VARCHAR) || type.equals(VARBINARY)) {
    return slice.toStringUtf8();
  }
  throw new IllegalArgumentException("Unsupported type: " + type);
}
