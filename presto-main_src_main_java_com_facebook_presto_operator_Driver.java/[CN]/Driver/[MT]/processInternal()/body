{
  checkLockHeld("Lock must be held to call processInternal");
  try {
    if (!newSources.isEmpty()) {
      processNewSources();
    }
    for (int i=0; i < operators.size() - 1 && !driverContext.isDone(); i++) {
      Operator current=operators.get(i);
      ListenableFuture<?> blocked=isBlocked(current);
      if (!blocked.isDone()) {
        current.getOperatorContext().recordBlocked(blocked);
        return blocked;
      }
      Operator next=operators.get(i + 1);
      blocked=isBlocked(next);
      if (!blocked.isDone()) {
        next.getOperatorContext().recordBlocked(blocked);
        return blocked;
      }
      if (!current.isFinished() && next.needsInput()) {
        current.getOperatorContext().startIntervalTimer();
        Page page=current.getOutput();
        current.getOperatorContext().recordGetOutput(page);
        if (page != null) {
          next.getOperatorContext().startIntervalTimer();
          next.addInput(page);
          next.getOperatorContext().recordAddInput(page);
        }
      }
      if (current.isFinished()) {
        next.getOperatorContext().startIntervalTimer();
        next.finish();
        next.getOperatorContext().recordFinish();
      }
    }
    return NOT_BLOCKED;
  }
 catch (  Throwable t) {
    driverContext.failed(t);
    throw t;
  }
}
