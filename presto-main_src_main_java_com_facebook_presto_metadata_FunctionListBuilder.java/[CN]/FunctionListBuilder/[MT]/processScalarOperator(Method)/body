{
  ScalarOperator scalarOperator=method.getAnnotation(ScalarOperator.class);
  if (scalarOperator == null) {
    return false;
  }
  checkValidMethod(method);
  Optional<MethodHandle> instanceFactory=getInstanceFactory(method);
  MethodHandle methodHandle=lookup().unreflect(method);
  OperatorType operatorType=scalarOperator.value();
  LiteralParameters literalParametersAnnotation=method.getAnnotation(LiteralParameters.class);
  Set<String> literalParameters=ImmutableSet.of();
  if (literalParametersAnnotation != null) {
    literalParameters=ImmutableSet.copyOf(literalParametersAnnotation.value());
  }
  List<LongVariableConstraint> longVariableConstraints=getLongVariableConstraints(method);
  List<TypeSignature> argumentTypes=parameterTypeSignatures(method,literalParameters);
  TypeSignature returnTypeSignature;
  if (operatorType == OperatorType.HASH_CODE) {
    returnTypeSignature=BIGINT.getTypeSignature();
  }
 else {
    SqlType explicitType=method.getAnnotation(SqlType.class);
    checkArgument(explicitType != null,"Method %s return type does not have a @SqlType annotation",method);
    returnTypeSignature=parseTypeSignature(explicitType.value(),literalParameters);
    verifyMethodSignature(method,returnTypeSignature,argumentTypes,typeManager);
  }
  List<Boolean> nullableArguments=getNullableArguments(method);
  operator(operatorType,ImmutableList.of(),longVariableConstraints,returnTypeSignature,argumentTypes,methodHandle,instanceFactory,method.isAnnotationPresent(Nullable.class),nullableArguments,literalParameters);
  return true;
}
