{
  for (int index=0; index < sortChannels.size(); index++) {
    int channel=sortChannels.get(index);
    SortOrder sortOrder=sortOrders.get(index);
    TupleReadable left=leftRow[channel];
    TupleReadable right=rightRow[channel];
    boolean leftIsNull=left.isNull();
    boolean rightIsNull=right.isNull();
    if (leftIsNull && rightIsNull) {
      return 0;
    }
    if (leftIsNull) {
      return sortOrder.isNullsFirst() ? -1 : 1;
    }
    if (rightIsNull) {
      return sortOrder.isNullsFirst() ? 1 : -1;
    }
    Type type=left.getTupleInfo().getType();
    int comparison;
switch (type) {
case BOOLEAN:
      comparison=Boolean.compare(left.getBoolean(),right.getBoolean());
    break;
case FIXED_INT_64:
  comparison=Long.compare(left.getLong(),right.getLong());
break;
case DOUBLE:
comparison=Double.compare(left.getDouble(),right.getDouble());
break;
case VARIABLE_BINARY:
comparison=left.getSlice().compareTo(right.getSlice());
break;
default :
throw new AssertionError("unimplemented type: " + type);
}
if (comparison != 0) {
return sortOrder.isAscending() ? comparison : -comparison;
}
}
return 0;
}
