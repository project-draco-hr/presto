{
  if (UnknownType.NAME.equals(firstType.getBase())) {
    return Optional.of(secondType);
  }
  if (UnknownType.NAME.equals(secondType.getBase())) {
    return Optional.of(firstType);
  }
  for (  String varcharSubType : new String[]{RegexpType.NAME,LikePatternType.NAME,JsonPathType.NAME}) {
    if (firstType.getBase().equals(StandardTypes.VARCHAR) && secondType.getBase().equals(varcharSubType)) {
      return Optional.of(secondType);
    }
 else     if (secondType.getBase().equals(StandardTypes.VARCHAR) && firstType.getBase().equals(varcharSubType)) {
      return Optional.of(firstType);
    }
  }
  Optional<String> commonSuperTypeBase=getCommonSuperTypeBase(firstType.getBase(),secondType.getBase());
  if (!commonSuperTypeBase.isPresent()) {
    return Optional.empty();
  }
  List<TypeSignatureParameter> firstTypeTypeParameters=firstType.getParameters();
  List<TypeSignatureParameter> secondTypeTypeParameters=secondType.getParameters();
  checkArgument(firstTypeTypeParameters.size() == secondTypeTypeParameters.size(),"Can not compare types [%s, %s] with different number of parameters. All default parameters should be expanded",firstType,secondType);
  if (firstType.getBase().equals(DECIMAL) && secondType.getBase().equals(DECIMAL)) {
    long firstPrecision=firstType.getParameters().get(0).getLongLiteral();
    long secondPrecision=secondType.getParameters().get(0).getLongLiteral();
    long firstScale=firstType.getParameters().get(1).getLongLiteral();
    long secondScale=secondType.getParameters().get(1).getLongLiteral();
    long targetScale=Math.max(firstScale,secondScale);
    long targetPrecision=Math.max(firstPrecision - firstScale,secondPrecision - secondScale) + targetScale;
    targetPrecision=Math.min(38,targetPrecision);
    return Optional.of(new TypeSignature(DECIMAL,ImmutableList.of(TypeSignatureParameter.of(targetPrecision),TypeSignatureParameter.of(targetScale))));
  }
  if (firstTypeTypeParameters.size() != secondTypeTypeParameters.size()) {
    return Optional.empty();
  }
  ImmutableList.Builder<TypeSignatureParameter> typeParameters=ImmutableList.builder();
  for (int i=0; i < firstTypeTypeParameters.size(); i++) {
    TypeSignatureParameter firstParameter=firstTypeTypeParameters.get(i);
    TypeSignatureParameter secondParameter=secondTypeTypeParameters.get(i);
    if (firstParameter.isLongLiteral() && secondParameter.isLongLiteral()) {
      typeParameters.add(TypeSignatureParameter.of(Math.max(firstParameter.getLongLiteral(),secondParameter.getLongLiteral())));
    }
 else     if (isCovariantParameterPosition(commonSuperTypeBase.get(),i)) {
      Optional<TypeSignature> firstParameterSignature=firstParameter.getTypeSignatureOrNamedTypeSignature();
      Optional<TypeSignature> secondParameterSignature=secondParameter.getTypeSignatureOrNamedTypeSignature();
      if (!firstParameterSignature.isPresent() || !secondParameterSignature.isPresent()) {
        return Optional.empty();
      }
      Optional<TypeSignature> commonSuperType=getCommonSuperTypeSignature(firstParameterSignature.get(),secondParameterSignature.get());
      if (!commonSuperType.isPresent()) {
        return Optional.empty();
      }
      typeParameters.add(TypeSignatureParameter.of(commonSuperType.get()));
    }
 else {
      if (!firstParameter.equals(secondParameter)) {
        return Optional.empty();
      }
      typeParameters.add(firstParameter);
    }
  }
  return Optional.of(new TypeSignature(commonSuperTypeBase.get(),typeParameters.build()));
}
