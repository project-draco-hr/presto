{
  Object value=process(node.getValue(),context);
  if (value == null) {
    return null;
  }
  Expression valueListExpression=node.getValueList();
  if (!(valueListExpression instanceof InListExpression)) {
    if (!optimize) {
      throw new UnsupportedOperationException("IN predicate value list type not yet implemented: " + valueListExpression.getClass().getName());
    }
    return node;
  }
  InListExpression valueList=(InListExpression)valueListExpression;
  Set<Object> set=inListCache.get(valueList);
  if (!inListCache.containsKey(valueList)) {
    if (Iterables.all(valueList.getValues(),isNonNullLiteralPredicate())) {
      set=new HashSet<>();
      for (      Expression expression : valueList.getValues()) {
        set.add(process(expression,context));
      }
    }
    inListCache.put(valueList,set);
  }
  if (set != null && !(value instanceof Expression)) {
    return set.contains(value);
  }
  boolean hasUnresolvedValue=false;
  if (value instanceof Expression) {
    hasUnresolvedValue=true;
  }
  boolean hasNullValue=false;
  boolean found=false;
  List<Object> values=new ArrayList<>(valueList.getValues().size());
  List<Type> types=new ArrayList<>(valueList.getValues().size());
  for (  Expression expression : valueList.getValues()) {
    Object inValue=process(expression,context);
    if (value instanceof Expression || inValue instanceof Expression) {
      hasUnresolvedValue=true;
      values.add(inValue);
      types.add(expressionTypes.get(expression));
      continue;
    }
    if (inValue == null) {
      hasNullValue=true;
    }
 else     if (!found && value.equals(inValue)) {
      found=true;
    }
  }
  if (found) {
    return true;
  }
  if (hasUnresolvedValue) {
    Type type=expressionTypes.get(node.getValue());
    return new InPredicate(toExpression(value,type),new InListExpression(toExpressions(values,types)));
  }
  if (hasNullValue) {
    return null;
  }
  return false;
}
