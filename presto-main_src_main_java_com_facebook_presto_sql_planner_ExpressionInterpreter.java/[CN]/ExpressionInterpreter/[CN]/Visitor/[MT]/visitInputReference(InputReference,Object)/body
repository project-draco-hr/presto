{
  Input input=node.getInput();
  int channel=input.getChannel();
  if (context instanceof TupleReadable[]) {
    TupleReadable[] inputs=(TupleReadable[])context;
    TupleReadable tuple=inputs[channel];
    int field=input.getField();
    if (tuple.isNull(field)) {
      return null;
    }
switch (tuple.getTupleInfo().getTypes().get(field)) {
case BOOLEAN:
      return tuple.getBoolean(field);
case FIXED_INT_64:
    return tuple.getLong(field);
case DOUBLE:
  return tuple.getDouble(field);
case VARIABLE_BINARY:
return tuple.getSlice(field);
default :
throw new UnsupportedOperationException("not yet implemented");
}
}
 else if (context instanceof RecordCursor) {
RecordCursor cursor=(RecordCursor)context;
checkArgument(input.getField() == 0,"Field for cursor must be 0 but is %s",input.getField());
if (cursor.isNull(channel)) {
return null;
}
switch (cursor.getType(input.getChannel())) {
case BOOLEAN:
return cursor.getBoolean(channel);
case LONG:
return cursor.getLong(channel);
case DOUBLE:
return cursor.getDouble(channel);
case STRING:
return Slices.wrappedBuffer(cursor.getString(channel));
default :
throw new UnsupportedOperationException("not yet implemented");
}
}
throw new UnsupportedOperationException("Inputs or cursor myst be set");
}
