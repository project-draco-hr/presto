{
  ExpressionAnalyzer analyzer=createConstantAnalyzer(metadata,session);
  analyzer.analyze(expression,new RelationType(),new AnalysisContext());
  Type actualType=analyzer.getExpressionTypes().get(expression);
  if (!metadata.getTypeManager().canCoerce(actualType,expectedType)) {
    throw new SemanticException(SemanticErrorCode.TYPE_MISMATCH,expression,String.format("Cannot cast type %s to %s",expectedType.getTypeSignature(),actualType.getTypeSignature()));
  }
  IdentityHashMap<Expression,Type> coercions=new IdentityHashMap<>();
  coercions.putAll(analyzer.getExpressionCoercions());
  coercions.put(expression,expectedType);
  return evaluateConstantExpression(expression,coercions,metadata,session,ImmutableSet.of());
}
