{
  requireNonNull(columnReferences,"columnReferences is null");
  expression.accept(new DefaultTraversalVisitor<Void,Void>(){
    @Override protected Void visitDereferenceExpression(    DereferenceExpression node,    Void context){
      if (columnReferences.contains(node)) {
        throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Constant expression cannot contain column references");
      }
      process(node.getBase(),context);
      return null;
    }
    @Override protected Void visitQualifiedNameReference(    QualifiedNameReference node,    Void context){
      throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Constant expression cannot contain column references");
    }
    @Override protected Void visitInputReference(    InputReference node,    Void context){
      throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Constant expression cannot contain column references");
    }
  }
,null);
  Expression rewrite=ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>(){
    @Override public Expression rewriteExpression(    Expression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      Expression rewrittenExpression=treeRewriter.defaultRewrite(node,context);
      Type coerceToType=coercions.get(node);
      if (coerceToType != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coerceToType.getTypeSignature().toString());
      }
      return rewrittenExpression;
    }
  }
,expression);
  Expression canonicalized=CanonicalizeExpressions.canonicalizeExpression(rewrite);
  ExpressionAnalyzer analyzer=createConstantAnalyzer(metadata,session);
  analyzer.analyze(canonicalized,new TupleDescriptor(),new AnalysisContext());
  Object result=expressionInterpreter(canonicalized,metadata,session,analyzer.getExpressionTypes()).evaluate(0);
  verify(!(result instanceof Expression),"Expression interpreter returned an unresolved expression");
  return result;
}
