{
  RelationPlan leftPlan=process(node.getLeft(),context);
  if (node.getRight() instanceof Unnest || (node.getRight() instanceof AliasedRelation && ((AliasedRelation)node.getRight()).getRelation() instanceof Unnest)) {
    Unnest unnest;
    if (node.getRight() instanceof AliasedRelation) {
      unnest=(Unnest)((AliasedRelation)node.getRight()).getRelation();
    }
 else {
      unnest=(Unnest)node.getRight();
    }
    if (node.getType() != Join.Type.CROSS && node.getType() != Join.Type.IMPLICIT) {
      throw new SemanticException(NOT_SUPPORTED,unnest,"UNNEST only supported on the right side of CROSS JOIN");
    }
    return planCrossJoinUnnest(leftPlan,node,unnest);
  }
  RelationPlan rightPlan=process(node.getRight(),context);
  PlanBuilder leftPlanBuilder=initializePlanBuilder(leftPlan);
  PlanBuilder rightPlanBuilder=initializePlanBuilder(rightPlan);
  RelationType outputDescriptor=analysis.getOutputDescriptor(node);
  List<Symbol> outputSymbols=ImmutableList.<Symbol>builder().addAll(leftPlan.getOutputSymbols()).addAll(rightPlan.getOutputSymbols()).build();
  ImmutableList.Builder<JoinNode.EquiJoinClause> equiClauses=ImmutableList.builder();
  List<Expression> complexJoinExpressions=new ArrayList<>();
  List<Expression> postInnerJoinConditions=new ArrayList<>();
  if (node.getType() != Join.Type.CROSS && node.getType() != Join.Type.IMPLICIT) {
    Expression criteria=analysis.getJoinCriteria(node);
    RelationType left=analysis.getOutputDescriptor(node.getLeft());
    RelationType right=analysis.getOutputDescriptor(node.getRight());
    List<Expression> leftComparisonExpressions=new ArrayList<>();
    List<Expression> rightComparisonExpressions=new ArrayList<>();
    List<ComparisonExpression.Type> joinConditionComparisonTypes=new ArrayList<>();
    for (    Expression conjunct : ExpressionUtils.extractConjuncts(criteria)) {
      conjunct=ExpressionUtils.normalize(conjunct);
      if (!isEqualComparisonExpression(conjunct) && node.getType() != INNER) {
        throw new SemanticException(NOT_SUPPORTED,node,"Non-equi joins only supported for inner join: %s",conjunct);
      }
      if (conjunct instanceof ComparisonExpression) {
        Expression firstExpression=((ComparisonExpression)conjunct).getLeft();
        Expression secondExpression=((ComparisonExpression)conjunct).getRight();
        ComparisonExpression.Type comparisonType=((ComparisonExpression)conjunct).getType();
        Set<QualifiedName> firstDependencies=DependencyExtractor.extractNames(firstExpression,analysis.getColumnReferences());
        Set<QualifiedName> secondDependencies=DependencyExtractor.extractNames(secondExpression,analysis.getColumnReferences());
        if (firstDependencies.stream().allMatch(left.canResolvePredicate()) && secondDependencies.stream().allMatch(right.canResolvePredicate())) {
          leftComparisonExpressions.add(firstExpression);
          rightComparisonExpressions.add(secondExpression);
          joinConditionComparisonTypes.add(comparisonType);
        }
 else         if (firstDependencies.stream().allMatch(right.canResolvePredicate()) && secondDependencies.stream().allMatch(left.canResolvePredicate())) {
          leftComparisonExpressions.add(secondExpression);
          rightComparisonExpressions.add(firstExpression);
          joinConditionComparisonTypes.add(comparisonType.flip());
        }
 else {
          complexJoinExpressions.add(conjunct);
        }
      }
 else {
        complexJoinExpressions.add(conjunct);
      }
    }
    Analysis.JoinInPredicates joinInPredicates=analysis.getJoinInPredicates(node);
    if (joinInPredicates != null) {
      leftPlanBuilder=appendSemiJoins(leftPlanBuilder,joinInPredicates.getLeftInPredicates());
      rightPlanBuilder=appendSemiJoins(rightPlanBuilder,joinInPredicates.getRightInPredicates());
    }
    leftPlanBuilder=appendProjections(leftPlanBuilder,leftComparisonExpressions);
    rightPlanBuilder=appendProjections(rightPlanBuilder,rightComparisonExpressions);
    for (int i=0; i < leftComparisonExpressions.size(); i++) {
      Symbol leftSymbol=leftPlanBuilder.translate(leftComparisonExpressions.get(i));
      Symbol rightSymbol=rightPlanBuilder.translate(rightComparisonExpressions.get(i));
      if (joinConditionComparisonTypes.get(i) == ComparisonExpression.Type.EQUAL) {
        equiClauses.add(new JoinNode.EquiJoinClause(leftSymbol,rightSymbol));
      }
      Expression leftExpression=leftPlanBuilder.rewrite(leftComparisonExpressions.get(i));
      Expression rightExpression=rightPlanBuilder.rewrite(rightComparisonExpressions.get(i));
      postInnerJoinConditions.add(new ComparisonExpression(joinConditionComparisonTypes.get(i),leftExpression,rightExpression));
    }
  }
  PlanNode root=new JoinNode(idAllocator.getNextId(),JoinNode.Type.typeConvert(node.getType()),leftPlanBuilder.getRoot(),rightPlanBuilder.getRoot(),equiClauses.build(),Optional.empty(),Optional.empty());
  Optional<Symbol> sampleWeight=Optional.empty();
  if (leftPlanBuilder.getSampleWeight().isPresent() || rightPlanBuilder.getSampleWeight().isPresent()) {
    Expression expression=new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Type.MULTIPLY,oneIfNull(leftPlanBuilder.getSampleWeight()),oneIfNull(rightPlanBuilder.getSampleWeight()));
    sampleWeight=Optional.of(symbolAllocator.newSymbol(expression,BIGINT));
    ImmutableMap.Builder<Symbol,Expression> projections=ImmutableMap.builder();
    projections.put(sampleWeight.get(),expression);
    for (    Symbol symbol : root.getOutputSymbols()) {
      projections.put(symbol,new QualifiedNameReference(symbol.toQualifiedName()));
    }
    root=new ProjectNode(idAllocator.getNextId(),root,projections.build());
  }
  RelationPlan intermediateRootRelationPlan=new RelationPlan(root,outputDescriptor,outputSymbols,sampleWeight);
  TranslationMap translationMap=new TranslationMap(intermediateRootRelationPlan,analysis);
  translationMap.setFieldMappings(outputSymbols);
  translationMap.putExpressionMappingsFrom(leftPlanBuilder.getTranslations());
  translationMap.putExpressionMappingsFrom(rightPlanBuilder.getTranslations());
  PlanBuilder rootPlanBuilder=new PlanBuilder(translationMap,root,sampleWeight);
  Set<InPredicate> inPredicates=analysis.getInPredicates(node);
  if (inPredicates != null) {
    rootPlanBuilder=appendSemiJoins(rootPlanBuilder,inPredicates);
  }
  for (  Expression expression : complexJoinExpressions) {
    postInnerJoinConditions.add(rootPlanBuilder.rewrite(expression));
  }
  root=rootPlanBuilder.getRoot();
  Expression postInnerJoinCriteria;
  if (!postInnerJoinConditions.isEmpty()) {
    postInnerJoinCriteria=ExpressionUtils.and(postInnerJoinConditions);
  }
 else {
    postInnerJoinCriteria=new BooleanLiteral("TRUE");
  }
  if (node.getType() == INNER) {
    root=new FilterNode(idAllocator.getNextId(),root,postInnerJoinCriteria);
  }
  return new RelationPlan(root,outputDescriptor,outputSymbols,sampleWeight);
}
