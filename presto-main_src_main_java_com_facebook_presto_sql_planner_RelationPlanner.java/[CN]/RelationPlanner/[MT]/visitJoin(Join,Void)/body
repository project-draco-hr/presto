{
  RelationPlan leftPlan=process(node.getLeft(),context);
  if (node.getRight() instanceof Unnest || (node.getRight() instanceof AliasedRelation && ((AliasedRelation)node.getRight()).getRelation() instanceof Unnest)) {
    Unnest unnest;
    if (node.getRight() instanceof AliasedRelation) {
      unnest=(Unnest)((AliasedRelation)node.getRight()).getRelation();
    }
 else {
      unnest=(Unnest)node.getRight();
    }
    if (node.getType() != Join.Type.CROSS && node.getType() != Join.Type.IMPLICIT) {
      throw new SemanticException(NOT_SUPPORTED,unnest,"UNNEST only supported on the right side of CROSS JOIN");
    }
    return planCrossJoinUnnest(leftPlan,node,unnest);
  }
  RelationPlan rightPlan=process(node.getRight(),context);
  PlanBuilder leftPlanBuilder=initializePlanBuilder(leftPlan);
  PlanBuilder rightPlanBuilder=initializePlanBuilder(rightPlan);
  TupleDescriptor outputDescriptor=analysis.getOutputDescriptor(node);
  List<Symbol> outputSymbols=ImmutableList.<Symbol>builder().addAll(leftPlan.getOutputSymbols()).addAll(rightPlan.getOutputSymbols()).build();
  ImmutableList.Builder<JoinNode.EquiJoinClause> clauses=ImmutableList.builder();
  if (node.getType() != Join.Type.CROSS && node.getType() != Join.Type.IMPLICIT) {
    List<EquiJoinClause> criteria=analysis.getJoinCriteria(node);
    Analysis.JoinInPredicates joinInPredicates=analysis.getJoinInPredicates(node);
    if (joinInPredicates != null) {
      leftPlanBuilder=appendSemiJoins(leftPlanBuilder,joinInPredicates.getLeftInPredicates());
      rightPlanBuilder=appendSemiJoins(rightPlanBuilder,joinInPredicates.getRightInPredicates());
    }
    leftPlanBuilder=appendProjections(leftPlanBuilder,Iterables.transform(criteria,leftGetter()));
    rightPlanBuilder=appendProjections(rightPlanBuilder,Iterables.transform(criteria,rightGetter()));
    for (    EquiJoinClause clause : criteria) {
      Symbol leftSymbol=leftPlanBuilder.translate(clause.getLeft());
      Symbol rightSymbol=rightPlanBuilder.translate(clause.getRight());
      clauses.add(new JoinNode.EquiJoinClause(leftSymbol,rightSymbol));
    }
  }
  PlanNode root=new JoinNode(idAllocator.getNextId(),JoinNode.Type.typeConvert(node.getType()),leftPlanBuilder.getRoot(),rightPlanBuilder.getRoot(),clauses.build());
  Optional<Symbol> sampleWeight=Optional.absent();
  if (leftPlanBuilder.getSampleWeight().isPresent() || rightPlanBuilder.getSampleWeight().isPresent()) {
    Expression expression=new ArithmeticExpression(ArithmeticExpression.Type.MULTIPLY,oneIfNull(leftPlanBuilder.getSampleWeight()),oneIfNull(rightPlanBuilder.getSampleWeight()));
    sampleWeight=Optional.of(symbolAllocator.newSymbol(expression,BIGINT));
    root=new ProjectNode(idAllocator.getNextId(),root,ImmutableMap.of(sampleWeight.get(),expression));
  }
  return new RelationPlan(root,outputDescriptor,outputSymbols,sampleWeight);
}
