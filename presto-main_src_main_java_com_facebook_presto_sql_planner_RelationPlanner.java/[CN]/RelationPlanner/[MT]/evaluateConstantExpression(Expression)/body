{
  expression.accept(new DefaultTraversalVisitor<Void,Void>(){
    @Override protected Void visitQualifiedNameReference(    QualifiedNameReference node,    Void context){
      throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Constant expression cannot contain column references");
    }
    @Override protected Void visitInputReference(    InputReference node,    Void context){
      throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Constant expression cannot contain input references");
    }
  }
,null);
  Expression rewrite=ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>(){
    @Override public Expression rewriteExpression(    Expression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      Expression rewrittenExpression=treeRewriter.defaultRewrite(node,context);
      Type coercion=analysis.getCoercion(node);
      if (coercion != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coercion.getTypeSignature().toString());
      }
      return rewrittenExpression;
    }
  }
,expression);
  try {
    Expression canonicalized=CanonicalizeExpressions.canonicalizeExpression(rewrite);
    ExpressionAnalyzer analyzer=ExpressionAnalyzer.createWithoutSubqueries(metadata.getFunctionRegistry(),metadata.getTypeManager(),session,EXPRESSION_NOT_CONSTANT,"Constant expression cannot contain as sub-query");
    analyzer.analyze(canonicalized,new TupleDescriptor(),new AnalysisContext());
    Object result=ExpressionInterpreter.expressionInterpreter(canonicalized,metadata,session,analyzer.getExpressionTypes()).evaluate(0);
    checkState(!(result instanceof Expression),"Expression interpreter returned an unresolved expression");
    return result;
  }
 catch (  Exception e) {
    throw new SemanticException(EXPRESSION_NOT_CONSTANT,expression,"Error evaluating constant expression: %s",e.getMessage());
  }
}
