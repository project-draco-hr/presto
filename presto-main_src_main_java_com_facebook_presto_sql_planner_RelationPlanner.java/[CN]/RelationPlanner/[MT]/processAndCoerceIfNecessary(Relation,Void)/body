{
  Type[] coerceToTypes=analysis.getRelationCoercion(node);
  RelationPlan plan=node.accept(this,context);
  if (coerceToTypes == null) {
    return plan;
  }
  List<Symbol> oldSymbols=plan.getRoot().getOutputSymbols();
  TupleDescriptor oldDescriptor=plan.getDescriptor().withOnlyVisibleFields();
  checkArgument(coerceToTypes.length == oldSymbols.size());
  ImmutableList.Builder<Symbol> newSymbols=new ImmutableList.Builder<>();
  Field[] newFields=new Field[coerceToTypes.length];
  ImmutableMap.Builder<Symbol,Expression> assignments=new ImmutableMap.Builder<>();
  for (int i=0; i < coerceToTypes.length; i++) {
    Symbol inputSymbol=oldSymbols.get(i);
    Type inputType=symbolAllocator.getTypes().get(inputSymbol);
    Type outputType=coerceToTypes[i];
    if (outputType != inputType) {
      Cast cast=new Cast(new QualifiedNameReference(inputSymbol.toQualifiedName()),outputType.getTypeSignature().toString());
      Symbol outputSymbol=symbolAllocator.newSymbol(cast,outputType);
      assignments.put(outputSymbol,cast);
      newSymbols.add(outputSymbol);
    }
 else {
      assignments.put(inputSymbol,new QualifiedNameReference(inputSymbol.toQualifiedName()));
      newSymbols.add(inputSymbol);
    }
    Field oldField=oldDescriptor.getFieldByIndex(i);
    newFields[i]=new Field(oldField.getRelationAlias(),oldField.getName(),coerceToTypes[i],oldField.isHidden());
  }
  ProjectNode projectNode=new ProjectNode(idAllocator.getNextId(),plan.getRoot(),assignments.build());
  return new RelationPlan(projectNode,new TupleDescriptor(newFields),newSymbols.build(),plan.getSampleWeight());
}
