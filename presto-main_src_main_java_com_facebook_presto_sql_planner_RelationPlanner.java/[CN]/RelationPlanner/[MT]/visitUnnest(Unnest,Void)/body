{
  TupleDescriptor descriptor=analysis.getOutputDescriptor(node);
  ImmutableList.Builder<Symbol> outputSymbolsBuilder=ImmutableList.builder();
  for (  Field field : descriptor.getVisibleFields()) {
    Symbol symbol=symbolAllocator.newSymbol(field);
    outputSymbolsBuilder.add(symbol);
  }
  List<Symbol> unnestedSymbols=outputSymbolsBuilder.build();
  ImmutableList.Builder<Symbol> argumentSymbols=ImmutableList.builder();
  ImmutableList.Builder<Expression> values=ImmutableList.builder();
  ImmutableMap.Builder<Symbol,List<Symbol>> unnestSymbols=ImmutableMap.builder();
  Iterator<Symbol> unnestedSymbolsIterator=unnestedSymbols.iterator();
  for (  Expression expression : node.getExpressions()) {
    values.add(evaluateConstantExpression(expression));
    Type type=analysis.getType(expression);
    Symbol inputSymbol=symbolAllocator.newSymbol(expression,type);
    argumentSymbols.add(inputSymbol);
    if (type instanceof ArrayType) {
      unnestSymbols.put(inputSymbol,ImmutableList.of(unnestedSymbolsIterator.next()));
    }
 else     if (type instanceof MapType) {
      unnestSymbols.put(inputSymbol,ImmutableList.of(unnestedSymbolsIterator.next(),unnestedSymbolsIterator.next()));
    }
 else {
      throw new IllegalArgumentException("Unsupported type for UNNEST: " + type);
    }
  }
  checkState(!unnestedSymbolsIterator.hasNext(),"Not all output symbols were matched with input symbols");
  ValuesNode valuesNode=new ValuesNode(idAllocator.getNextId(),argumentSymbols.build(),ImmutableList.<List<Expression>>of(values.build()));
  UnnestNode unnestNode=new UnnestNode(idAllocator.getNextId(),valuesNode,ImmutableList.<Symbol>of(),unnestSymbols.build());
  return new RelationPlan(unnestNode,descriptor,unnestedSymbols,Optional.<Symbol>absent());
}
