{
  Preconditions.checkNotNull(session,"session is null");
  return new AbstractBlockIterator<MaskedBlock>(){
    Iterator<? extends TupleStream> valueBlocks=source.iterator(session);
    Cursor positionsCursor=positions.cursor(session);
{
      Cursors.advanceNextPositionNoYield(positionsCursor);
    }
    @Override protected MaskedBlock computeNext(){
      while (valueBlocks.hasNext()) {
        TupleStream currentValueBlock=valueBlocks.next();
        if (positionsCursor.getPosition() < currentValueBlock.getRange().getStart() && !Cursors.advanceToPositionNoYield(positionsCursor,currentValueBlock.getRange().getStart())) {
          endOfData();
          return null;
        }
        if (positionsCursor.getPosition() > currentValueBlock.getRange().getEnd()) {
          continue;
        }
        ImmutableList.Builder<Long> positionsForCurrentBlock=ImmutableList.builder();
        do {
          positionsForCurrentBlock.add(positionsCursor.getPosition());
        }
 while (Cursors.advanceNextPositionNoYield(positionsCursor) && positionsCursor.getPosition() <= currentValueBlock.getRange().getEnd());
        List<Long> validPositions=getValidPositions(currentValueBlock,positionsForCurrentBlock.build());
        if (!validPositions.isEmpty()) {
          return new MaskedBlock(currentValueBlock,validPositions);
        }
      }
      endOfData();
      return null;
    }
    private List<Long> getValidPositions(    TupleStream currentValueBlock,    List<Long> positionsForCurrentBlock){
      ImmutableList.Builder<Long> validPositions=ImmutableList.builder();
      Cursor valueCursor=currentValueBlock.cursor(session);
      valueCursor.advanceNextPosition();
      for (      Long nextPosition : positionsForCurrentBlock) {
        if (nextPosition > valueCursor.getRange().getEnd()) {
          break;
        }
        if (nextPosition > valueCursor.getPosition()) {
          valueCursor.advanceToPosition(nextPosition);
        }
        if (valueCursor.getPosition() == nextPosition) {
          validPositions.add(nextPosition);
        }
      }
      return validPositions.build();
    }
  }
;
}
