{
  if (!finishing) {
    int i;
    for (i=0; i < ROWS_PER_REQUEST; i++) {
      if (pageBuilder.isFull()) {
        break;
      }
      if (!cursor.advanceNextPosition()) {
        finishing=true;
        break;
      }
      for (int column=0; column < types.size(); column++) {
        BlockBuilder output=pageBuilder.getBlockBuilder(column);
        if (cursor.isNull(column)) {
          output.appendNull();
        }
 else {
          Type type=getTypes().get(column);
switch (type.toColumnType()) {
case BOOLEAN:
            output.append(cursor.getBoolean(column));
          break;
case LONG:
        output.append(cursor.getLong(column));
      break;
case DOUBLE:
    output.append(cursor.getDouble(column));
  break;
case STRING:
output.append(cursor.getString(column));
break;
default :
throw new AssertionError("unimplemented type: " + type);
}
}
}
}
long bytesProcessed=cursor.getCompletedBytes() - completedBytes;
long endReadTimeNanos=cursor.getReadTimeNanos();
operatorContext.recordGeneratedInput(new DataSize(bytesProcessed,BYTE),i,endReadTimeNanos - readTimeNanos);
completedBytes+=bytesProcessed;
readTimeNanos=endReadTimeNanos;
}
if (pageBuilder.isEmpty() || (!finishing && !pageBuilder.isFull())) {
return null;
}
Page page=pageBuilder.build();
pageBuilder.reset();
operatorContext.recordGeneratedInput(page.getDataSize(),page.getPositionCount());
return page;
}
