{
  if (!finishing) {
    RecordCursor cursor=getCursor();
    int i=0;
    for (; i < ROWS_PER_REQUEST; i++) {
      if (pageBuilder.isFull()) {
        break;
      }
      if (!cursor.advanceNextPosition()) {
        finishing=true;
        break;
      }
      for (int column=0; column < tupleInfos.size(); column++) {
        BlockBuilder output=pageBuilder.getBlockBuilder(column);
        if (cursor.isNull(column)) {
          output.appendNull();
        }
 else {
          Type type=getTupleInfos().get(column).getTypes().get(0);
switch (type) {
case BOOLEAN:
            output.append(cursor.getBoolean(column));
          break;
case FIXED_INT_64:
        output.append(cursor.getLong(column));
      break;
case DOUBLE:
    output.append(cursor.getDouble(column));
  break;
case VARIABLE_BINARY:
output.append(cursor.getString(column));
break;
default :
throw new AssertionError("unimplemented type: " + type);
}
}
}
}
long bytesProcessed=cursor.getCompletedBytes() - completedBytes;
operatorContext.recordGeneratedInput(new DataSize(bytesProcessed,BYTE),i);
completedBytes+=bytesProcessed;
}
if (pageBuilder.isEmpty() || (!finishing && !pageBuilder.isFull())) {
return null;
}
Page page=pageBuilder.build();
pageBuilder.reset();
return page;
}
