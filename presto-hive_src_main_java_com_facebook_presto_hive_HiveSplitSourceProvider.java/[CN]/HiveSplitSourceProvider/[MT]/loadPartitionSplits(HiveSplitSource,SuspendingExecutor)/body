{
  final Semaphore semaphore=new Semaphore(maxPartitionBatchSize);
  try (ThreadContextClassLoader ignored=new ThreadContextClassLoader(classLoader)){
    ImmutableList.Builder<ListenableFuture<Void>> futureBuilder=ImmutableList.builder();
    Iterator<String> nameIterator=partitionNames.iterator();
    for (    Partition partition : partitions) {
      checkState(nameIterator.hasNext(),"different number of partitions and partition names!");
      semaphore.acquire();
      final String partitionName=nameIterator.next();
      final Properties schema=getPartitionSchema(table,partition);
      final List<HivePartitionKey> partitionKeys=getPartitionKeys(table,partition);
      Path path=new Path(getPartitionLocation(table,partition));
      final Configuration configuration=hdfsEnvironment.getConfiguration(path);
      final InputFormat<?,?> inputFormat=getInputFormat(configuration,schema,false);
      FileSystem fs=path.getFileSystem(configuration);
      final LastSplitMarkingQueue markerQueue=new LastSplitMarkingQueue(hiveSplitSource);
      if (inputFormat instanceof SymlinkTextInputFormat) {
        JobConf jobConf=new JobConf(configuration);
        FileInputFormat.setInputPaths(jobConf,path);
        InputSplit[] splits=inputFormat.getSplits(jobConf,0);
        for (        InputSplit rawSplit : splits) {
          FileSplit split=((SymlinkTextInputFormat.SymlinkTextInputSplit)rawSplit).getTargetSplit();
          FileSystem targetFilesystem=split.getPath().getFileSystem(configuration);
          FileStatus fileStatus=targetFilesystem.getFileStatus(split.getPath());
          markerQueue.addToQueue(createHiveSplits(partitionName,fileStatus,targetFilesystem.getFileBlockLocations(fileStatus,split.getStart(),split.getLength()),split.getStart(),split.getLength(),schema,partitionKeys,false));
        }
        markerQueue.finish();
        continue;
      }
      if (bucket.isPresent()) {
        Optional<FileStatus> bucketFile=getBucketFile(bucket.get(),fs,path);
        if (bucketFile.isPresent()) {
          FileStatus file=bucketFile.get();
          BlockLocation[] blockLocations=fs.getFileBlockLocations(file,0,file.getLen());
          boolean splittable=isSplittable(inputFormat,fs,file.getPath());
          markerQueue.addToQueue(createHiveSplits(partitionName,file,blockLocations,0,file.getLen(),schema,partitionKeys,splittable));
          markerQueue.finish();
          continue;
        }
      }
      ListenableFuture<Void> partitionFuture=new AsyncRecursiveWalker(fs,suspendingExecutor).beginWalk(path,new FileStatusCallback(){
        @Override public void process(        FileStatus file,        BlockLocation[] blockLocations){
          try {
            boolean splittable=isSplittable(inputFormat,file.getPath().getFileSystem(configuration),file.getPath());
            markerQueue.addToQueue(createHiveSplits(partitionName,file,blockLocations,0,file.getLen(),schema,partitionKeys,splittable));
          }
 catch (          IOException e) {
            hiveSplitSource.fail(e);
          }
        }
      }
);
      Futures.addCallback(partitionFuture,new FutureCallback<Void>(){
        @Override public void onSuccess(        Void result){
          semaphore.release();
          markerQueue.finish();
        }
        @Override public void onFailure(        Throwable t){
          semaphore.release();
          markerQueue.finish();
        }
      }
);
      futureBuilder.add(partitionFuture);
    }
    Futures.addCallback(Futures.allAsList(futureBuilder.build()),new FutureCallback<List<Void>>(){
      @Override public void onSuccess(      List<Void> result){
        hiveSplitSource.finished();
      }
      @Override public void onFailure(      Throwable t){
        hiveSplitSource.fail(t);
      }
    }
);
  }
 catch (  Throwable e) {
    hiveSplitSource.fail(e);
    Throwables.propagateIfInstanceOf(e,Error.class);
  }
}
