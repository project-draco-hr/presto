{
  checkArgument(normalized.getValue().getType().equals(DOUBLE),"Value should be of DOUBLE type");
  checkArgument(!normalized.getValue().isNull(),"Value should not be null");
  QualifiedNameReference reference=normalized.getNameReference();
  Double value=(Double)normalized.getValue().getValue();
switch (normalized.getComparisonType()) {
case GREATER_THAN_OR_EQUAL:
case LESS_THAN:
    return new ComparisonExpression(normalized.getComparisonType(),reference,toExpression(DoubleMath.roundToLong(value,CEILING),BIGINT));
case GREATER_THAN:
case LESS_THAN_OR_EQUAL:
  return new ComparisonExpression(normalized.getComparisonType(),reference,toExpression(DoubleMath.roundToLong(value,FLOOR),BIGINT));
case EQUAL:
Long equalValue=DoubleMath.roundToLong(value,FLOOR);
if (equalValue.doubleValue() != value) {
return and(new ComparisonExpression(EQUAL,reference,new LongLiteral("0")),new ComparisonExpression(NOT_EQUAL,reference,new LongLiteral("0")));
}
return new ComparisonExpression(normalized.getComparisonType(),reference,toExpression(equalValue,BIGINT));
case NOT_EQUAL:
Long notEqualValue=DoubleMath.roundToLong(value,FLOOR);
if (notEqualValue.doubleValue() != value) {
return or(new ComparisonExpression(EQUAL,reference,new LongLiteral("0")),new ComparisonExpression(NOT_EQUAL,reference,new LongLiteral("0")));
}
return new ComparisonExpression(normalized.getComparisonType(),reference,toExpression(notEqualValue,BIGINT));
case IS_DISTINCT_FROM:
Long distinctValue=DoubleMath.roundToLong(value,FLOOR);
if (distinctValue.doubleValue() != value) {
return TRUE_LITERAL;
}
return new ComparisonExpression(normalized.getComparisonType(),reference,toExpression(distinctValue,BIGINT));
default :
throw new AssertionError("Unhandled type: " + normalized.getComparisonType());
}
}
