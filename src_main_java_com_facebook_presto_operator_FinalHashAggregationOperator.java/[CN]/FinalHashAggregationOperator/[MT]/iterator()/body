{
  final Cursor cursor=groupBySource.cursor();
  return new AbstractBlockIterator<UncompressedBlock>(){
    private final Map<Tuple,AggregationFunction> aggregationMap=new HashMap<>();
    private Iterator<Entry<Tuple,AggregationFunction>> aggregations;
    private long position;
    @Override protected UncompressedBlock computeNext(){
      if (aggregations == null) {
        while (!cursor.isFinished()) {
          AdvanceResult result=cursor.advanceNextValue();
          if (result != AdvanceResult.SUCCESS) {
            if (result == MUST_YIELD) {
              return setMustYield();
            }
 else             if (result == AdvanceResult.FINISHED) {
              break;
            }
          }
          Tuple key=getKey();
          AggregationFunction aggregation=aggregationMap.get(key);
          if (aggregation == null) {
            aggregation=functionProvider.get();
            aggregationMap.put(key,aggregation);
          }
          aggregation.addCurrentPosition(cursor);
        }
        this.aggregations=aggregationMap.entrySet().iterator();
      }
      if (!aggregations.hasNext()) {
        endOfData();
        return null;
      }
      BlockBuilder blockBuilder=new BlockBuilder(position,info);
      while (!blockBuilder.isFull() && aggregations.hasNext()) {
        Entry<Tuple,AggregationFunction> aggregation=aggregations.next();
        Tuple key=aggregation.getKey();
        Tuple value=aggregation.getValue().evaluate();
        blockBuilder.append(key);
        blockBuilder.append(value);
      }
      UncompressedBlock block=blockBuilder.build();
      position+=block.getCount();
      return block;
    }
    private Tuple getKey(){
      TupleInfo.Builder keyBuilder=groupByTypeInfo.builder();
      for (int field=0; field < groupByTypeInfo.getFieldCount(); field++) {
        Type type=groupByTypeInfo.getTypes().get(field);
switch (type) {
case FIXED_INT_64:
          keyBuilder.append(cursor.getLong(field));
        break;
case DOUBLE:
      keyBuilder.append(cursor.getDouble(field));
    break;
case VARIABLE_BINARY:
  Slice data=cursor.getSlice(field);
keyBuilder.append(data);
break;
default :
throw new IllegalStateException("Type not yet supported: " + type);
}
}
return keyBuilder.build();
}
}
;
}
