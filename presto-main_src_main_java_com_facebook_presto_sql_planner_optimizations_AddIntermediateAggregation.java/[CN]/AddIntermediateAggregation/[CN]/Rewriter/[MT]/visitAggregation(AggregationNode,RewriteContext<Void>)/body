{
  if (node.getStep() != PARTIAL || node.getGroupBy().isEmpty()) {
    return context.defaultRewrite(node);
  }
  PlanNode rewrittenSource=context.defaultRewrite(node.getSource());
  Map<Symbol,Symbol> masks=node.getMasks();
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> initialCalls=new HashMap<>();
  Map<Symbol,Signature> initialFunctions=new HashMap<>();
  Map<Symbol,Symbol> initialMask=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    Signature signature=node.getFunctions().get(entry.getKey());
    InternalAggregationFunction function=metadata.getFunctionRegistry().getAggregateFunctionImplementation(signature);
    Symbol initialSymbol=symbolAllocator.newSymbol(signature.getName(),function.getIntermediateType());
    initialCalls.put(initialSymbol,entry.getValue());
    initialFunctions.put(initialSymbol,signature);
    if (masks.containsKey(entry.getKey())) {
      initialMask.put(initialSymbol,masks.get(entry.getKey()));
    }
    finalCalls.put(entry.getKey(),new FunctionCall(QualifiedName.of(signature.getName()),ImmutableList.<Expression>of(new QualifiedNameReference(initialSymbol.toQualifiedName()))));
  }
  PlanNode partialAggregation=new AggregationNode(idAllocator.getNextId(),rewrittenSource,node.getGroupBy(),initialCalls,initialFunctions,initialMask,node.getGroupingSets(),PARTIAL,node.getSampleWeight(),node.getConfidence(),node.getHashSymbol());
  return new AggregationNode(idAllocator.getNextId(),partialAggregation,node.getGroupBy(),finalCalls,node.getFunctions(),ImmutableMap.of(),node.getGroupingSets(),INTERMEDIATE,Optional.empty(),node.getConfidence(),node.getHashSymbol());
}
