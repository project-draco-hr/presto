{
  Map<Symbol,Symbol> masks=node.getMasks();
  Map<Symbol,FunctionCall> finalCalls=new HashMap<>();
  Map<Symbol,FunctionCall> intermediateCalls=new HashMap<>();
  Map<Symbol,Signature> intermediateFunctions=new HashMap<>();
  Map<Symbol,Symbol> intermediateMask=new HashMap<>();
  for (  Map.Entry<Symbol,FunctionCall> entry : node.getAggregations().entrySet()) {
    Signature signature=node.getFunctions().get(entry.getKey());
    InternalAggregationFunction function=metadata.getFunctionRegistry().getAggregateFunctionImplementation(signature);
    Symbol intermediateSymbol=symbolAllocator.newSymbol(signature.getName(),function.getIntermediateType());
    intermediateCalls.put(intermediateSymbol,entry.getValue());
    intermediateFunctions.put(intermediateSymbol,signature);
    if (masks.containsKey(entry.getKey())) {
      intermediateMask.put(intermediateSymbol,masks.get(entry.getKey()));
    }
    finalCalls.put(entry.getKey(),new FunctionCall(QualifiedName.of(signature.getName()),ImmutableList.<Expression>of(new QualifiedNameReference(intermediateSymbol.toQualifiedName()))));
  }
  PlanWithProperties source=deriveProperties(new AggregationNode(idAllocator.getNextId(),newChild.getNode(),node.getGroupBy(),intermediateCalls,intermediateFunctions,intermediateMask,node.getGroupingSets(),Step.PARTIAL,node.getSampleWeight(),node.getConfidence(),node.getHashSymbol()),newChild.getProperties());
  if (exchanger != null) {
    source=deriveProperties(exchanger.apply(source.getNode()),source.getProperties());
  }
  return deriveProperties(new AggregationNode(node.getId(),source.getNode(),node.getGroupBy(),finalCalls,node.getFunctions(),ImmutableMap.of(),node.getGroupingSets(),Step.FINAL,Optional.empty(),node.getConfidence(),node.getHashSymbol()),source.getProperties());
}
