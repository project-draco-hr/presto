{
  this.id=checkNotNull(id,"id is null");
  this.root=checkNotNull(root,"root is null");
  this.symbols=checkNotNull(symbols,"symbols is null");
  this.distribution=checkNotNull(distribution,"distribution is null");
  this.partitionedSource=partitionedSource;
  this.partitionBy=ImmutableList.copyOf(checkNotNull(partitionBy,"partitionBy is null"));
  tupleInfos=IterableTransformer.on(root.getOutputSymbols()).transform(Functions.forMap(symbols)).transform(Type.toRaw()).transform(new Function<TupleInfo.Type,TupleInfo>(){
    @Override public TupleInfo apply(    TupleInfo.Type input){
      return new TupleInfo(input);
    }
  }
).list();
  ImmutableList.Builder<PlanNode> sources=ImmutableList.builder();
  findSources(root,sources,partitionedSource);
  this.sources=sources.build();
  ImmutableSet.Builder<PlanNodeId> sourceIds=ImmutableSet.builder();
  for (  PlanNode source : this.sources) {
    sourceIds.add(source.getId());
  }
  if (partitionedSource != null) {
    sourceIds.add(partitionedSource);
  }
  this.sourceIds=sourceIds.build();
  this.outputPartitioning=checkNotNull(outputPartitioning,"outputPartitioning is null");
}
