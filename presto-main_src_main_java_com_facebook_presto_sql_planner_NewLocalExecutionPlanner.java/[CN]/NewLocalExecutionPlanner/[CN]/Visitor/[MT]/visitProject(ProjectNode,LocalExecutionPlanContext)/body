{
  PhysicalOperation source;
  Expression filterExpression;
  if (node.getSource() instanceof FilterNode) {
    FilterNode filterNode=(FilterNode)node.getSource();
    source=filterNode.getSource().accept(this,context);
    filterExpression=filterNode.getPredicate();
  }
 else {
    source=node.getSource().accept(this,context);
    filterExpression=BooleanLiteral.TRUE_LITERAL;
  }
  List<Expression> expressions=node.getExpressions();
  Map<Input,Type> inputTypes=null;
  FilterFunction filter;
  if (filterExpression != BooleanLiteral.TRUE_LITERAL) {
    filter=new InterpretedFilterFunction(filterExpression,convertLayoutToInputMap(source.getLayout()),metadata,context.getSession(),inputTypes);
  }
 else {
    filter=FilterFunctions.TRUE_FUNCTION;
  }
  ImmutableMultimap.Builder<Symbol,Input> outputMappings=ImmutableMultimap.builder();
  List<ProjectionFunction> projections=new ArrayList<>();
  for (int i=0; i < expressions.size(); i++) {
    Symbol symbol=node.getOutputSymbols().get(i);
    Expression expression=expressions.get(i);
    ProjectionFunction function;
    if (expression instanceof QualifiedNameReference) {
      Symbol reference=Symbol.fromQualifiedName(((QualifiedNameReference)expression).getName());
      function=ProjectionFunctions.singleColumn(context.getTypes().get(reference).getRawType(),getFirst(source.getLayout().get(symbol)));
    }
 else {
      function=new InterpretedProjectionFunction(context.getTypes().get(symbol),expression,convertLayoutToInputMap(source.getLayout()),metadata,context.getSession(),inputTypes);
    }
    projections.add(function);
    outputMappings.put(symbol,new Input(i,0));
  }
  NewOperatorFactory operatorFactory=new NewFilterAndProjectOperatorFactory(context.getNextOperatorId(),filter,projections);
  return new PhysicalOperation(operatorFactory,outputMappings.build(),source);
}
