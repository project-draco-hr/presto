{
  Set<Expression> scopeEqualities=new HashSet<>();
  Set<Expression> scopeComplementEqualities=new HashSet<>();
  Set<Expression> scopeStraddlingEqualities=new HashSet<>();
  for (  Collection<Expression> equalitySet : equalitySets.asMap().values()) {
    Set<Expression> scopeExpressions=new HashSet<>();
    Set<Expression> scopeComplementExpressions=new HashSet<>();
    Set<Expression> scopeStraddlingExpressions=new HashSet<>();
    for (    Expression expression : equalitySet) {
      Expression scopeRewritten=rewriteExpression(expression,symbolScope,false);
      if (scopeRewritten != null) {
        scopeExpressions.add(scopeRewritten);
      }
      Expression scopeComplementRewritten=rewriteExpression(expression,not(symbolScope),false);
      if (scopeComplementRewritten != null) {
        scopeComplementExpressions.add(scopeComplementRewritten);
      }
      if (scopeRewritten == null && scopeComplementRewritten == null) {
        scopeStraddlingExpressions.add(expression);
      }
    }
    Expression matchingCanonical=getCanonical(scopeExpressions);
    if (scopeExpressions.size() >= 2) {
      for (      Expression expression : filter(scopeExpressions,not(equalTo(matchingCanonical)))) {
        scopeEqualities.add(new ComparisonExpression(ComparisonExpression.Type.EQUAL,matchingCanonical,expression));
      }
    }
    Expression complementCanonical=getCanonical(scopeComplementExpressions);
    if (scopeComplementExpressions.size() >= 2) {
      for (      Expression expression : filter(scopeComplementExpressions,not(equalTo(complementCanonical)))) {
        scopeComplementEqualities.add(new ComparisonExpression(ComparisonExpression.Type.EQUAL,complementCanonical,expression));
      }
    }
    List<Expression> connectingExpressions=new ArrayList<>();
    connectingExpressions.add(matchingCanonical);
    connectingExpressions.add(complementCanonical);
    connectingExpressions.addAll(scopeStraddlingExpressions);
    connectingExpressions=ImmutableList.copyOf(filter(connectingExpressions,Predicates.notNull()));
    Expression connectingCanonical=getCanonical(connectingExpressions);
    if (connectingCanonical != null) {
      for (      Expression expression : filter(connectingExpressions,not(equalTo(connectingCanonical)))) {
        scopeStraddlingEqualities.add(new ComparisonExpression(ComparisonExpression.Type.EQUAL,connectingCanonical,expression));
      }
    }
  }
  return new EqualityPartition(scopeEqualities,scopeComplementEqualities,scopeStraddlingEqualities);
}
