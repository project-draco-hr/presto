{
  checkState(node.getOutputSymbols().containsAll(context.getLookupSymbols()));
  Set<ColumnHandle> lookupColumns=FluentIterable.from(context.getLookupSymbols()).transform(Functions.forMap(node.getAssignments())).toSet();
  checkState(node.getGeneratedPartitions().isPresent(),"Predicate should have generated partitions before this optimizer");
  TupleDomain tupleDomain=node.getGeneratedPartitions().get().getTupleDomainInput();
  Optional<ResolvedIndex> optionalResolvedIndex=indexManager.resolveIndex(node.getTable(),lookupColumns,tupleDomain);
  if (!optionalResolvedIndex.isPresent()) {
    return node;
  }
  ResolvedIndex resolvedIndex=optionalResolvedIndex.get();
  Map<ColumnHandle,Symbol> inverseAssignments=ImmutableBiMap.copyOf(node.getAssignments()).inverse();
  Expression unresolvedExpression=DomainTranslator.toPredicate(resolvedIndex.getUnresolvedTupleDomain(),inverseAssignments,symbolAllocator.getTypes());
  PlanNode source=new IndexSourceNode(idAllocator.getNextId(),resolvedIndex.getIndexHandle(),node.getTable(),context.getLookupSymbols(),node.getOutputSymbols(),node.getAssignments(),tupleDomain);
  if (!unresolvedExpression.equals(TRUE_LITERAL)) {
    source=new FilterNode(idAllocator.getNextId(),source,unresolvedExpression);
  }
  context.markSuccess();
  return source;
}
