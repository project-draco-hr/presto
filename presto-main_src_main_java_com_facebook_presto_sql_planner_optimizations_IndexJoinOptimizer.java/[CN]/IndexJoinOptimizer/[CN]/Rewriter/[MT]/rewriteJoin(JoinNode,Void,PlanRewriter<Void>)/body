{
  PlanNode leftRewritten=planRewriter.rewrite(node.getLeft(),context);
  PlanNode rightRewritten=planRewriter.rewrite(node.getRight(),context);
  if (!node.getCriteria().isEmpty()) {
    List<Symbol> leftJoinSymbols=Lists.transform(node.getCriteria(),leftGetter());
    List<Symbol> rightJoinSymbols=Lists.transform(node.getCriteria(),rightGetter());
    Optional<PlanNode> leftIndexCandidate=IndexSourceRewriter.rewriteWithIndex(leftRewritten,ImmutableSet.copyOf(leftJoinSymbols),indexManager,symbolAllocator,idAllocator);
    if (leftIndexCandidate.isPresent()) {
      Map<Symbol,Symbol> trace=IndexKeyTracer.trace(leftIndexCandidate.get(),ImmutableSet.copyOf(leftJoinSymbols));
      checkState(!trace.isEmpty() && leftJoinSymbols.containsAll(trace.keySet()));
    }
    Optional<PlanNode> rightIndexCandidate=IndexSourceRewriter.rewriteWithIndex(rightRewritten,ImmutableSet.copyOf(rightJoinSymbols),indexManager,symbolAllocator,idAllocator);
    if (rightIndexCandidate.isPresent()) {
      Map<Symbol,Symbol> trace=IndexKeyTracer.trace(rightIndexCandidate.get(),ImmutableSet.copyOf(rightJoinSymbols));
      checkState(!trace.isEmpty() && rightJoinSymbols.containsAll(trace.keySet()));
    }
switch (node.getType()) {
case INNER:
      if (rightIndexCandidate.isPresent()) {
        return new IndexJoinNode(idAllocator.getNextId(),IndexJoinNode.Type.INNER,leftRewritten,rightIndexCandidate.get(),createEquiJoinClause(leftJoinSymbols,rightJoinSymbols),Optional.<Symbol>absent(),Optional.<Symbol>absent());
      }
 else       if (leftIndexCandidate.isPresent()) {
        return new IndexJoinNode(idAllocator.getNextId(),IndexJoinNode.Type.INNER,rightRewritten,leftIndexCandidate.get(),createEquiJoinClause(rightJoinSymbols,leftJoinSymbols),Optional.<Symbol>absent(),Optional.<Symbol>absent());
      }
    break;
case LEFT:
  if (rightIndexCandidate.isPresent()) {
    return new IndexJoinNode(idAllocator.getNextId(),IndexJoinNode.Type.SOURCE_OUTER,leftRewritten,rightIndexCandidate.get(),createEquiJoinClause(leftJoinSymbols,rightJoinSymbols),Optional.<Symbol>absent(),Optional.<Symbol>absent());
  }
break;
case RIGHT:
if (leftIndexCandidate.isPresent()) {
return new IndexJoinNode(idAllocator.getNextId(),IndexJoinNode.Type.SOURCE_OUTER,rightRewritten,leftIndexCandidate.get(),createEquiJoinClause(rightJoinSymbols,leftJoinSymbols),Optional.<Symbol>absent(),Optional.<Symbol>absent());
}
break;
default :
throw new IllegalArgumentException("Unknown type: " + node.getType());
}
}
if (leftRewritten != node.getLeft() || rightRewritten != node.getRight()) {
return new JoinNode(node.getId(),node.getType(),leftRewritten,rightRewritten,node.getCriteria(),node.getLeftHashSymbol(),node.getRightHashSymbol());
}
return node;
}
