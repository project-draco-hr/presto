{
  Block block=readStructuralBlock(map);
  int position=0;
  Class<?> keyTypeJavaType=keyType.getJavaType();
  for (; position < block.getPositionCount(); position+=2) {
    try {
      boolean equals;
      if (keyTypeJavaType == long.class) {
        equals=(boolean)keyEqualsMethod.invokeExact(keyType.getLong(block,position),(long)key);
      }
 else       if (keyTypeJavaType == double.class) {
        equals=(boolean)keyEqualsMethod.invokeExact(keyType.getDouble(block,position),(double)key);
      }
 else       if (keyTypeJavaType == boolean.class) {
        equals=(boolean)keyEqualsMethod.invokeExact(keyType.getBoolean(block,position),(boolean)key);
      }
 else       if (keyTypeJavaType == Slice.class) {
        equals=(boolean)keyEqualsMethod.invokeExact(keyType.getSlice(block,position),(Slice)key);
      }
 else {
        throw new IllegalArgumentException("Unsupported type: " + keyTypeJavaType.getSimpleName());
      }
      if (equals) {
        break;
      }
    }
 catch (    Throwable t) {
      Throwables.propagateIfInstanceOf(t,Error.class);
      Throwables.propagateIfInstanceOf(t,PrestoException.class);
      throw new PrestoException(INTERNAL_ERROR,t);
    }
  }
  if (position == block.getPositionCount()) {
    return null;
  }
  position+=1;
  return (T)castValue(valueType,block,position);
}
