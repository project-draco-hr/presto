{
  ImmutableList.Builder<Optional<String>> names=ImmutableList.builder();
  ImmutableList.Builder<Symbol> symbols=ImmutableList.builder();
  BiMap<Symbol,AnalyzedExpression> assignments=HashBiMap.create();
  ImmutableList.Builder<Type> types=ImmutableList.builder();
  for (  Expression expression : select.getSelectItems()) {
    if (expression instanceof AllColumns) {
      Optional<QualifiedName> starPrefix=((AllColumns)expression).getPrefix();
      for (      Field field : descriptor.getFields()) {
        Optional<QualifiedName> prefix=field.getPrefix();
        if (!starPrefix.isPresent() || prefix.isPresent() && prefix.get().hasSuffix(starPrefix.get())) {
          names.add(field.getAttribute());
          symbols.add(field.getSymbol());
          types.add(field.getType());
          assignments.put(field.getSymbol(),new AnalyzedExpression(field.getType(),new QualifiedNameReference(field.getSymbol().toQualifiedName())));
        }
      }
    }
 else {
      Optional<String> alias=Optional.absent();
      if (expression instanceof AliasedExpression) {
        AliasedExpression aliased=(AliasedExpression)expression;
        alias=Optional.of(aliased.getAlias());
        expression=aliased.getExpression();
      }
 else       if (expression instanceof QualifiedNameReference) {
        alias=Optional.of(((QualifiedNameReference)expression).getName().getSuffix());
      }
      AnalyzedExpression analysis=new ExpressionAnalyzer(metadata).analyze(expression,descriptor);
      Symbol symbol;
      if (assignments.containsValue(analysis)) {
        symbol=assignments.inverse().get(analysis);
      }
 else {
        symbol=allocator.newSymbol(analysis.getRewrittenExpression(),analysis.getType());
        assignments.put(symbol,analysis);
      }
      symbols.add(symbol);
      names.add(alias);
      types.add(analysis.getType());
    }
  }
  return new AnalyzedOutput(new TupleDescriptor(names.build(),symbols.build(),types.build()),assignments);
}
