{
  Preconditions.checkArgument(query.getHaving() == null,"not yet implemented: HAVING");
  Preconditions.checkArgument(query.getFrom().size() == 1,"not yet implemented: multiple FROM relations");
  for (  Expression expression : query.getSelect().getSelectItems()) {
    if (expression instanceof AliasedExpression) {
      context.getSymbolAllocator().blacklist(((AliasedExpression)expression).getAlias());
    }
  }
  Relation relation=Iterables.getOnlyElement(query.getFrom());
  TupleDescriptor sourceDescriptor=new RelationAnalyzer(metadata,context.getSession()).process(relation,context);
  AnalyzedExpression predicate=null;
  if (query.getWhere() != null) {
    predicate=analyzePredicate(query.getWhere(),sourceDescriptor);
  }
  List<AnalyzedExpression> groupBy=analyzeGroupBy(query.getGroupBy(),sourceDescriptor,context.getSymbols());
  Set<AnalyzedAggregation> aggregations=analyzeAggregations(query.getGroupBy(),query.getSelect(),query.getOrderBy(),sourceDescriptor,context.getSymbols());
  List<AnalyzedOrdering> orderBy=analyzeOrderBy(query.getOrderBy(),sourceDescriptor);
  AnalyzedOutput output=analyzeOutput(query.getSelect(),context.getSymbolAllocator(),sourceDescriptor);
  if (query.getSelect().isDistinct()) {
    analyzeDistinct(output,orderBy);
  }
  Long limit=null;
  if (query.getLimit() != null) {
    limit=Long.parseLong(query.getLimit());
  }
  return AnalysisResult.newInstance(context,query.getSelect().isDistinct(),output,predicate,groupBy,aggregations,limit,orderBy);
}
