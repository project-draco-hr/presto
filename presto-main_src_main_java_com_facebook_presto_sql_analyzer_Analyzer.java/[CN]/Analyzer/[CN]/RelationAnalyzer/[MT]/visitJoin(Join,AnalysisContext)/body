{
  if (node.getType() != Join.Type.INNER) {
    throw new SemanticException(node,"Only inner joins are supported");
  }
  TupleDescriptor leftTuple=process(node.getLeft(),context);
  TupleDescriptor rightTuple=process(node.getRight(),context);
  TupleDescriptor descriptor=new TupleDescriptor(ImmutableList.copyOf(Iterables.concat(leftTuple.getFields(),rightTuple.getFields())));
  JoinCriteria criteria=node.getCriteria();
  if (criteria instanceof NaturalJoin) {
    throw new SemanticException(node,"Natural join not supported");
  }
 else   if (criteria instanceof JoinUsing) {
    List<String> columns=((JoinUsing)criteria).getColumns();
    ImmutableList.Builder<AnalyzedJoinClause> clauses=ImmutableList.builder();
    for (    String column : columns) {
      AnalyzedExpression left=new ExpressionAnalyzer(metadata).analyze(new QualifiedNameReference(new QualifiedName(column)),leftTuple);
      AnalyzedExpression right=new ExpressionAnalyzer(metadata).analyze(new QualifiedNameReference(new QualifiedName(column)),rightTuple);
      clauses.add(new AnalyzedJoinClause(left,right));
    }
    context.registerJoin(node,clauses.build());
    return descriptor;
  }
 else   if (criteria instanceof JoinOn) {
    new ExpressionAnalyzer(metadata).analyze(((JoinOn)criteria).getExpression(),descriptor);
    ImmutableList.Builder<AnalyzedJoinClause> clauses=ImmutableList.builder();
    for (    Expression conjunct : ExpressionUtils.extractConjuncts(((JoinOn)criteria).getExpression())) {
      if (!(conjunct instanceof ComparisonExpression)) {
        throw new SemanticException(node,"Non-equi joins not supported");
      }
      ComparisonExpression comparison=(ComparisonExpression)conjunct;
      if (comparison.getType() != ComparisonExpression.Type.EQUAL) {
        throw new SemanticException(node,"Non-equi joins not supported");
      }
      AnalyzedExpression first=new ExpressionAnalyzer(metadata).analyze(comparison.getLeft(),descriptor);
      Set<Symbol> firstDependencies=DependencyExtractor.extract(first.getRewrittenExpression());
      AnalyzedExpression second=new ExpressionAnalyzer(metadata).analyze(comparison.getRight(),descriptor);
      Set<Symbol> secondDependencies=DependencyExtractor.extract(second.getRewrittenExpression());
      Set<Symbol> leftSymbols=leftTuple.getSymbols().keySet();
      Set<Symbol> rightSymbols=rightTuple.getSymbols().keySet();
      AnalyzedExpression leftExpression;
      AnalyzedExpression rightExpression;
      if (leftSymbols.containsAll(firstDependencies) && rightSymbols.containsAll(secondDependencies)) {
        leftExpression=first;
        rightExpression=second;
      }
 else       if (leftSymbols.containsAll(secondDependencies) && rightSymbols.containsAll(firstDependencies)) {
        leftExpression=second;
        rightExpression=first;
      }
 else {
        throw new SemanticException(node,"Non-equi joins not supported");
      }
      clauses.add(new AnalyzedJoinClause(leftExpression,rightExpression));
    }
    context.registerJoin(node,clauses.build());
    return descriptor;
  }
 else {
    throw new UnsupportedOperationException("unsupported join criteria: " + criteria.getClass().getName());
  }
}
