{
  if (outputIterator == null) {
    PriorityQueue<KeyAndTuples> globalCandidates=new PriorityQueue<>(n,KeyAndTuples.keyComparator(ordering));
    while (pageIterator.hasNext()) {
      Page page=pageIterator.next();
      Iterable<KeyAndPosition> keyAndPositions=computePageCandidatePositions(globalCandidates,page);
      mergeWithGlobalCandidates(globalCandidates,page,keyAndPositions);
    }
    ImmutableList.Builder<KeyAndTuples> minSortedGlobalCandidates=ImmutableList.builder();
    while (!globalCandidates.isEmpty()) {
      minSortedGlobalCandidates.add(globalCandidates.remove());
    }
    outputIterator=minSortedGlobalCandidates.build().reverse().iterator();
  }
  if (!outputIterator.hasNext()) {
    return endOfData();
  }
  BlockBuilder[] outputs=new BlockBuilder[projections.size()];
  for (int i=0; i < outputs.length; i++) {
    outputs[i]=new BlockBuilder(position,projections.get(i).getTupleInfo());
  }
  while (!isFull(outputs) && outputIterator.hasNext()) {
    KeyAndTuples next=outputIterator.next();
    for (int i=0; i < projections.size(); i++) {
      projections.get(i).project(next.getTuples(),outputs[i]);
    }
  }
  Block[] blocks=new Block[projections.size()];
  for (int i=0; i < blocks.length; i++) {
    blocks[i]=outputs[i].build();
  }
  Page page=new Page(blocks);
  position+=page.getPositionCount();
  return page;
}
