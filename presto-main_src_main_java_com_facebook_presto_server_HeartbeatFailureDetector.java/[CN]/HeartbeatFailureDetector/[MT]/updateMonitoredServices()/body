{
  Set<ServiceDescriptor> active=ImmutableSet.copyOf(selector.selectAllServices());
  Set<UUID> activeIds=IterableTransformer.on(active).transform(idGetter()).set();
synchronized (tasks) {
    Set<UUID> current=tasks.keySet();
    for (    UUID serviceId : Sets.difference(current,activeIds)) {
      tasks.remove(serviceId).getFuture().cancel(true);
    }
    Set<ServiceDescriptor> newServices=IterableTransformer.on(active).select(compose(not(in(current)),idGetter())).set();
    for (    final ServiceDescriptor service : newServices) {
      final URI uri=getHttpUri(service);
      if (uri != null) {
        ScheduledFuture<?> future=executor.scheduleAtFixedRate(new Runnable(){
          @Override public void run(){
            try {
              ping(service,uri);
            }
 catch (            Throwable e) {
              log.warn(e,"Error updating services");
            }
          }
        }
,(long)hearbeatInterval.toMillis(),(long)hearbeatInterval.toMillis(),TimeUnit.MILLISECONDS);
        tasks.put(service.getId(),new MonitoringTask(future,service,new Stats(uri)));
      }
    }
  }
}
