{
  Expression parsedExpression=SQL_PARSER.createExpression(expression);
  final ExpressionAnalysis analysis=analyzeExpressionsWithSymbols(TEST_SESSION,metadata,SQL_PARSER,symbolTypes,ImmutableList.of(parsedExpression));
  Expression rewrittenExpression=ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>(){
    @Override public Expression rewriteExpression(    Expression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      Expression rewrittenExpression=treeRewriter.defaultRewrite(node,context);
      Type type=analysis.getType(node);
      Type coercion=analysis.getCoercion(node);
      if (coercion != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coercion.getTypeSignature().toString(),false,isTypeOnlyCoercion(type.getTypeSignature(),coercion.getTypeSignature()));
      }
      return rewrittenExpression;
    }
    @Override public Expression rewriteDereferenceExpression(    DereferenceExpression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      if (analysis.getColumnReferences().contains(node)) {
        return rewriteExpression(node,context,treeRewriter);
      }
      QualifiedName mangledName=QualifiedName.of(mangleFieldReference(node.getFieldName()));
      FunctionCall functionCall=new FunctionCall(mangledName,ImmutableList.of(node.getBase()));
      Expression rewrittenExpression=rewriteFunctionCall(functionCall,context,treeRewriter);
      Type coercion=analysis.getCoercion(node);
      if (coercion != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coercion.getTypeSignature().toString());
      }
      return rewrittenExpression;
    }
  }
,parsedExpression);
  return canonicalizeExpression(rewrittenExpression);
}
