{
  Preconditions.checkArgument(!symbols.isEmpty(),"symbols is empty");
  List<Symbol> otherSymbols=ImmutableList.copyOf(Sets.difference(source.getLayout().keySet(),ImmutableSet.copyOf(symbols)));
  IdentityProjectionInfo mappings=computeIdentityMapping(otherSymbols,source.getLayout(),types);
  ImmutableMultimap.Builder<Symbol,Input> outputMappings=ImmutableMultimap.builder();
  ImmutableList.Builder<ProjectionFunction> projections=ImmutableList.builder();
  outputMappings.putAll(mappings.getOutputLayout());
  projections.addAll(mappings.getProjections());
  List<ProjectionFunction> packedProjections=new ArrayList<>();
  int channel=mappings.getProjections().size();
  int field=0;
  for (  Symbol symbol : symbols) {
    packedProjections.add(ProjectionFunctions.singleColumn(types.get(symbol).getRawType(),getFirst(source.getLayout().get(symbol))));
    outputMappings.put(symbol,new Input(channel,field));
    field++;
  }
  projections.add(ProjectionFunctions.concat(packedProjections));
  Operator operator=new FilterAndProjectOperator(source.getOperator(),FilterFunctions.TRUE_FUNCTION,projections.build());
  return new PhysicalOperation(operator,outputMappings.build());
}
