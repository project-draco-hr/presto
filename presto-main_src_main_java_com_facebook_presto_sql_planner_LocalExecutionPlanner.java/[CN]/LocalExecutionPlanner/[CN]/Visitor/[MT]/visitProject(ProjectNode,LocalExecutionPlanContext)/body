{
  PhysicalOperation source;
  Expression filterExpression;
  if (node.getSource() instanceof FilterNode) {
    FilterNode filterNode=(FilterNode)node.getSource();
    source=filterNode.getSource().accept(this,context);
    filterExpression=filterNode.getPredicate();
    filterExpression=TreeRewriter.rewriteWith(new SymbolToInputRewriter(source.getLayout()),filterExpression);
  }
 else {
    source=node.getSource().accept(this,context);
    filterExpression=BooleanLiteral.TRUE_LITERAL;
  }
  Map<Symbol,Input> outputMappings=new HashMap<>();
  List<Expression> projections=new ArrayList<>();
  for (int i=0; i < node.getExpressions().size(); i++) {
    Symbol symbol=node.getOutputSymbols().get(i);
    projections.add(TreeRewriter.rewriteWith(new SymbolToInputRewriter(source.getLayout()),node.getExpressions().get(i)));
    outputMappings.put(symbol,new Input(i,0));
  }
  ImmutableMap<Input,TupleInfo.Type> inputTypes=getInputTypes(source.getLayout(),source.getOperator().getTupleInfos());
  Function<Operator,Operator> operatorFactory=compiler.compileFilterAndProjectOperator(filterExpression,projections,inputTypes);
  Operator operator=operatorFactory.apply(source.getOperator());
  return new PhysicalOperation(operator,outputMappings);
}
