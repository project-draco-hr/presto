{
  PhysicalOperation source;
  Expression filterExpression;
  if (node.getSource() instanceof FilterNode) {
    FilterNode filterNode=(FilterNode)node.getSource();
    source=filterNode.getSource().accept(this,context);
    filterExpression=filterNode.getPredicate();
  }
 else {
    source=node.getSource().accept(this,context);
    filterExpression=BooleanLiteral.TRUE_LITERAL;
  }
  List<Expression> expressions=node.getExpressions();
  Map<Input,Type> inputTypes=null;
  try {
    Expression rewrittenFilterExpression=ExpressionTreeRewriter.rewriteWith(new SymbolToInputRewriter(convertLayoutToInputMap(source.getLayout())),filterExpression);
    ImmutableMultimap.Builder<Symbol,Input> outputMappings=ImmutableMultimap.builder();
    List<Expression> projections=new ArrayList<>();
    for (int i=0; i < expressions.size(); i++) {
      Symbol symbol=node.getOutputSymbols().get(i);
      projections.add(ExpressionTreeRewriter.rewriteWith(new SymbolToInputRewriter(convertLayoutToInputMap(source.getLayout())),expressions.get(i)));
      outputMappings.put(symbol,new Input(i,0));
    }
    inputTypes=getInputTypes(source.getLayout(),source.getOperator().getTupleInfos());
    OperatorFactory operatorFactory=compiler.compileFilterAndProjectOperator(rewrittenFilterExpression,projections,inputTypes);
    Operator operator=operatorFactory.createOperator(source.getOperator(),context.getSession());
    return new PhysicalOperation(operator,outputMappings.build());
  }
 catch (  Exception e) {
    log.error(e,"Compile failed for filter=%s projections=%s inputTypes=%s error=%s",filterExpression,node.getExpressions(),inputTypes,e);
    FilterFunction filter;
    if (filterExpression != BooleanLiteral.TRUE_LITERAL) {
      filter=new InterpretedFilterFunction(filterExpression,convertLayoutToInputMap(source.getLayout()),metadata,context.getSession(),inputTypes);
    }
 else {
      filter=FilterFunctions.TRUE_FUNCTION;
    }
    ImmutableMultimap.Builder<Symbol,Input> outputMappings=ImmutableMultimap.builder();
    List<ProjectionFunction> projections=new ArrayList<>();
    for (int i=0; i < expressions.size(); i++) {
      Symbol symbol=node.getOutputSymbols().get(i);
      Expression expression=expressions.get(i);
      ProjectionFunction function;
      if (expression instanceof QualifiedNameReference) {
        Symbol reference=Symbol.fromQualifiedName(((QualifiedNameReference)expression).getName());
        function=ProjectionFunctions.singleColumn(context.getTypes().get(reference).getRawType(),getFirst(source.getLayout().get(symbol)));
      }
 else {
        function=new InterpretedProjectionFunction(context.getTypes().get(symbol),expression,convertLayoutToInputMap(source.getLayout()),metadata,context.getSession(),inputTypes);
      }
      projections.add(function);
      outputMappings.put(symbol,new Input(i,0));
    }
    FilterAndProjectOperator operator=new FilterAndProjectOperator(source.getOperator(),filter,projections);
    return new PhysicalOperation(operator,outputMappings.build());
  }
}
