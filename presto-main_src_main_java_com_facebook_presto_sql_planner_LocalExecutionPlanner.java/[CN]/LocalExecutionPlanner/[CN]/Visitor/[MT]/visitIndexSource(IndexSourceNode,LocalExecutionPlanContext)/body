{
  checkState(context.getIndexSourceContext().isPresent(),"Must be in an index source context");
  IndexSourceContext indexSourceContext=context.getIndexSourceContext().get();
  ImmutableMap.Builder<Symbol,Input> outputMappings=ImmutableMap.builder();
  int channel=0;
  for (  Symbol symbol : node.getOutputSymbols()) {
    outputMappings.put(symbol,new Input(channel));
    channel++;
  }
  SetMultimap<Symbol,Input> indexLookupToProbeInput=indexSourceContext.getIndexLookupToProbeInput();
  checkState(indexLookupToProbeInput.keySet().equals(node.getLookupSymbols()));
  List<Symbol> lookupSymbolSchema=ImmutableList.copyOf(node.getLookupSymbols());
  ImmutableList.Builder<Integer> remappedProbeKeyChannelsBuilder=ImmutableList.builder();
  ImmutableList.Builder<Set<Integer>> overlappingFieldSetsBuilder=ImmutableList.builder();
  for (  Symbol lookupSymbol : lookupSymbolSchema) {
    Set<Input> potentialProbeInputs=indexLookupToProbeInput.get(lookupSymbol);
    checkState(!potentialProbeInputs.isEmpty(),"Must have at least one source from the probe input");
    if (potentialProbeInputs.size() > 1) {
      overlappingFieldSetsBuilder.add(FluentIterable.from(potentialProbeInputs).transform(Input.channelGetter()).toSet());
    }
    remappedProbeKeyChannelsBuilder.add(Iterables.getFirst(potentialProbeInputs,null).getChannel());
  }
  final List<Set<Integer>> overlappingFieldSets=overlappingFieldSetsBuilder.build();
  final List<Integer> remappedProbeKeyChannels=remappedProbeKeyChannelsBuilder.build();
  Function<RecordSet,RecordSet> probeKeyNormalizer=new Function<RecordSet,RecordSet>(){
    @Override public RecordSet apply(    RecordSet recordSet){
      if (!overlappingFieldSets.isEmpty()) {
        recordSet=new FieldSetFilteringRecordSet(recordSet,overlappingFieldSets);
      }
      return new MappedRecordSet(recordSet,remappedProbeKeyChannels);
    }
  }
;
  List<ColumnHandle> lookupSchema=Lists.transform(lookupSymbolSchema,Functions.forMap(node.getAssignments()));
  List<ColumnHandle> outputSchema=Lists.transform(node.getOutputSymbols(),Functions.forMap(node.getAssignments()));
  Index index=indexManager.getIndex(node.getIndexHandle(),lookupSchema,outputSchema);
  List<Type> types=getSourceOperatorTypes(node,context.getTypes());
  OperatorFactory operatorFactory=new IndexSourceOperator.IndexSourceOperatorFactory(context.getNextOperatorId(),node.getId(),index,types,probeKeyNormalizer);
  return new PhysicalOperation(operatorFactory,outputMappings.build());
}
