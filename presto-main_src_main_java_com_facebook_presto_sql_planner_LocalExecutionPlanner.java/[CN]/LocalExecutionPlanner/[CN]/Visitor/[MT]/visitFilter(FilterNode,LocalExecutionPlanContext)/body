{
  PhysicalOperation source=node.getSource().accept(this,context);
  Map<Input,Type> inputTypes=getInputTypes(source.getLayout(),source.getOperator().getTupleInfos());
  try {
    Expression filterExpression=TreeRewriter.rewriteWith(new SymbolToInputRewriter(convertLayoutToInputMap(source.getLayout())),node.getPredicate());
    ImmutableMultimap.Builder<Symbol,Input> outputMappings=ImmutableMultimap.builder();
    List<Expression> projections=new ArrayList<>();
    for (int i=0; i < node.getOutputSymbols().size(); i++) {
      Symbol symbol=node.getOutputSymbols().get(i);
      Input input=getFirst(source.getLayout().get(symbol));
      Preconditions.checkArgument(input != null,"Cannot resolve symbol %s",symbol.getName());
      projections.add(new InputReference(input));
      outputMappings.put(symbol,new Input(i,0));
    }
    OperatorFactory operatorFactory=compiler.compileFilterAndProjectOperator(filterExpression,projections,inputTypes);
    Operator operator=operatorFactory.createOperator(source.getOperator(),context.getSession());
    return new PhysicalOperation(operator,outputMappings.build());
  }
 catch (  Exception e) {
    log.error(e,"Compile failed for filter=%s inputTypes=%s error=%s",node.getPredicate(),inputTypes,e);
    FilterFunction filter=new InterpretedFilterFunction(node.getPredicate(),convertLayoutToInputMap(source.getLayout()),metadata,context.getSession(),inputTypes);
    IdentityProjectionInfo mappings=computeIdentityMapping(node.getOutputSymbols(),source.getLayout(),context.getTypes());
    Operator operator=new FilterAndProjectOperator(source.getOperator(),filter,mappings.getProjections());
    return new PhysicalOperation(operator,mappings.getOutputLayout());
  }
}
