{
  Map<Symbol,Integer> sourceLayout;
  Map<Integer,Type> sourceTypes;
  List<ColumnHandle> columns=null;
  PhysicalOperation source=null;
  if (sourceNode instanceof TableScanNode) {
    TableScanNode tableScanNode=(TableScanNode)sourceNode;
    sourceLayout=new LinkedHashMap<>();
    sourceTypes=new LinkedHashMap<>();
    columns=new ArrayList<>();
    int channel=0;
    for (    Symbol symbol : tableScanNode.getOutputSymbols()) {
      columns.add(tableScanNode.getAssignments().get(symbol));
      Integer input=channel;
      sourceLayout.put(symbol,input);
      Type type=checkNotNull(context.getTypes().get(symbol),"No type for symbol %s",symbol);
      sourceTypes.put(input,type);
      channel++;
    }
  }
 else {
    source=sourceNode.accept(this,context);
    sourceLayout=source.getLayout();
    sourceTypes=getInputTypes(source.getLayout(),source.getTypes());
  }
  ImmutableMap.Builder<Symbol,Integer> outputMappingsBuilder=ImmutableMap.builder();
  for (int i=0; i < outputSymbols.size(); i++) {
    Symbol symbol=outputSymbols.get(i);
    outputMappingsBuilder.put(symbol,i);
  }
  Map<Symbol,Integer> outputMappings=outputMappingsBuilder.build();
  try {
    SymbolToInputRewriter symbolToInputRewriter=SymbolToInputRewriter.createRewriter(sourceLayout);
    Expression rewrittenFilter=ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,filterExpression);
    List<Expression> rewrittenProjections=new ArrayList<>();
    List<Type> outputTypes=new ArrayList<>();
    for (int i=0; i < projectionExpressions.size(); i++) {
      Expression projection=projectionExpressions.get(i);
      rewrittenProjections.add(ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,projection));
      outputTypes.add(context.getTypes().get(outputSymbols.get(i)));
    }
    IdentityHashMap<Expression,Type> expressionTypes=getExpressionTypesFromInput(context.getSession(),metadata,sqlParser,sourceTypes,concat(singleton(rewrittenFilter),rewrittenProjections));
    if (columns != null) {
      SourceOperatorFactory operatorFactory=compiler.compileScanFilterAndProjectOperator(context.getNextOperatorId(),sourceNode.getId(),dataStreamProvider,columns,rewrittenFilter,rewrittenProjections,expressionTypes,session.getTimeZoneKey());
      return new PhysicalOperation(operatorFactory,outputMappings);
    }
 else {
      OperatorFactory operatorFactory=compiler.compileFilterAndProjectOperator(context.getNextOperatorId(),rewrittenFilter,rewrittenProjections,expressionTypes,session.getTimeZoneKey());
      return new PhysicalOperation(operatorFactory,outputMappings,source);
    }
  }
 catch (  RuntimeException e) {
    if (!interpreterEnabled) {
      throw e;
    }
    log.error(e,"Compile failed for filter=%s projections=%s sourceTypes=%s error=%s",filterExpression,projectionExpressions,sourceTypes,e);
  }
  FilterFunction filterFunction;
  if (filterExpression != BooleanLiteral.TRUE_LITERAL) {
    filterFunction=new InterpretedFilterFunction(filterExpression,context.getTypes(),sourceLayout,metadata,sqlParser,context.getSession());
  }
 else {
    filterFunction=FilterFunctions.TRUE_FUNCTION;
  }
  List<ProjectionFunction> projectionFunctions=new ArrayList<>();
  for (  Expression expression : projectionExpressions) {
    ProjectionFunction function;
    if (expression instanceof QualifiedNameReference) {
      Symbol reference=Symbol.fromQualifiedName(((QualifiedNameReference)expression).getName());
      function=ProjectionFunctions.singleColumn(context.getTypes().get(reference),sourceLayout.get(reference));
    }
 else {
      function=new InterpretedProjectionFunction(expression,context.getTypes(),sourceLayout,metadata,sqlParser,context.getSession());
    }
    projectionFunctions.add(function);
  }
  if (columns != null) {
    OperatorFactory operatorFactory=new ScanFilterAndProjectOperatorFactory(context.getNextOperatorId(),sourceNode.getId(),dataStreamProvider,columns,filterFunction,projectionFunctions);
    return new PhysicalOperation(operatorFactory,outputMappings);
  }
 else {
    OperatorFactory operatorFactory=new FilterAndProjectOperatorFactory(context.getNextOperatorId(),filterFunction,projectionFunctions);
    return new PhysicalOperation(operatorFactory,outputMappings,source);
  }
}
