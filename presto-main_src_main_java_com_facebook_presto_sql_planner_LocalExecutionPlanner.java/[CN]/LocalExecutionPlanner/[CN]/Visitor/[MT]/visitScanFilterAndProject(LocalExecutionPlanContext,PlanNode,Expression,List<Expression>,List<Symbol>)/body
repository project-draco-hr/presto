{
  Map<Symbol,Integer> sourceLayout;
  Map<Integer,Type> sourceTypes;
  List<ColumnHandle> columns=null;
  PhysicalOperation source=null;
  if (sourceNode instanceof TableScanNode) {
    TableScanNode tableScanNode=(TableScanNode)sourceNode;
    sourceLayout=new LinkedHashMap<>();
    sourceTypes=new LinkedHashMap<>();
    columns=new ArrayList<>();
    int channel=0;
    for (    Symbol symbol : tableScanNode.getOutputSymbols()) {
      columns.add(tableScanNode.getAssignments().get(symbol));
      Integer input=channel;
      sourceLayout.put(symbol,input);
      Type type=checkNotNull(context.getTypes().get(symbol),"No type for symbol %s",symbol);
      sourceTypes.put(input,type);
      channel++;
    }
  }
 else {
    source=sourceNode.accept(this,context);
    sourceLayout=source.getLayout();
    sourceTypes=getInputTypes(source.getLayout(),source.getTypes());
  }
  ImmutableMap.Builder<Symbol,Integer> outputMappingsBuilder=ImmutableMap.builder();
  for (int i=0; i < outputSymbols.size(); i++) {
    Symbol symbol=outputSymbols.get(i);
    outputMappingsBuilder.put(symbol,i);
  }
  Map<Symbol,Integer> outputMappings=outputMappingsBuilder.build();
  try {
    SymbolToInputRewriter symbolToInputRewriter=new SymbolToInputRewriter(sourceLayout);
    Expression rewrittenFilter=ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,filterExpression);
    List<Expression> rewrittenProjections=new ArrayList<>();
    for (    Expression projection : projectionExpressions) {
      rewrittenProjections.add(ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,projection));
    }
    IdentityHashMap<Expression,Type> expressionTypes=getExpressionTypesFromInput(context.getSession(),metadata,sqlParser,sourceTypes,concat(singleton(rewrittenFilter),rewrittenProjections));
    RowExpression traslatedFilter=SqlToRowExpressionTranslator.translate(rewrittenFilter,expressionTypes,metadata,session,true);
    List<RowExpression> translatedProjections=SqlToRowExpressionTranslator.translate(rewrittenProjections,expressionTypes,metadata,session,true);
    if (columns != null) {
      CursorProcessor cursorProcessor=compiler.compileCursorProcessor(traslatedFilter,translatedProjections,sourceNode.getId());
      PageProcessor pageProcessor=compiler.compilePageProcessor(traslatedFilter,translatedProjections);
      SourceOperatorFactory operatorFactory=new ScanFilterAndProjectOperator.ScanFilterAndProjectOperatorFactory(context.getNextOperatorId(),sourceNode.getId(),pageSourceProvider,cursorProcessor,pageProcessor,columns,Lists.transform(rewrittenProjections,forMap(expressionTypes)));
      return new PhysicalOperation(operatorFactory,outputMappings);
    }
 else {
      PageProcessor processor=compiler.compilePageProcessor(traslatedFilter,translatedProjections);
      OperatorFactory operatorFactory=new FilterAndProjectOperator.FilterAndProjectOperatorFactory(context.getNextOperatorId(),processor,Lists.transform(rewrittenProjections,forMap(expressionTypes)));
      return new PhysicalOperation(operatorFactory,outputMappings,source);
    }
  }
 catch (  RuntimeException e) {
    if (!interpreterEnabled) {
      throw new PrestoException(COMPILER_ERROR,"Compiler failed and interpreter is disabled",e);
    }
    log.error(e,"Compile failed for filter=%s projections=%s sourceTypes=%s error=%s",filterExpression,projectionExpressions,sourceTypes,e);
  }
  FilterFunction filterFunction;
  if (filterExpression != BooleanLiteral.TRUE_LITERAL) {
    filterFunction=new InterpretedFilterFunction(filterExpression,context.getTypes(),sourceLayout,metadata,sqlParser,context.getSession());
  }
 else {
    filterFunction=FilterFunctions.TRUE_FUNCTION;
  }
  List<ProjectionFunction> projectionFunctions=new ArrayList<>();
  for (  Expression expression : projectionExpressions) {
    ProjectionFunction function;
    if (expression instanceof QualifiedNameReference) {
      Symbol reference=Symbol.fromQualifiedName(((QualifiedNameReference)expression).getName());
      function=ProjectionFunctions.singleColumn(context.getTypes().get(reference),sourceLayout.get(reference));
    }
 else {
      function=new InterpretedProjectionFunction(expression,context.getTypes(),sourceLayout,metadata,sqlParser,context.getSession());
    }
    projectionFunctions.add(function);
  }
  if (columns != null) {
    OperatorFactory operatorFactory=new ScanFilterAndProjectOperator.ScanFilterAndProjectOperatorFactory(context.getNextOperatorId(),sourceNode.getId(),pageSourceProvider,new GenericCursorProcessor(filterFunction,projectionFunctions),new GenericPageProcessor(filterFunction,projectionFunctions),columns,toTypes(projectionFunctions));
    return new PhysicalOperation(operatorFactory,outputMappings);
  }
 else {
    OperatorFactory operatorFactory=new FilterAndProjectOperator.FilterAndProjectOperatorFactory(context.getNextOperatorId(),new GenericPageProcessor(filterFunction,projectionFunctions),toTypes(projectionFunctions));
    return new PhysicalOperation(operatorFactory,outputMappings,source);
  }
}
