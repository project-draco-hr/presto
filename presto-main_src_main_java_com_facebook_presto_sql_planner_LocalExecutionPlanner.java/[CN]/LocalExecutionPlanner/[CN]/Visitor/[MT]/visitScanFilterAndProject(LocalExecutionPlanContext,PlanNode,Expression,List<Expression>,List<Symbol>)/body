{
  Map<Symbol,Input> sourceLayout;
  Map<Input,Type> sourceTypes;
  List<ColumnHandle> columns=null;
  PhysicalOperation source=null;
  if (sourceNode instanceof TableScanNode) {
    TableScanNode tableScanNode=(TableScanNode)sourceNode;
    sourceLayout=new LinkedHashMap<>();
    sourceTypes=new LinkedHashMap<>();
    columns=new ArrayList<>();
    int channel=0;
    for (    Symbol symbol : tableScanNode.getOutputSymbols()) {
      columns.add(tableScanNode.getAssignments().get(symbol));
      Input input=new Input(channel);
      sourceLayout.put(symbol,input);
      Type type=checkNotNull(context.getTypes().get(symbol),"No type for symbol %s",symbol);
      sourceTypes.put(input,type);
      channel++;
    }
  }
 else {
    source=sourceNode.accept(this,context);
    sourceLayout=convertLayoutToInputMap(source.getLayout());
    sourceTypes=getInputTypes(source.getLayout(),source.getTupleInfos());
  }
  ImmutableMultimap.Builder<Symbol,Input> outputMappingsBuilder=ImmutableMultimap.builder();
  for (int i=0; i < outputSymbols.size(); i++) {
    Symbol symbol=outputSymbols.get(i);
    outputMappingsBuilder.put(symbol,new Input(i));
  }
  Multimap<Symbol,Input> outputMappings=outputMappingsBuilder.build();
  try {
    SymbolToInputRewriter symbolToInputRewriter=new SymbolToInputRewriter(sourceLayout);
    Expression rewrittenFilter=ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,filterExpression);
    List<Expression> rewrittenProjections=new ArrayList<>();
    for (    Expression projection : projectionExpressions) {
      rewrittenProjections.add(ExpressionTreeRewriter.rewriteWith(symbolToInputRewriter,projection));
    }
    if (columns != null) {
      SourceOperatorFactory operatorFactory=compiler.compileScanFilterAndProjectOperator(context.getNextOperatorId(),sourceNode.getId(),dataStreamProvider,columns,rewrittenFilter,rewrittenProjections,sourceTypes);
      return new PhysicalOperation(operatorFactory,outputMappings);
    }
 else {
      OperatorFactory operatorFactory=compiler.compileFilterAndProjectOperator(context.getNextOperatorId(),rewrittenFilter,rewrittenProjections,sourceTypes);
      return new PhysicalOperation(operatorFactory,outputMappings,source);
    }
  }
 catch (  RuntimeException e) {
    log.error(e,"Compile failed for filter=%s projections=%s sourceTypes=%s error=%s",filterExpression,projectionExpressions,sourceTypes,e);
  }
  FilterFunction filterFunction;
  if (filterExpression != BooleanLiteral.TRUE_LITERAL) {
    filterFunction=new InterpretedFilterFunction(filterExpression,sourceLayout,metadata,context.getSession());
  }
 else {
    filterFunction=FilterFunctions.TRUE_FUNCTION;
  }
  List<ProjectionFunction> projectionFunctions=new ArrayList<>();
  for (int i=0; i < projectionExpressions.size(); i++) {
    Symbol symbol=outputSymbols.get(i);
    Expression expression=projectionExpressions.get(i);
    ProjectionFunction function;
    if (expression instanceof QualifiedNameReference) {
      Symbol reference=Symbol.fromQualifiedName(((QualifiedNameReference)expression).getName());
      function=ProjectionFunctions.singleColumn(context.getTypes().get(reference).getRawType(),sourceLayout.get(reference));
    }
 else {
      function=new InterpretedProjectionFunction(context.getTypes().get(symbol),expression,sourceLayout,metadata,context.getSession());
    }
    projectionFunctions.add(function);
  }
  if (columns != null) {
    OperatorFactory operatorFactory=new ScanFilterAndProjectOperatorFactory(context.getNextOperatorId(),sourceNode.getId(),dataStreamProvider,columns,filterFunction,projectionFunctions);
    return new PhysicalOperation(operatorFactory,outputMappings);
  }
 else {
    OperatorFactory operatorFactory=new FilterAndProjectOperatorFactory(context.getNextOperatorId(),filterFunction,projectionFunctions);
    return new PhysicalOperation(operatorFactory,outputMappings,source);
  }
}
