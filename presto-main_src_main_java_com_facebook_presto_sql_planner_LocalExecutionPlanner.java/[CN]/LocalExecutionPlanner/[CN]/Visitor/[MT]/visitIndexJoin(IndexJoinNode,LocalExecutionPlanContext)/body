{
  List<IndexJoinNode.EquiJoinClause> clauses=node.getCriteria();
  List<Symbol> probeSymbols=Lists.transform(clauses,probeGetter());
  List<Symbol> indexSymbols=Lists.transform(clauses,indexGetter());
  PhysicalOperation probeSource=node.getProbeSource().accept(this,context);
  List<Integer> probeChannels=getChannelsForSymbols(probeSymbols,probeSource.getLayout());
  Optional<Integer> probeHashChannel=node.getProbeHashSymbol().transform(channelGetter(probeSource));
  Map<Symbol,Integer> probeKeyLayout=new HashMap<>();
  for (int i=0; i < probeSymbols.size(); i++) {
    probeKeyLayout.put(probeSymbols.get(i),i);
  }
  SetMultimap<Symbol,Integer> indexLookupToProbeInput=mapIndexSourceLookupSymbolToProbeKeyInput(node,probeKeyLayout);
  LocalExecutionPlanContext indexContext=context.createIndexSourceSubContext(new IndexSourceContext(indexLookupToProbeInput));
  PhysicalOperation indexSource=node.getIndexSource().accept(this,indexContext);
  List<Integer> indexOutputChannels=getChannelsForSymbols(indexSymbols,indexSource.getLayout());
  Optional<Integer> indexHashChannel=node.getIndexHashSymbol().transform(channelGetter(indexSource));
  Set<Symbol> indexSymbolsNeededBySource=IndexJoinOptimizer.IndexKeyTracer.trace(node.getIndexSource(),ImmutableSet.copyOf(indexSymbols)).keySet();
  Set<Integer> lookupSourceInputChannels=FluentIterable.from(node.getCriteria()).filter(Predicates.compose(in(indexSymbolsNeededBySource),indexGetter())).transform(probeGetter()).transform(Functions.forMap(probeKeyLayout)).toSet();
  Optional<DynamicTupleFilterFactory> dynamicTupleFilterFactory=Optional.absent();
  if (lookupSourceInputChannels.size() < probeKeyLayout.values().size()) {
    int[] nonLookupInputChannels=Ints.toArray(FluentIterable.from(node.getCriteria()).filter(Predicates.compose(not(in(indexSymbolsNeededBySource)),indexGetter())).transform(probeGetter()).transform(Functions.forMap(probeKeyLayout)).toList());
    int[] nonLookupOutputChannels=Ints.toArray(FluentIterable.from(node.getCriteria()).filter(Predicates.compose(not(in(indexSymbolsNeededBySource)),indexGetter())).transform(indexGetter()).transform(Functions.forMap(indexSource.getLayout())).toList());
    int filterOperatorId=indexContext.getNextOperatorId();
    dynamicTupleFilterFactory=Optional.of(new DynamicTupleFilterFactory(filterOperatorId,nonLookupInputChannels,nonLookupOutputChannels,indexSource.getTypes()));
  }
  IndexBuildDriverFactoryProvider indexBuildDriverFactoryProvider=new IndexBuildDriverFactoryProvider(indexContext.getNextOperatorId(),indexContext.isInputDriver(),indexSource.getOperatorFactories(),dynamicTupleFilterFactory);
  IndexLookupSourceSupplier indexLookupSourceSupplier=new IndexLookupSourceSupplier(lookupSourceInputChannels,indexOutputChannels,indexHashChannel,indexSource.getTypes(),indexBuildDriverFactoryProvider,maxIndexMemorySize,indexJoinLookupStats);
  ImmutableMap.Builder<Symbol,Integer> outputMappings=ImmutableMap.builder();
  outputMappings.putAll(probeSource.getLayout());
  int offset=probeSource.getTypes().size();
  for (  Map.Entry<Symbol,Integer> entry : indexSource.getLayout().entrySet()) {
    Integer input=entry.getValue();
    outputMappings.put(entry.getKey(),offset + input);
  }
  OperatorFactory lookupJoinOperatorFactory;
switch (node.getType()) {
case INNER:
    lookupJoinOperatorFactory=LookupJoinOperators.innerJoin(context.getNextOperatorId(),indexLookupSourceSupplier,probeSource.getTypes(),probeChannels,probeHashChannel);
  break;
case SOURCE_OUTER:
lookupJoinOperatorFactory=LookupJoinOperators.outerJoin(context.getNextOperatorId(),indexLookupSourceSupplier,probeSource.getTypes(),probeChannels,probeHashChannel);
break;
default :
throw new AssertionError("Unknown type: " + node.getType());
}
return new PhysicalOperation(lookupJoinOperatorFactory,outputMappings.build(),probeSource);
}
