{
  ComparisonExpression comparison=(ComparisonExpression)node.getCriteria();
  Symbol first=Symbol.fromQualifiedName(((QualifiedNameReference)comparison.getLeft()).getName());
  Symbol second=Symbol.fromQualifiedName(((QualifiedNameReference)comparison.getRight()).getName());
  Symbol left;
  Symbol right;
  if (node.getLeft().getOutputSymbols().contains(first)) {
    left=first;
    right=second;
  }
 else {
    left=second;
    right=first;
  }
  PhysicalOperation leftSource=node.getLeft().accept(this,context);
  int probeChannel=leftSource.getLayout().get(left).getChannel();
  PhysicalOperation rightSource=node.getRight().accept(this,context);
  int buildChannel=rightSource.getLayout().get(right).getChannel();
  Preconditions.checkState(leftSource.getOperator().getTupleInfos().get(probeChannel).getFieldCount() == 1 && rightSource.getOperator().getTupleInfos().get(buildChannel).getFieldCount() == 1,"JOIN with the results of a multi-field GROUP BY, DISTINCT or ORDER BY not yet supported");
  SourceHashProvider hashProvider=joinHashFactory.getSourceHashProvider(node,rightSource.getOperator(),buildChannel,operatorStats);
  ImmutableMap.Builder<Symbol,Input> outputMappings=ImmutableMap.builder();
  outputMappings.putAll(leftSource.getLayout());
  int offset=leftSource.getOperator().getChannelCount();
  for (  Map.Entry<Symbol,Input> entry : rightSource.getLayout().entrySet()) {
    Input input=entry.getValue();
    outputMappings.put(entry.getKey(),new Input(offset + input.getChannel(),input.getField()));
  }
  HashJoinOperator operator=new HashJoinOperator(hashProvider,leftSource.getOperator(),probeChannel);
  return new PhysicalOperation(operator,outputMappings.build());
}
