{
  if (closed) {
    log.debug("scheduleRequest() called, but client has been closed");
    return;
  }
  if (future != null) {
    log.debug("scheduleRequest() called, but future is not null");
    return;
  }
  future=httpClient.executeAsync(prepareGet().setHeader(PRESTO_MAX_SIZE,maxResponseSize.toString()).setHeader(PRESTO_PAGE_SEQUENCE_ID,String.valueOf(getSequenceId())).setUri(location).build(),new PageResponseHandler());
  Futures.addCallback(future,new FutureCallback<PagesResponse>(){
    @Override public void onSuccess(    PagesResponse result){
      if (Thread.holdsLock(HttpPageBufferClient.this)) {
        log.error("Can not handle callback while holding a lock on this");
      }
      requestsCompleted.incrementAndGet();
      List<Page> pages;
synchronized (HttpPageBufferClient.this) {
        pages=result.getPages(sequenceId);
        sequenceId+=pages.size();
      }
      for (      Page page : pages) {
        pagesReceived.incrementAndGet();
        clientCallback.addPage(HttpPageBufferClient.this,page);
      }
      if (result.isClientClosed()) {
synchronized (HttpPageBufferClient.this) {
          closed=true;
          future=null;
          lastUpdate=DateTime.now();
        }
        clientCallback.clientFinished(HttpPageBufferClient.this);
      }
 else {
synchronized (HttpPageBufferClient.this) {
          future=null;
          lastUpdate=DateTime.now();
        }
        clientCallback.requestComplete(HttpPageBufferClient.this);
      }
    }
    @Override public void onFailure(    Throwable t){
      if (Thread.holdsLock(HttpPageBufferClient.this)) {
        log.error("Can not handle callback while holding a lock on this");
      }
      requestsCompleted.incrementAndGet();
synchronized (HttpPageBufferClient.this) {
        future=null;
        lastUpdate=DateTime.now();
      }
      clientCallback.requestComplete(HttpPageBufferClient.this);
    }
  }
,executor);
  lastUpdate=DateTime.now();
  requestsScheduled.incrementAndGet();
}
