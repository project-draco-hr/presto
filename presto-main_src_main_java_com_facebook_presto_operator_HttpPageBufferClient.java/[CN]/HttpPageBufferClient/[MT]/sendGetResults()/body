{
  final URI uri=HttpUriBuilder.uriBuilderFrom(location).appendPath(String.valueOf(token)).build();
  HttpResponseFuture<PagesResponse> resultFuture=httpClient.executeAsync(prepareGet().setHeader(PRESTO_MAX_SIZE,maxResponseSize.toString()).setUri(uri).build(),new PageResponseHandler(blockEncodingSerde));
  future=resultFuture;
  Futures.addCallback(resultFuture,new FutureCallback<PagesResponse>(){
    @Override public void onSuccess(    PagesResponse result){
      checkNotHoldsLock();
      resetErrors();
      List<Page> pages;
synchronized (HttpPageBufferClient.this) {
        if (result.getToken() == token) {
          pages=result.getPages();
          token=result.getNextToken();
        }
 else {
          pages=ImmutableList.of();
        }
      }
      for (      Page page : pages) {
        pagesReceived.incrementAndGet();
        clientCallback.addPage(HttpPageBufferClient.this,page);
      }
synchronized (HttpPageBufferClient.this) {
        if (result.isClientComplete()) {
          completed=true;
        }
        future=null;
        lastUpdate=DateTime.now();
      }
      requestsCompleted.incrementAndGet();
      clientCallback.requestComplete(HttpPageBufferClient.this);
    }
    @Override public void onFailure(    Throwable t){
      log.debug("Request to %s failed %s",uri,t);
      checkNotHoldsLock();
      Duration errorDuration=elapsedErrorDuration();
      t=rewriteException(t);
      if (!(t instanceof PrestoException) && errorDuration.compareTo(minErrorDuration) > 0) {
        String message=format("%s (%s - requests failed for %s)",WORKER_NODE_ERROR,uri,errorDuration);
        t=new PageTransportTimeoutException(message,t);
      }
      handleFailure(t);
    }
  }
,executor);
}
