{
  Set<ComparisonExpression> comparisons=IterableTransformer.on(extractConjuncts(predicate)).select(instanceOf(ComparisonExpression.class)).cast(ComparisonExpression.class).select(or(matchesPattern(ComparisonExpression.Type.EQUAL,QualifiedNameReference.class,StringLiteral.class),matchesPattern(ComparisonExpression.Type.EQUAL,StringLiteral.class,QualifiedNameReference.class),matchesPattern(ComparisonExpression.Type.EQUAL,QualifiedNameReference.class,LongLiteral.class),matchesPattern(ComparisonExpression.Type.EQUAL,LongLiteral.class,QualifiedNameReference.class),matchesPattern(ComparisonExpression.Type.EQUAL,QualifiedNameReference.class,DoubleLiteral.class),matchesPattern(ComparisonExpression.Type.EQUAL,DoubleLiteral.class,QualifiedNameReference.class))).set();
  final Map<ColumnHandle,Object> bindings=new HashMap<>();
  for (  ComparisonExpression comparison : comparisons) {
    QualifiedNameReference reference=extractReference(comparison);
    Symbol symbol=Symbol.fromQualifiedName(reference.getName());
    ColumnHandle column=symbolToColumnName.get(symbol);
    if (column != null) {
      Literal literal=extractLiteral(comparison);
      Object value;
      if (literal instanceof DoubleLiteral) {
        value=((DoubleLiteral)literal).getValue();
      }
 else       if (literal instanceof LongLiteral) {
        value=((LongLiteral)literal).getValue();
      }
 else       if (literal instanceof StringLiteral) {
        value=((StringLiteral)literal).getValue();
      }
 else {
        throw new AssertionError(String.format("Literal type (%s) not currently handled",literal.getClass().getName()));
      }
      Object previous=bindings.get(column);
      if (previous != null && !previous.equals(value)) {
        return Optional.absent();
      }
      bindings.put(column,value);
    }
  }
  return Optional.of(bindings);
}
