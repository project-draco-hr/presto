{
  if (!Iterables.all(terms,or(isAliasedQualifiedNameReference(),isAliasedAggregateFunction(metadata)))) {
    return false;
  }
  Iterable<Expression> unnested=concat(Iterables.transform(terms,new Function<Expression,List<Expression>>(){
    @Override public List<Expression> apply(    Expression input){
      if (input instanceof AliasedExpression) {
        return apply(((AliasedExpression)input).getExpression());
      }
      if (input instanceof FunctionCall) {
        return ((FunctionCall)input).getArguments();
      }
      return ImmutableList.of(input);
    }
  }
));
  return Iterables.any(unnested,not(instanceOf(QualifiedNameReference.class)));
}
