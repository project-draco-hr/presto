{
  ImmutableList.Builder<TypeSignatureParameter> parametersBuilder=ImmutableList.builder();
  boolean failedToCalculateLiteral=false;
  for (  TypeSignatureParameter parameter : typeSignature.getParameters()) {
switch (parameter.getKind()) {
case TYPE:
      parametersBuilder.add(TypeSignatureParameter.of(resolveCalculatedType(parameter.getTypeSignature(),inputs)));
    break;
case VARIABLE:
{
    OptionalLong optionalLong=TypeCalculation.calculateLiteralValue(parameter.getVariable(),inputs,false);
    if (optionalLong.isPresent()) {
      parametersBuilder.add(TypeSignatureParameter.of(optionalLong.getAsLong()));
    }
 else {
      failedToCalculateLiteral=true;
    }
    break;
  }
default :
parametersBuilder.add(parameter);
break;
}
}
List<TypeSignatureParameter> calculatedParameters=parametersBuilder.build();
if (failedToCalculateLiteral && !calculatedParameters.isEmpty()) {
throw new IllegalArgumentException(format("Could not evaluate type expression %s with parameter bindings %s",typeSignature,inputs));
}
return new TypeSignature(typeSignature.getBase(),calculatedParameters);
}
