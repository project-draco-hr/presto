{
  List<DriverContext> runningDrivers=ImmutableList.copyOf(this.runningDrivers);
  int totalDriers=completedDrivers.get() + runningDrivers.size();
  int queuedDrivers=0;
  int startedDrivers=0;
  int completedDrivers=this.completedDrivers.get();
  Distribution queuedTime=new Distribution(this.queuedTime);
  Distribution elapsedTime=new Distribution(this.elapsedTime);
  long totalScheduledTime=this.totalScheduledTime.get();
  long totalCpuTime=this.totalCpuTime.get();
  long totalUserTime=this.totalUserTime.get();
  long totalBlockedTime=this.totalBlockedTime.get();
  long rawInputDataSize=this.rawInputDataSize.get();
  long rawInputPositions=this.rawInputPositions.get();
  long processedInputDataSize=this.processedInputDataSize.get();
  long processedInputPositions=this.processedInputPositions.get();
  long outputDataSize=this.outputDataSize.get();
  long outputPositions=this.outputPositions.get();
  List<DriverStats> drivers=new ArrayList<>();
  Multimap<Integer,OperatorStats> runningOperators=ArrayListMultimap.create();
  for (  DriverContext driverContext : runningDrivers) {
    DriverStats driverStats=driverContext.getDriverStats();
    drivers.add(driverStats);
    if (driverStats.getStartTime() == null) {
      queuedDrivers++;
    }
 else {
      startedDrivers++;
    }
    queuedTime.add(driverStats.getQueuedTime().roundTo(NANOSECONDS));
    elapsedTime.add(driverStats.getElapsedTime().roundTo(NANOSECONDS));
    totalScheduledTime+=driverStats.getTotalScheduledTime().roundTo(NANOSECONDS);
    totalCpuTime+=driverStats.getTotalCpuTime().roundTo(NANOSECONDS);
    totalUserTime+=driverStats.getTotalUserTime().roundTo(NANOSECONDS);
    totalBlockedTime+=driverStats.getTotalBlockedTime().roundTo(NANOSECONDS);
    List<OperatorStats> operators=ImmutableList.copyOf(transform(driverContext.getOperatorContexts(),operatorStatsGetter()));
    for (    OperatorStats operator : operators) {
      runningOperators.put(operator.getOperatorId(),operator);
    }
    rawInputDataSize+=driverStats.getRawInputDataSize().toBytes();
    rawInputPositions+=driverStats.getRawInputPositions();
    processedInputDataSize+=driverStats.getProcessedInputDataSize().toBytes();
    processedInputPositions+=driverStats.getProcessedInputPositions();
    outputDataSize+=driverStats.getOutputDataSize().toBytes();
    outputPositions+=driverStats.getOutputPositions();
  }
  TreeMap<Integer,OperatorStats> operatorSummaries=new TreeMap<>();
  for (  Entry<Integer,OperatorStats> entry : this.operatorSummaries.entrySet()) {
    OperatorStats operator=entry.getValue();
    operator.add(runningOperators.get(entry.getKey()));
    operatorSummaries.put(entry.getKey(),operator);
  }
  return new PipelineStats(inputPipeline,outputPipeline,totalDriers,queuedDrivers,startedDrivers,completedDrivers,new DataSize(memoryReservation.get(),BYTE).convertToMostSuccinctDataSize(),queuedTime.snapshot(),elapsedTime.snapshot(),new Duration(totalScheduledTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalCpuTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalUserTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new Duration(totalBlockedTime,NANOSECONDS).convertToMostSuccinctTimeUnit(),new DataSize(rawInputDataSize,BYTE).convertToMostSuccinctDataSize(),rawInputPositions,new DataSize(processedInputDataSize,BYTE).convertToMostSuccinctDataSize(),processedInputPositions,new DataSize(outputDataSize,BYTE).convertToMostSuccinctDataSize(),outputPositions,ImmutableList.copyOf(operatorSummaries.values()),drivers);
}
