{
  Preconditions.checkState(!Thread.holdsLock(this),"Update state can not be called while holding a lock on this");
  cancelStaleRequest();
  Request request;
  CurrentRequest currentRequest;
synchronized (this) {
    if (taskInfo.get().getState().isDone()) {
      return Futures.immediateFuture(null);
    }
    if (!forceRefresh) {
      if (this.currentRequest != null) {
        if (!this.currentRequest.isDone()) {
          this.currentRequest.requestAnotherUpdate();
          return Futures.immediateFuture(null);
        }
        this.currentRequest=null;
      }
      if (!requestRateLimiter.tryAcquire()) {
        return Futures.immediateFuture(null);
      }
    }
    List<TaskSource> sources=getSources();
    currentRequest=new CurrentRequest(sources);
    if (canceled) {
      request=prepareDelete().setUri(taskInfo.get().getSelf()).build();
    }
 else {
      TaskUpdateRequest updateRequest=new TaskUpdateRequest(session,taskInfo.get().getQueryId(),taskInfo.get().getStageId(),planFragment,sources,new OutputBuffers(outputIds,noMoreOutputIds));
      request=preparePost().setUri(uriBuilderFrom(taskInfo.get().getSelf()).build()).setHeader(HttpHeaders.CONTENT_TYPE,MediaType.JSON_UTF_8.toString()).setBodyGenerator(jsonBodyGenerator(taskUpdateRequestCodec,updateRequest)).build();
    }
    this.currentRequest=currentRequest;
  }
  ListenableFuture<JsonResponse<TaskInfo>> future=httpClient.executeAsync(request,createFullJsonResponseHandler(taskInfoCodec));
  currentRequest.setRequestFuture(future);
  return currentRequest;
}
