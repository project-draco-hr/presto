{
  final TaskInfo taskInfo=this.taskInfo.get();
  final TaskInfo canceledTask=new TaskInfo(taskInfo.getQueryId(),taskInfo.getStageId(),taskInfo.getTaskId(),Long.MAX_VALUE,TaskState.CANCELED,taskInfo.getSelf(),taskInfo.getOutputBuffers(),taskInfo.getNoMoreSplits(),taskInfo.getStats(),ImmutableList.<FailureInfo>of());
  if (taskInfo.getSelf() == null) {
    updateTaskInfo(canceledTask);
    return;
  }
  Request request=prepareDelete().setUri(taskInfo.getSelf()).build();
  Futures.addCallback(httpClient.executeAsync(request,createFullJsonResponseHandler(taskInfoCodec)),new FutureCallback<JsonResponse<TaskInfo>>(){
    @Override public void onSuccess(    JsonResponse<TaskInfo> response){
      if (response.hasValue() && response.getValue().getState().isDone()) {
        updateTaskInfo(response);
      }
 else {
        updateTaskInfo(canceledTask);
      }
    }
    @Override public void onFailure(    Throwable t){
      if (isSocketError(t)) {
        log.warn("Failed to cancel task %s: %s",taskInfo.getTaskId(),t.getMessage());
      }
 else {
        log.warn(t,"Failed to cancel task %s",taskInfo.getTaskId());
      }
      updateTaskInfo(canceledTask);
    }
  }
);
}
