{
  pendingSplits.clear();
  if (currentRequest != null) {
    currentRequest.cancel(true);
    currentRequest=null;
    currentRequestStartNanos=0;
  }
  TaskInfo taskInfo=getTaskInfo();
  updateTaskInfo(new TaskInfo(taskInfo.getTaskId(),TaskInfo.MAX_VERSION,TaskState.CANCELED,taskInfo.getSelf(),taskInfo.getOutputBuffers(),taskInfo.getNoMoreSplits(),taskInfo.getStats(),ImmutableList.<SplitExecutionStats>of(),ImmutableList.<FailureInfo>of(),ImmutableMap.<PlanNodeId,Set<?>>of()));
  if (taskInfo.getSelf() != null) {
    final long start=System.nanoTime();
    final Request request=prepareDelete().setUri(taskInfo.getSelf()).build();
    Futures.addCallback(httpClient.executeAsync(request,createStatusResponseHandler()),new FutureCallback<StatusResponse>(){
      @Override public void onSuccess(      StatusResponse result){
      }
      @Override public void onFailure(      Throwable t){
        if (Duration.nanosSince(start).compareTo(new Duration(2,TimeUnit.MINUTES)) < 0) {
          Futures.addCallback(httpClient.executeAsync(request,createStatusResponseHandler()),this,executor);
        }
 else {
          log.error(t,"Unable to cancel task at %s",request.getUri());
        }
      }
    }
,executor);
  }
}
