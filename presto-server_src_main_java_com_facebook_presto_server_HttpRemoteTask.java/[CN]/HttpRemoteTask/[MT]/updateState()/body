{
  Preconditions.checkState(!Thread.holdsLock(this),"Update state can not be called while holding a lock on this");
  cancelStaleRequest();
  Request request;
  CurrentRequest currentRequest;
synchronized (this) {
    if (taskInfo.get().getState().isDone()) {
      return Futures.immediateFuture(null);
    }
    if (updateLoop == null) {
      updateLoop=new UpdateLoop();
      updateLoop.start();
    }
    if (this.currentRequest != null) {
      if (!this.currentRequest.isDone()) {
        this.currentRequest.requestAnotherUpdate();
        return Futures.immediateFuture(null);
      }
      this.currentRequest=null;
    }
    if (errorCount.get() > 0) {
      errorRequestRateLimiter.acquire();
    }
    List<TaskSource> sources=getSources();
    currentRequest=new CurrentRequest(sources);
    TaskUpdateRequest updateRequest=new TaskUpdateRequest(session,planFragment,sources,new OutputBuffers(outputIds,noMoreOutputIds));
    request=preparePost().setUri(uriBuilderFrom(taskInfo.get().getSelf()).build()).setHeader(HttpHeaders.CONTENT_TYPE,MediaType.JSON_UTF_8.toString()).setBodyGenerator(jsonBodyGenerator(taskUpdateRequestCodec,updateRequest)).build();
    this.currentRequest=currentRequest;
  }
  ListenableFuture<JsonResponse<TaskInfo>> future=httpClient.executeAsync(request,createFullJsonResponseHandler(taskInfoCodec));
  currentRequest.setRequestFuture(future);
  return currentRequest;
}
