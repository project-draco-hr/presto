{
  checkNotNull(session,"session is null");
  checkNotNull(taskId,"taskId is null");
  checkNotNull(location,"location is null");
  checkNotNull(planFragment,"planFragment1 is null");
  checkNotNull(outputReceivers,"outputReceivers is null");
  checkNotNull(initialOutputIds,"initialOutputIds is null");
  checkNotNull(httpClient,"httpClient is null");
  checkNotNull(executor,"executor is null");
  checkNotNull(taskInfoCodec,"taskInfoCodec is null");
  checkNotNull(taskUpdateRequestCodec,"taskUpdateRequestCodec is null");
  try (SetThreadName setThreadName=new SetThreadName("HttpRemoteTask-%s",taskId)){
    this.taskId=taskId;
    this.session=session;
    this.nodeId=node.getNodeIdentifier();
    this.planFragment=planFragment;
    this.outputReceivers=ImmutableMap.copyOf(outputReceivers);
    this.outputIds.addAll(initialOutputIds);
    this.httpClient=httpClient;
    this.executor=executor;
    this.taskInfoCodec=taskInfoCodec;
    this.taskUpdateRequestCodec=taskUpdateRequestCodec;
    this.tupleInfos=planFragment.getTupleInfos();
    this.maxConsecutiveErrorCount=maxConsecutiveErrorCount;
    this.minErrorDuration=minErrorDuration;
    for (    Entry<PlanNodeId,URI> entry : initialExchangeLocations.entries()) {
      ScheduledSplit scheduledSplit=new ScheduledSplit(nextSplitId.getAndIncrement(),createRemoteSplitFor(entry.getValue()));
      pendingSplits.put(entry.getKey(),scheduledSplit);
    }
    this.exchangeLocations.putAll(initialExchangeLocations);
    List<BufferInfo> bufferStates=ImmutableList.copyOf(transform(initialOutputIds,new Function<String,BufferInfo>(){
      @Override public BufferInfo apply(      String outputId){
        return new BufferInfo(outputId,false,0,0);
      }
    }
));
    if (initialSplit != null) {
      checkState(planFragment.getPartitioning() != PlanFragment.Partitioning.NONE,"Plan is not partitioned");
      pendingSplits.put(planFragment.getPartitionedSource(),new ScheduledSplit(nextSplitId.getAndIncrement(),initialSplit));
    }
    TaskStats taskStats=new TaskContext(taskId,executor,session).getTaskStats();
    taskInfo=new StateMachine<>("task " + taskId,executor,new TaskInfo(taskId,TaskInfo.MIN_VERSION,TaskState.PLANNED,location,DateTime.now(),new SharedBufferInfo(QueueState.OPEN,0,0,bufferStates),ImmutableSet.<PlanNodeId>of(),taskStats,ImmutableList.<FailureInfo>of(),ImmutableMap.<PlanNodeId,Set<?>>of()));
  }
 }
