{
  List<Split> nextBatch=splitSource.getNextBatch(maxSize);
  Iterable<Split> sampleIterable=Iterables.transform(nextBatch,new Function<Split,Split>(){
    @Override public Split apply(    Split sourceSplit){
      NativeSplit writingSplit=new NativeSplit(UUID.randomUUID(),ImmutableList.<HostAddress>of());
      String partition="unpartitioned";
      boolean lastSplit=false;
      List<? extends PartitionKey> partitionKeys=ImmutableList.of();
      if (sourceSplit instanceof PartitionedSplit) {
        PartitionedSplit partitionedSplit=(PartitionedSplit)sourceSplit;
        partition=partitionedSplit.getPartitionId();
        lastSplit=partitionedSplit.isLastSplit();
        partitionKeys=partitionedSplit.getPartitionKeys();
      }
      addPartitionShard(partition,lastSplit,partitionKeys,writingSplit.getShardUuid());
      CollocatedSplit collocatedSplit=new CollocatedSplit(ImmutableMap.of(planNodeId,sourceSplit,writerNode.getId(),writingSplit),sourceSplit.getAddresses(),sourceSplit.isRemotelyAccessible());
      shardsInFlight.incrementAndGet();
      return collocatedSplit;
    }
  }
);
  if (splitSource.isFinished()) {
    finishOpenPartitions();
    dropAdditionalPartitions();
  }
  return ImmutableList.copyOf(sampleIterable);
}
