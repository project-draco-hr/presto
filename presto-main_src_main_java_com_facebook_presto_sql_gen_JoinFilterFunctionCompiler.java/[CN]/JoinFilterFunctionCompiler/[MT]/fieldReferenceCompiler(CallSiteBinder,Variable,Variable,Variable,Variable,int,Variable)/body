{
  return new RowExpressionVisitor<Scope,BytecodeNode>(){
    @Override public BytecodeNode visitInputReference(    InputReferenceExpression node,    Scope scope){
      int field=node.getField();
      Type type=node.getType();
      Class<?> javaType=type.getJavaType();
      if (!javaType.isPrimitive() && javaType != Slice.class) {
        javaType=Object.class;
      }
      Variable blocksVariable;
      Variable positionVariable;
      if (field < leftBlocksSize) {
        blocksVariable=leftBlocks;
        positionVariable=leftPosition;
      }
 else {
        blocksVariable=rightBlocks;
        positionVariable=rightPosition;
        field-=leftBlocksSize;
      }
      IfStatement ifStatement=new IfStatement();
      ifStatement.condition().setDescription(format("block_%d.get%s()",field,type)).append(blocksVariable.getElement(field)).append(positionVariable).invokeInterface(Block.class,"isNull",boolean.class,int.class);
      ifStatement.ifTrue().putVariable(wasNullVariable,true).pushJavaDefault(javaType);
      String methodName="get" + Primitives.wrap(javaType).getSimpleName();
      ifStatement.ifFalse().append(loadConstant(callSiteBinder.bind(type,Type.class))).append(blocksVariable.getElement(field)).append(positionVariable).invokeInterface(Type.class,methodName,javaType,Block.class,int.class);
      return ifStatement;
    }
    @Override public BytecodeNode visitCall(    CallExpression call,    Scope scope){
      throw new UnsupportedOperationException("only input references are supported");
    }
    @Override public BytecodeNode visitConstant(    ConstantExpression literal,    Scope scope){
      throw new UnsupportedOperationException("only input references are supported");
    }
  }
;
}
