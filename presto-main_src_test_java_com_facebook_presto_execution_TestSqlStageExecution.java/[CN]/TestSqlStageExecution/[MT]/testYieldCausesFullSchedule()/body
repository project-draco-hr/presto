{
  ExecutorService executor=Executors.newCachedThreadPool(Threads.daemonThreadsNamed("test"));
  SqlStageExecution stageExecution=null;
  try {
    MetadataManager metadata=new MetadataManager();
    metadata.addInternalSchemaMetadata(new DualMetadata());
    StageExecutionPlan joinPlan=createJoinPlan("A",metadata);
    InMemoryNodeManager nodeManager=new InMemoryNodeManager();
    nodeManager.addNode("foo",new Node("other",URI.create("http://127.0.0.1:11"),NodeVersion.UNKNOWN));
    stageExecution=new SqlStageExecution(new QueryId("query"),new MockLocationFactory(),joinPlan,new NodeScheduler(nodeManager,new NodeSchedulerConfig()),new MockRemoteTaskFactory(executor),SESSION,1,executor);
    stageExecution.addOutputBuffer("out");
    stageExecution.noMoreOutputBuffers();
    Future<?> future=stageExecution.start();
    long start=System.nanoTime();
    while (true) {
      StageInfo stageInfo=stageExecution.getStageInfo();
      assertEquals(stageInfo.getState(),StageState.SCHEDULING);
      StageInfo tableScanInfo=stageInfo.getSubStages().get(0);
      StageState tableScanState=tableScanInfo.getState();
switch (tableScanState) {
case PLANNED:
case SCHEDULING:
case SCHEDULED:
        break;
case RUNNING:
      assertEquals(stageInfo.getTasks().size(),2);
    assertEquals(tableScanInfo.getTasks().size(),1);
  assertEquals(tableScanInfo.getTasks().get(0).getOutputBuffers().getState(),QueueState.NO_MORE_QUEUES);
return;
case FINISHED:
case CANCELED:
case FAILED:
fail("Unexpected state for table scan stage " + tableScanState);
break;
}
if (TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start) > 1) {
fail("Expected test to complete within 1 second");
}
try {
future.get(50,TimeUnit.MILLISECONDS);
}
 catch (TimeoutException e) {
}
}
}
  finally {
if (stageExecution != null) {
stageExecution.cancel();
}
executor.shutdownNow();
}
}
