{
  ExecutorService executor=Executors.newCachedThreadPool(Threads.daemonThreadsNamed("test"));
  SqlStageExecution stageExecution=null;
  try {
    MetadataManager metadata=new MetadataManager();
    metadata.addInternalSchemaMetadata(MetadataManager.INTERNAL_CONNECTOR_ID,new DualMetadata());
    StageExecutionPlan joinPlan=createJoinPlan("A",metadata);
    InMemoryNodeManager nodeManager=new InMemoryNodeManager();
    nodeManager.addNode("foo",new PrestoNode("other",URI.create("http://127.0.0.1:11"),NodeVersion.UNKNOWN));
    OutputBuffers outputBuffers=INITIAL_EMPTY_OUTPUT_BUFFERS.withBuffer("out",new UnpartitionedPagePartitionFunction()).withNoMoreBufferIds();
    stageExecution=new SqlStageExecution(new QueryId("query"),new MockLocationFactory(),joinPlan,new NodeScheduler(nodeManager,nodeSchedulerConfig,nodeTaskMap),new MockRemoteTaskFactory(executor),SESSION,1000,8,executor,nodeTaskMap,outputBuffers);
    Future<?> future=stageExecution.start();
    long start=System.nanoTime();
    while (true) {
      StageInfo stageInfo=stageExecution.getStageInfo();
      assertEquals(stageInfo.getState(),StageState.SCHEDULING);
      StageInfo tableScanInfo=stageInfo.getSubStages().get(0);
      StageState tableScanState=tableScanInfo.getState();
switch (tableScanState) {
case PLANNED:
case SCHEDULING:
case SCHEDULED:
        break;
case RUNNING:
      assertEquals(stageInfo.getTasks().size(),2);
    assertEquals(tableScanInfo.getTasks().size(),1);
  assertEquals(tableScanInfo.getTasks().get(0).getOutputBuffers().getState(),QueueState.NO_MORE_QUEUES);
return;
case FINISHED:
case CANCELED:
case FAILED:
fail("Unexpected state for table scan stage " + tableScanState);
break;
}
if (TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - start) > 1) {
fail("Expected test to complete within 1 second");
}
try {
future.get(50,TimeUnit.MILLISECONDS);
}
 catch (TimeoutException e) {
}
}
}
  finally {
if (stageExecution != null) {
stageExecution.cancel(false);
}
executor.shutdownNow();
}
}
