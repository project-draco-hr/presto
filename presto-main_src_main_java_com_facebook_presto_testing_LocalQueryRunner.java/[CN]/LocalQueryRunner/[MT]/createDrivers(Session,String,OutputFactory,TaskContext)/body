{
  Statement statement=sqlParser.createStatement(sql);
  assertFormattedSql(sqlParser,statement);
  PlanNodeIdAllocator idAllocator=new PlanNodeIdAllocator();
  FeaturesConfig featuresConfig=new FeaturesConfig().setExperimentalSyntaxEnabled(true).setDistributedIndexJoinsEnabled(false).setOptimizeHashGeneration(true);
  PlanOptimizersFactory planOptimizersFactory=new PlanOptimizersFactory(metadata,sqlParser,indexManager,featuresConfig,true);
  QueryExplainer queryExplainer=new QueryExplainer(planOptimizersFactory.get(),metadata,sqlParser,featuresConfig.isExperimentalSyntaxEnabled());
  Analyzer analyzer=new Analyzer(session,metadata,sqlParser,Optional.of(queryExplainer),featuresConfig.isExperimentalSyntaxEnabled());
  Analysis analysis=analyzer.analyze(statement);
  Plan plan=new LogicalPlanner(session,planOptimizersFactory.get(),idAllocator,metadata).plan(analysis);
  if (printPlan) {
    System.out.println(PlanPrinter.textLogicalPlan(plan.getRoot(),plan.getTypes(),metadata,session));
  }
  SubPlan subplan=new PlanFragmenter().createSubPlans(plan);
  if (!subplan.getChildren().isEmpty()) {
    throw new AssertionError("Expected subplan to have no children");
  }
  LocalExecutionPlanner executionPlanner=new LocalExecutionPlanner(metadata,sqlParser,pageSourceManager,indexManager,pageSinkManager,null,compiler,new IndexJoinLookupStats(),new CompilerConfig().setInterpreterEnabled(false),new TaskManagerConfig().setTaskDefaultConcurrency(4));
  LocalExecutionPlan localExecutionPlan=executionPlanner.plan(session,subplan.getFragment().getRoot(),subplan.getFragment().getOutputLayout(),plan.getTypes(),subplan.getFragment().getDistribution(),outputFactory);
  List<TaskSource> sources=new ArrayList<>();
  long sequenceId=0;
  for (  TableScanNode tableScan : findTableScanNodes(subplan.getFragment().getRoot())) {
    TableLayoutHandle layout=tableScan.getLayout().get();
    SplitSource splitSource=splitManager.getSplits(session,layout);
    ImmutableSet.Builder<ScheduledSplit> scheduledSplits=ImmutableSet.builder();
    while (!splitSource.isFinished()) {
      for (      Split split : getFutureValue(splitSource.getNextBatch(1000))) {
        scheduledSplits.add(new ScheduledSplit(sequenceId++,split));
      }
    }
    sources.add(new TaskSource(tableScan.getId(),scheduledSplits.build(),true));
  }
  List<Driver> drivers=new ArrayList<>();
  Map<PlanNodeId,Driver> driversBySource=new HashMap<>();
  for (  DriverFactory driverFactory : localExecutionPlan.getDriverFactories()) {
    for (int i=0; i < driverFactory.getDriverInstances(); i++) {
      DriverContext driverContext=taskContext.addPipelineContext(driverFactory.isInputDriver(),driverFactory.isOutputDriver()).addDriverContext();
      Driver driver=driverFactory.createDriver(driverContext);
      drivers.add(driver);
      for (      PlanNodeId sourceId : driver.getSourceIds()) {
        driversBySource.put(sourceId,driver);
      }
    }
    driverFactory.close();
  }
  for (  TaskSource source : sources) {
    for (    Driver driver : driversBySource.values()) {
      driver.updateSource(source);
    }
  }
  return ImmutableList.copyOf(drivers);
}
