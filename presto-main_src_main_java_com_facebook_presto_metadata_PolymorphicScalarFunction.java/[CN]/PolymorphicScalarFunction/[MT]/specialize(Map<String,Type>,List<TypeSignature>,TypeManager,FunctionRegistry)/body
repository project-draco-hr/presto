{
  Signature signature=getSignature();
  Map<String,OptionalLong> literalParameters=signature.bindLongVariables(parameterTypes);
  TypeSignature calculatedReturnType=resolveCalculatedType(signature.getReturnType(),literalParameters,true);
  List<Type> resolvedParameterTypes=resolveTypes(parameterTypes,typeManager);
  Type resolvedReturnType=resolveReturnType(types,typeManager,calculatedReturnType);
  SpecializeContext context=new SpecializeContext(types,filterPresentLiterals(literalParameters),resolvedParameterTypes,resolvedReturnType,typeManager,functionRegistry);
  Optional<Method> matchingMethod=Optional.empty();
  Optional<MethodsGroup> matchingMethodsGroup=Optional.empty();
  for (  MethodsGroup candidateMethodsGroup : methodsGroups) {
    for (    Method candidateMethod : candidateMethodsGroup.getMethods()) {
      if (matchesParameterAndReturnTypes(candidateMethod,resolvedParameterTypes,resolvedReturnType) && predicateIsTrue(candidateMethodsGroup,context)) {
        if (matchingMethod.isPresent()) {
          if (onlyFirstMatchedMethodHasPredicate(matchingMethodsGroup.get(),candidateMethodsGroup)) {
            continue;
          }
          throw new IllegalStateException("two matching methods (" + matchingMethod.get().getName() + " and "+ candidateMethod.getName()+ ") for parameter types "+ parameterTypes);
        }
        matchingMethod=Optional.of(candidateMethod);
        matchingMethodsGroup=Optional.of(candidateMethodsGroup);
      }
    }
  }
  checkState(matchingMethod.isPresent(),"no matching method for parameter types %s",parameterTypes);
  List<Object> extraParameters=computeExtraParameters(matchingMethodsGroup.get(),context);
  MethodHandle matchingMethodHandle=applyExtraParameters(matchingMethod.get(),extraParameters);
  return new ScalarFunctionImplementation(nullableResult,nullableArguments,matchingMethodHandle,deterministic);
}
