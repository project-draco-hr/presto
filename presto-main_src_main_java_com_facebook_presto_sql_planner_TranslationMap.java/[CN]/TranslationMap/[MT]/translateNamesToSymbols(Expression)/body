{
  final Map<QualifiedName,Integer> resolvedNames=analysis.getResolvedNames(expression);
  Preconditions.checkArgument(resolvedNames != null,"No resolved names for expression %s",expression);
  return ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>(){
    @Override public Expression rewriteExpression(    Expression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      Expression rewrittenExpression=treeRewriter.defaultRewrite(node,context);
      Type coercion=analysis.getCoercion(node);
      if (coercion != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coercion.getTypeSignature().toString());
      }
      return rewrittenExpression;
    }
    @Override public Expression rewriteQualifiedNameReference(    QualifiedNameReference node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      QualifiedName name=node.getName();
      Integer fieldIndex=resolvedNames.get(name);
      Preconditions.checkState(fieldIndex != null,"No field mapping for name '%s'",name);
      Symbol symbol=rewriteBase.getSymbol(fieldIndex);
      Preconditions.checkState(symbol != null,"No symbol mapping for name '%s' (%s)",name,fieldIndex);
      Expression rewrittenExpression=new QualifiedNameReference(symbol.toQualifiedName());
      if (analysis.isRowFieldReference(node)) {
        QualifiedName mangledName=QualifiedName.of(mangleFieldReference(node.getName().getSuffix()));
        rewrittenExpression=new FunctionCall(mangledName,ImmutableList.of(rewrittenExpression));
      }
      Type coercion=analysis.getCoercion(node);
      if (coercion != null) {
        rewrittenExpression=new Cast(rewrittenExpression,coercion.getTypeSignature().toString());
      }
      return rewrittenExpression;
    }
  }
,expression);
}
