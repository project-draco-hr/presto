{
  return ExpressionTreeRewriter.rewriteWith(new ExpressionRewriter<Void>(){
    @Override public Expression rewriteExpression(    Expression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      if (translatedExpressions.contains(node)) {
        return node;
      }
      Expression rewrittenExpression=treeRewriter.defaultRewrite(node,context);
      return coerceIfNecessary(node,rewrittenExpression);
    }
    @Override public Expression rewriteFieldReference(    FieldReference node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      Symbol symbol=rewriteBase.getSymbol(node.getFieldIndex());
      checkState(symbol != null,"No symbol mapping for node '%s' (%s)",node,node.getFieldIndex());
      return new QualifiedNameReference(symbol.toQualifiedName());
    }
    @Override public Expression rewriteQualifiedNameReference(    QualifiedNameReference node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      if (translatedExpressions.contains(node)) {
        return node;
      }
      return rewriteExpressionWithResolvedName(node);
    }
    private Expression rewriteExpressionWithResolvedName(    Expression node){
      Optional<Integer> fieldIndex=analysis.getFieldIndex(node);
      checkState(fieldIndex.isPresent(),"No field mapping for node '%s'",node);
      Symbol symbol=rewriteBase.getSymbol(fieldIndex.get());
      checkState(symbol != null,"No symbol mapping for node '%s' (%s)",node,fieldIndex.get());
      Expression rewrittenExpression=new QualifiedNameReference(symbol.toQualifiedName());
      return coerceIfNecessary(node,rewrittenExpression);
    }
    @Override public Expression rewriteDereferenceExpression(    DereferenceExpression node,    Void context,    ExpressionTreeRewriter<Void> treeRewriter){
      if (translatedExpressions.contains(node)) {
        return node;
      }
      if (analysis.getFieldIndex(node).isPresent()) {
        return rewriteExpressionWithResolvedName(node);
      }
      return rewriteExpression(node,context,treeRewriter);
    }
    private Expression coerceIfNecessary(    Expression original,    Expression rewritten){
      Type coercion=analysis.getCoercion(original);
      if (coercion != null) {
        rewritten=new Cast(rewritten,coercion.getTypeSignature().toString(),false,analysis.isTypeOnlyCoercion(original));
      }
      return rewritten;
    }
  }
,expression);
}
