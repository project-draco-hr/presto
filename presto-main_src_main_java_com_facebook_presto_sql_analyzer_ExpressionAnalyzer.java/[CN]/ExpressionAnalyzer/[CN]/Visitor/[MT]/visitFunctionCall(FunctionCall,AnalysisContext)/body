{
  if (node.getWindow().isPresent()) {
    for (    Expression expression : node.getWindow().get().getPartitionBy()) {
      process(expression,context);
      Type type=expressionTypes.get(expression);
      if (!type.isComparable()) {
        throw new SemanticException(TYPE_MISMATCH,node,"%s is not comparable, and therefore cannot be used in window function PARTITION BY",type);
      }
    }
    for (    SortItem sortItem : node.getWindow().get().getOrderBy()) {
      process(sortItem.getSortKey(),context);
      Type type=expressionTypes.get(sortItem.getSortKey());
      if (!type.isComparable()) {
        throw new SemanticException(TYPE_MISMATCH,node,"%s is not comparable, and therefore cannot be used in window function ORDER BY",type);
      }
    }
  }
  ImmutableList.Builder<TypeSignature> argumentTypes=ImmutableList.builder();
  for (  Expression expression : node.getArguments()) {
    argumentTypes.add(process(expression,context).getTypeSignature());
  }
  FunctionInfo function=metadata.resolveFunction(node.getName(),argumentTypes.build(),context.isApproximate());
  for (int i=0; i < node.getArguments().size(); i++) {
    Expression expression=node.getArguments().get(i);
    Type type=metadata.getType(function.getArgumentTypes().get(i));
    checkNotNull(type,"Type %s not found",function.getArgumentTypes().get(i));
    coerceType(context,expression,type,String.format("Function %s argument %d",function.getSignature(),i));
  }
  resolvedFunctions.put(node,function);
  Type type=metadata.getType(function.getReturnType());
  expressionTypes.put(node,type);
  return type;
}
